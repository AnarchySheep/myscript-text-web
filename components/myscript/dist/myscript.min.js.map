{"version":3,"sources":["myscript.js","MyScript.js","point.js","quadraticPoint.js","rectangle.js","inkManager.js","penParameters.js","renderingParameters.js","mathUtils.js","abstractWSMessage.js","abstractComponent.js","stroke.js","strokeComponent.js","characterInputComponent.js","characterInputComponentAlternate.js","abstractParameter.js","abstractRecognitionInput.js","abstractRecognitionData.js","recognitionLanguagesData.js","abstractStartRequestWSMessage.js","abstractContinueRequestWSMessage.js","challengeRequestWSMessage.js","initRequestWSMessage.js","resetRequestWSMessage.js","abstractTextInputComponent.js","charInputComponent.js","stringInputComponent.js","textInputUnit.js","textParameter.js","textProperties.js","textRecognitionInput.js","textRecognitionData.js","textStartRequestWSMessage.js","textContinueRequestWSMessage.js","shapeParameter.js","shapeRecognitionInput.js","shapeRecognitionData.js","mathParameter.js","mathRecognitionInput.js","mathRecognitionData.js","mathStartRequestWSMessage.js","mathContinueRequestWSMessage.js","abstractMusicInputComponent.js","musicAccidentalInputComponent.js","musicArpeggiateInputComponent.js","musicBarInputComponent.js","musicBeamInputComponent.js","musicClefInputComponent.js","musicDecorationInputComponent.js","musicDotsInputComponent.js","musicHeadInputComponent.js","musicLedgerLineInputComponent.js","musicRestInputComponent.js","musicStemInputComponent.js","musicTieOrSlurInputComponent.js","musicTimeSignatureInputComponent.js","musicStaff.js","musicParameter.js","musicRecognitionInput.js","musicRecognitionData.js","analyzerParameter.js","analyzerRecognitionInput.js","analyzerRecognitionData.js","abstractResult.js","abstractRecoResponseWSMessage.js","challengeResponseWSMessage.js","errorResponseWSMessage.js","initResponseWSMessage.js","resetResponseWSMessage.js","textInkRange.js","textCandidate.js","textDocument.js","textResult.js","textSegment.js","textTagItem.js","textResponseWSMessage.js","abstractShapePrimitive.js","shapeCandidate.js","shapeDocument.js","shapeEllipse.js","shapeErased.js","shapeInkRange.js","shapeLine.js","shapeNotRecognized.js","shapeRecognized.js","shapeResult.js","shapeScratchOut.js","shapeSegment.js","mathNode.js","mathNonTerminalNode.js","mathResultElement.js","mathRuleNode.js","mathDocument.js","mathInkRange.js","mathLaTexResultElement.js","mathMathMLResultElement.js","mathResult.js","mathScratchOut.js","mathSymbolTreeResultElement.js","mathTerminalNode.js","mathTerminalNodeCandidate.js","mathBorderData.js","mathBorderNonTerminalNode.js","mathCellData.js","mathCellNonTerminalNode.js","mathTableData.js","mathTableRuleNode.js","mathResponseWSMessage.js","musicElement.js","musicResultElement.js","musicAccidental.js","musicAnnotation.js","musicArpeggiate.js","musicBar.js","musicBeam.js","musicChord.js","musicClef.js","musicDecoration.js","musicDocument.js","musicDots.js","musicHead.js","musicInputRange.js","musicKeySignature.js","musicKeySignatureData.js","musicLedgerLine.js","musicNote.js","musicPart.js","musicPitchData.js","musicRest.js","musicResult.js","musicScore.js","musicScoreTreeResultElement.js","musicScratchOut.js","musicSlur.js","musicStem.js","musicTie.js","musicTimeModificationData.js","musicTimeSignature.js","musicTupletBracket.js","musicTuplet.js","musicXMLResultElement.js","analyzerElement.js","analyzerCell.js","analyzerCellData.js","analyzerDocument.js","analyzerElementReference.js","analyzerGroup.js","analyzerInkRange.js","analyzerLine.js","analyzerLineData.js","analyzerRecognizedStroke.js","analyzerResult.js","analyzerStrokeType.js","analyzerTable.js","analyzerTableData.js","analyzerTextLine.js","analyzerTextLineData.js","analyzerUnderline.js","analyzerUnderlineData.js","networkInterface.js","networkWSInterface.js","abstractRecognizer.js","abstractWSRecognizer.js","textRecognizer.js","textWSRecognizer.js","shapeRecognizer.js","mathRecognizer.js","mathWSRecognizer.js","musicRecognizer.js","analyzerRecognizer.js","abstractRenderer.js","textRenderer.js","shapeRenderer.js","mathRenderer.js","musicRenderer.js","analyzerRenderer.js","inkGrabber.js","inkPaper.js"],"names":["CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","prototype","window","Event","Function","bind","oThis","this","TypeError","aArgs","Array","slice","call","arguments","fToBind","fNOP","fBound","apply","concat","MyScript","RecognitionType","TEXT","MATH","SHAPE","MUSIC","ANALYZER","InputMode","CURSIVE","ISOLATED","SUPERIMPOSED","VERTICAL","InputType","CHAR","WORD","SINGLE_LINE_TEXT","MULTI_LINE_TEXT","ResultDetail","CHARACTER","ResultType","Math","LATEX","MATHML","SYMBOLTREE","Music","MUSICXML","SCORETREE","Protocol","WS","REST","scope","Point","obj","x","y","getX","setX","getY","setY","QuadraticPoint","pressure","distance","length","cos","sin","p1","p2","constructor","getPressure","setPressure","getDistance","setDistance","getLength","setLength","getCos","setCos","getSin","setSin","getP1","setP1","getP2","setP2","Rectangle","width","height","getTopLeftPoint","point","setTopLeftPoint","topLeftPoint","getWidth","setWidth","getHeight","setHeight","InkManager","writing","strokes","currentStroke","undoRedoStack","isWriting","getCurrentStroke","startInkCapture","t","Error","isRedoEmpty","clearUndoRedoStack","Stroke","addX","addY","addT","continueInkCapture","endInkCapture","push","clear","isEmpty","undo","pop","redo","getStrokes","getUndoRedoStack","copy","index","PenParameters","color","rectColor","font","decoration","pressureType","alpha","getColor","setColor","getRectColor","setRectColor","getFont","setFont","getDecoration","setDecoration","getPressureType","setPressureType","getAlpha","setAlpha","RenderingParameters","MathUtils","getEllipseArcRect","center","maxRadius","minRadius","orientation","startAngle","sweepAngle","angle","z1","z2","z3","z4","cosAlpha","sinAlpha","n","xList","yList","i","xMin","xMax","yMin","yMax","angleStep","sortFloat","a","b","abs","atan2","sort","getLineRect","firstPoint","lastPoint","xFirst","xLast","min","max","yFirst","yLast","getBoundingRect","boundingBoxes","rectangle","AbstractWSMessage","type","getType","AbstractComponent","setType","getBoundingBox","setBoundingBox","boundingBox","getT","setT","StrokeComponent","p","d","l","toJSON","getP","setP","addP","getD","setD","addD","getL","setL","addL","addPoint","filterPointByAcquisitionDelta","computeP","computeD","computeL","getLastIndexPoint","getPointByIndex","sqrt","pow","isNaN","ratio","parseFloat","delta","ret","CharacterInputComponent","alternates","getAlternates","setAlternates","addAlternate","alternate","CharacterInputComponentAlternate","probability","getAlternate","setAlternate","getProbability","setProbability","AbstractParameter","AbstractRecognitionInput","AbstractRecognitionData","getApplicationKey","applicationKey","setApplicationKey","getInstanceId","instanceId","setInstanceId","getHmac","hmac","setHmac","getRecognitionInput","setRecognitionInput","input","RecognitionLanguagesData","getInputMode","inputMode","setInputMode","AbstractStartRequestWSMessage","AbstractContinueRequestWSMessage","ChallengeRequestWSMessage","getChallenge","challenge","setChallenge","getHmacSignature","setHmacSignature","InitRequestWSMessage","ResetRequestWSMessage","AbstractTextInputComponent","CharInputComponent","getCharacter","character","setCharacter","getLabel","setLabel","label","StringInputComponent","getString","string","setString","TextInputUnit","textInputType","components","getInputType","setInputType","inputType","getComponents","inkRange","TextInkRange","getStartComponent","getEndComponent","setComponents","TextParameter","textProperties","TextProperties","getLanguage","language","setLanguage","textInputMode","getContentTypes","contentTypes","setContentTypes","getSubsetKnowledges","subsetKnowledges","setSubsetKnowledges","getUserResources","userResources","setUserResources","getUserLkWords","userLkWords","setUserLkWords","getResultDetail","resultDetail","setResultDetail","getTextProperties","setTextProperties","getTextCandidateListSize","textCandidateListSize","setTextCandidateListSize","getWordCandidateListSize","wordCandidateListSize","setWordCandidateListSize","getWordPredictionListSize","wordPredictionListSize","setWordPredictionListSize","getWordCompletionListSize","wordCompletionListSize","setWordCompletionListSize","getCharacterCandidateListSize","characterCandidateListSize","setCharacterCandidateListSize","getDiscardCaseVariations","discardCaseVariations","setDiscardCaseVariations","getDiscardAccentuationVariations","discardAccentuationVariations","setDiscardAccentuationVariations","getDisableSpatialOrdering","disableSpatialOrdering","setDisableSpatialOrdering","getGlyphDistortion","glyphDistortion","setGlyphDistortion","getEnableOutOfLexicon","enableOutOfLexicon","setEnableOutOfLexicon","getSpellingDistortion","spellingDistortion","setSpellingDistortion","TextRecognitionInput","getParameters","textParameter","setParameters","parameters","getInputUnits","inputUnits","getStartUnit","getEndUnit","setInputUnits","TextRecognitionData","getTextRecognitionInput","textInput","setTextRecognitionInput","JSON","stringify","TextStartRequestWSMessage","TextContinueRequestWSMessage","ShapeParameter","getRejectDetectionSensitivity","rejectDetectionSensitivity","setRejectDetectionSensitivity","hasBeautification","doBeautification","setBeautification","ShapeRecognitionInput","getDoBeautification","setDoBeautification","ShapeRecognitionData","getShapeRecognitionInput","shapeInput","setShapeRecognitionInput","MathParameter","resultTypes","getResultTypes","setResultTypes","isColumnar","columnarOperation","setColumnar","columnar","getScratchOutDetectionSensitivity","scratchOutDetectionSensitivity","setScratchOutDetectionSensitivity","MathRecognitionInput","MathRecognitionData","getMathRecognitionInput","mathInput","setMathRecognitionInput","MathStartRequestWSMessage","MathContinueRequestWSMessage","AbstractMusicInputComponent","MusicAccidentalInputComponent","getValue","value","setValue","MusicArpeggiateInputComponent","MusicBarInputComponent","MusicBar","MusicBeamInputComponent","MusicBeam","MusicClefInputComponent","MusicClef","MusicDecorationInputComponent","MusicDecoration","MusicDotsInputComponent","MusicHeadInputComponent","MusicLedgerLineInputComponent","MusicRestInputComponent","MusicStemInputComponent","MusicTieOrSlurInputComponent","MusicTimeSignatureInputComponent","MusicStaff","count","gap","getCount","setCount","getTop","top","setTop","getGap","setGap","MusicParameter","getStaff","staff","setStaff","getDivisions","divisions","setDivisions","MusicRecognitionInput","MusicRecognitionData","getMusicRecognitionInput","musicInput","setMusicRecognitionInput","AnalyzerParameter","getTextParameters","setTextParameters","getCoordinateResolution","coordinateResolution","setCoordinateResolution","AnalyzerRecognitionInput","parameter","AnalyzerRecognitionData","getAnalyzerRecognitionInput","analyzerInput","setAnalyzerRecognitionInput","AbstractResult","getDocument","result","AbstractRecoResponseWSMessage","ChallengeResponseWSMessage","ErrorResponseWSMessage","error","getError","InitResponseWSMessage","ResetResponseWSMessage","cpt","split","startUnit","Number","startComponent","startPoint","endUnit","endComponent","endPoint","getStartPoint","getEndPoint","TextCandidate","flags","children","normalizedScore","spellingDistortionRatio","j","TextSegment","getNormalizedScore","getResemblanceScore","resemblanceScore","getSpellingDistortionRatio","getFlags","getChildren","TextDocument","tagItems","wordCandidates","charCandidates","textSegmentResult","TextTagItem","k","getTagItems","getWordSegments","getWordSegment","inkRanges","getInkRanges","getCharSegments","getCharSegment","getTextSegment","hasScratchOutResults","TextResult","getTextDocument","candidates","selectedCandidateIdx","ranges","getCandidates","getSelectedCandidateIdx","getSelectedCandidate","tagType","getTagType","TextResponseWSMessage","AbstractShapePrimitive","beginDecoration","beginTangentAngle","endDecoration","endTangentAngle","isLine","isEllipse","hasBeginDecoration","hasEndDecoration","getBeginDecoration","getEndDecoration","getBeginTangentAngle","getEndTangentAngle","ShapeCandidate","isErased","isScratchOut","isNotRecognized","isRecognized","ShapeDocument","segments","ShapeSegment","getSegments","currentSeg","currentCandidate","ShapeScratchOut","ShapeEllipse","getCenter","getMinRadius","getMaxRadius","getOrientation","getStartAngle","getSweepAngle","ShapeErased","ShapeInkRange","firstStroke","lastStroke","getFirstStroke","getLastStroke","getFirstPoint","getLastPoint","ShapeLine","ShapeNotRecognized","ShapeRecognized","primitives","normalizedRecognitionScore","getPrimitives","getNormalizedRecognitionScore","ShapeResult","getShapeDocument","elementType","uniqueID","selectedCandidateIndex","getElementType","getUniqueId","MathNode","name","getName","MathNonTerminalNode","selectedCandidate","MathTerminalNode","MathRuleNode","MathCellNonTerminalNode","MathBorderNonTerminalNode","MathTableRuleNode","MathResultElement","isLaTex","isMathMl","isSymbolTree","childInkRanges","MathDocument","results","scratchOutResults","MathMathMLResultElement","MathLaTexResultElement","MathSymbolTreeResultElement","MathScratchOut","getResultElements","getScratchOutResults","MathInkRange","component","firstItem","lastItem","getComponent","getFirstItem","getLastItem","MathResult","getMathDocument","erasedInkRanges","getErasedInkRanges","root","getRoot","MathTerminalNodeCandidate","MathBorderData","position","start","stop","getPosition","getStart","getStop","data","getData","MathCellData","columnStart","columnStop","rowStart","rowStop","getColumnStart","getColumnStop","getRowStart","getRowStop","MathTableData","columnCount","rowCount","getColumnCount","getRowCount","MathResponseWSMessage","MusicElement","inputRanges","getInputRanges","MusicResultElement","isMusicXML","isScoreTree","MusicAccidental","MusicAnnotation","MusicArpeggiate","decorations","repeatDirection","style","getRepeatDirection","setRepeatDirection","getStyle","setStyle","getDecorations","setDecorations","slope","placement","leftCount","rightCount","getSlope","setSlope","getPlacement","setPlacement","getLeftCount","setLeftCount","getRightCount","setRightCount","MusicChord","notes","beamTypes","ledgerLines","startSlurs","stopSlurs","duration","arpeggiate","startBeam","stopBeam","stem","MusicStem","MusicNote","MusicLedgerLine","m","MusicSlur","getDuration","getArpeggiate","getStartBeam","getStopBeam","getStem","getNotes","getBeamTypes","getLedgerLines","getStartSlurs","getStopSlurs","symbol","octave","line","yAnchor","getYAnchor","setYAnchor","getLine","setLine","getOctave","setOctave","getSymbol","setSymbol","MusicDocument","MusicXMLResultElement","MusicScoreTreeResultElement","MusicScratchOut","MusicDots","MusicHead","MusicInputRange","MusicKeySignature","accidentals","signature","MusicKeySignatureData","getSignature","getAccidentals","fifths","cancel","getFifths","getCancel","accidental","dots","head","pitch","MusicPitchData","startTie","MusicTie","stopTie","startTuplet","MusicTuplet","stopTuplet","timeModification","MusicTimeModificationData","getAccidental","getDots","getHead","getPitch","getStartTie","getStopTie","getStartTuplet","getStopTuplet","getTimeModification","MusicPart","elements","MusicRest","MusicTimeSignature","MusicTupletBracket","getElements","alteration","step","getAlteration","getStep","MusicResult","getMusicDocument","MusicScore","parts","getParts","score","getScore","erasedInputRanges","getErasedInputRanges","actual","normal","getActual","getNormal","bottom","getBottom","brackets","number","getNumber","getBrackets","AnalyzerElement","AnalyzerCell","AnalyzerCellData","firstColumn","lastColumn","firstRow","lastRow","topBorder","bottomBorder","leftBorder","rightBorder","getFirstColumn","getLastColumn","getFirstRow","getLastRow","hasTopBorder","hasBottomBorder","hasLeftBorder","hasRightBorder","AnalyzerDocument","textLines","shapes","tables","groups","AnalyzerTextLine","AnalyzerTable","AnalyzerGroup","getTextLines","getShapes","getTables","getGroups","AnalyzerElementReference","elementReferences","getElementReferences","AnalyzerInkRange","stroke","AnalyzerRecognizedStroke","getStroke","AnalyzerLine","AnalyzerLineData","AnalyzerResult","getAnalyzerDocument","AnalyzerStrokeType","getInkRange","lines","cells","AnalyzerTableData","getLines","getCells","underlineList","AnalyzerTextLineData","AnalyzerUnderline","getUnderlineList","baselinePos","toMidline","textHeight","justificationType","getBaselinePos","getToMidline","getTextHeight","getJustificationType","AnalyzerUnderlineData","firstCharacter","lastCharacter","getFirstCharacter","getLastCharacter","Q","NetworkInterface","parse","req","responseText","e","transformRequest","str","encodeURIComponent","join","xhr","url","onStateChange","request","readyState","status","deferred","resolve","onLoad","reject","onError","onProgress","notify","loaded","total","defer","XMLHttpRequest","open","withCredentials","setRequestHeader","onload","onerror","onprogress","onreadystatechange","send","promise","get","src","put","post","NetworkWSInterface","callback","_url","_callback","_socket","isClosed","isClosing","isOpen","isConnecting","close","code","reason","self","WebSocket","onopen","onclose","onmessage","CryptoJS","AbstractRecognizer","host","setHost","getHost","getAvailableLanguageList","then","response","doRestRecognition","hmacKey","_computeHmac","_doTextRecognition","_doShapeRecognition","_doMathRecognition","_doMusicRecognition","_doAnalyzerRecognition","clearRestRecognition","instanceSessionId","_clearShapeRecognition","computeHmac","jsonInput","HmacSHA512","toString","enc","Hex","AbstractWSRecognizer","_init","endpoint","_wsInterface","sendMessage","message","initWSRecognition","takeUpHmacChallenge","resetWSRecognition","TextRecognizer","doSimpleRecognition","TextWSRecognizer","_endpoint","startWSRecognition","continueWSRecognition","ShapeRecognizer","clearShapeRecognitionSession","MathRecognizer","MathWSRecognizer","MusicRecognizer","AnalyzerRecognizer","AbstractRenderer","context","penParameters","showBoundingBoxes","typeset","points","drawing","_computeLinksPoints","radius","_computeMiddlePoint","point1","point2","_computeAxeAngle","begin","end","_fill","fillStyle","fill","_renderStroke","beginPath","arc","PI","_renderLine","nbquadratics","_renderQuadratic","_renderFinal","closePath","ARCSPLIT","linkPoints","moveTo","newAngle","lineTo","linkPoints1","linkPoints2","ctrl","linkPoints3","quadraticCurveTo","getContext","_setContext","getShowBoundingBoxes","setShowBoundingBoxes","isTypesetting","setTypeset","clearRect","canvas","drawRecognitionResult","recognitionResult","drawComponents","drawComponent","drawStroke","drawCharacter","drawRectangle","save","strokeStyle","lineWidth","fillRect","restore","drawStart","drawContinue","drawEnd","drawStrokes","last","pA","pB","pAB","_computePointParameters","_computeFirstControls","_computeControls","_drawFirstSegment","pC","pBC","_drawSegment","_drawPoint","_computeLastControls","_drawLastSegment","globalAlpha","previous","dx","dy","_computePressure","first","next","penWidth","r","nx","ny","u","TextRenderer","drawInputUnits","_drawTextComponent","drawTextComponent","_drawChar","_drawString","char","ShapeRenderer","drawShapes","_drawShapePrimitive","drawShapeSegment","segment","candidate","_drawShapeRecognized","drawShapeNotRecognized","drawShapeRecognized","shapeRecognized","notRecognized","_extractShapeNotRecognized","drawShapePrimitive","primitive","drawShapeLine","shapeLine","_drawShapeLine","drawShapeEllipse","shapeEllipse","_drawShapeEllipse","_drawLine","_drawArrowHead","_drawEllipseArc","extractStroke","centerPoint","floor","boundariesPoints","_phi","headPoint","beta","firstPointIndex","lastPointIndex","ceil","strokeIndex","currentStrokePointCount","newStroke","pointIndex","MathRenderer","notScratchOutComponents","_removeMathScratchOut","removeScratchOut","cloneComponents","componentsToRemove","z","splice","MusicRenderer","_removeMusicScratchOut","drawStaff","_drawStaff","_drawMusicNode","drawMusicNode","staffHeight","staves","offset","clientWidth","_drawAccidental","_drawArpeggiate","_drawBar","_drawBeam","_drawClef","_drawDecoration","_drawDots","_drawHead","_drawLedgerLine","_drawRest","_drawStem","_drawTieOrSlur","_drawTimeSignature","bar","beam","clef","imageObj","Image","drawImage","ledgerLine","rest","tieOrSlur","timeSignature","AnalyzerRenderer","shapeRenderer","getShapeRenderer","setShapeRenderer","_drawTables","_drawTextLines","drawTables","_drawCell","drawTextLines","textLine","drawText","text","baseline","_drawText","drawUnderline","underline","_drawUnderline","drawGroups","_drawGroups","drawCell","cell","underlines","textAlign","fillText","topLeft","textMetrics","measureText","substring","x1","x2","InkGrabber","startCapture","continueCapture","endCapture","InkPaper","element","options","_element","_instanceId","_timerId","_initialized","redoComponents","lastNonRecoComponentIdx","resultCallback","changeCallback","protocol","timeout","textParameters","mathParameters","shapeParameters","musicParameters","analyzerParameters","_captureCanvas","_createCanvas","_inkGrabber","_renderingCanvas","_textRenderer","_mathRenderer","_shapeRenderer","_musicRenderer","_analyzerRenderer","_textRecognizer","_mathRecognizer","_shapeRecognizer","_musicRecognizer","_analyzerRecognizer","_textWSRecognizer","_handleMessage","_mathWSRecognizer","_attachListeners","idx","_initialize","_getOptions","parent","id","querySelectorAll","createElement","appendChild","_getCoordinates","container","changedTouches","rect","getBoundingClientRect","clientX","left","clientLeft","clientY","clientTop","timeStamp","_initRenderingCanvas","setProtocol","_selectedRecognizer","_selectedRESTRecognizer","setTimeout","_selectedWSRecognizer","getProtocol","_selectedRenderer","getTimeout","getHmacKey","setHmacKey","isStarted","map","toUpperCase","setMathParameters","getMathParameters","setShapeParameters","getShapeParameters","setMusicParameters","getMusicParameters","setAnalyzerParameters","getAnalyzerParameters","setPenParameters","getPenParameters","_setHost","getAvailableLanguages","getRenderer","getInkGrabber","getRecognizer","setCallback","setChangeCallback","setResultCallback","recognize","_doRecognition","canUndo","_onChange","canRedo","clearTimeout","_onResult","addDomListener","useCapture","myfunction","addEventListener","_down","clientHeight","_move","_up","inputWS","inputUnitWS","inputUnit","_parseResult","done","err","dispatchEvent","changes","pointerId","preventDefault","coord","console","log","_drawInput","replayNeeded"],"mappings":"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","file":"myscript.min.js","sourcesContent":["/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n\n\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Complex Point object used for quadratic calculation\n     *\n     * @deprecated\n     * @class QuadraticPoint\n     * @extends Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function QuadraticPoint(obj) {\n        scope.Point.call(this, obj);\n        this.pressure = 0.5;\n        this.distance = 0.0;\n        this.length = 0.0;\n        this.cos = 0.0;\n        this.sin = 0.0;\n        this.p1 = new scope.Point(obj);\n        this.p2 = new scope.Point(obj);\n        if (obj) {\n            this.pressure = obj.pressure;\n            this.distance = obj.distance;\n            this.length = obj.length;\n            this.cos = obj.cos;\n            this.sin = obj.sin;\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    QuadraticPoint.prototype = new scope.Point();\n\n    /**\n     * Constructor property\n     */\n    QuadraticPoint.prototype.constructor = QuadraticPoint;\n\n    /**\n     * Get pressure\n     *\n     * @method getPressure\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getPressure = function () {\n        return this.pressure;\n    };\n\n    /**\n     * Set pressure\n     *\n     * @method setPressure\n     * @param {Number} pressure\n     */\n    QuadraticPoint.prototype.setPressure = function (pressure) {\n        this.pressure = pressure;\n    };\n\n    /**\n     * Get distance\n     *\n     * @method getDistance\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getDistance = function () {\n        return this.distance;\n    };\n\n    /**\n     * Set distance\n     *\n     * @method setDistance\n     * @param {Number} distance\n     */\n    QuadraticPoint.prototype.setDistance = function (distance) {\n        this.distance = distance;\n    };\n\n    /**\n     * Get length\n     *\n     * @method getLength\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getLength = function () {\n        return this.length;\n    };\n\n    /**\n     * Set length\n     *\n     * @method setLength\n     * @param {Number} length\n     */\n    QuadraticPoint.prototype.setLength = function (length) {\n        this.length = length;\n    };\n\n    /**\n     * Get cos\n     *\n     * @method getCos\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getCos = function () {\n        return this.cos;\n    };\n\n    /**\n     * Set cos\n     *\n     * @method setCos\n     * @param {Number} cos\n     */\n    QuadraticPoint.prototype.setCos = function (cos) {\n        this.cos = cos;\n    };\n\n    /**\n     * Get sin\n     *\n     * @method getSin\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getSin = function () {\n        return this.sin;\n    };\n\n    /**\n     * Set sin\n     *\n     * @method setSin\n     * @param {Number} sin\n     */\n    QuadraticPoint.prototype.setSin = function (sin) {\n        this.sin = sin;\n    };\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Set p1\n     *\n     * @method setP1\n     * @param {Point} p1\n     */\n    QuadraticPoint.prototype.setP1 = function (p1) {\n        this.p1 = p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    /**\n     * Set p2\n     *\n     * @method setP2\n     * @param {Point} p2\n     */\n    QuadraticPoint.prototype.setP2 = function (p2) {\n        this.p2 = p2;\n    };\n\n    // Export\n    scope.QuadraticPoint = QuadraticPoint;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * The InkManager class that can use to store writing strokes and manage the undo/redo/clear system\n     *\n     * @deprecated\n     * @class InkManager\n     * @constructor\n     */\n    function InkManager() {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    }\n\n    /**\n     * Is Writing a stroke\n     *\n     * @deprecated\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last current Stroke write\n     *\n     * @deprecated\n     * @method getCurrentStroke\n     * @returns {Stroke}\n     */\n    InkManager.prototype.getCurrentStroke = function () {\n        return this.currentStroke;\n    };\n\n    /**\n     * Start ink capture\n     *\n     * @deprecated\n     * @method startInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.startInkCapture = function (x, y, t) {\n        if (!this.writing) {\n            if (!this.isRedoEmpty()) {\n                this.clearUndoRedoStack();\n            }\n            this.currentStroke = new scope.Stroke();\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n            this.writing = true;\n        } else {\n            throw new Error('Stroke capture already running');\n        }\n    };\n\n    /**\n     * Continue ink capture\n     *\n     * @deprecated\n     * @method continueInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.continueInkCapture = function (x, y, t) {\n        if (this.writing) {\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * End ink capture\n     *\n     * @deprecated\n     * @method endInkCapture\n     */\n    InkManager.prototype.endInkCapture = function () {\n        if (this.writing) {\n            this.strokes.push(this.currentStroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * Clear the strokes list\n     *\n     * @deprecated\n     * @method clear\n     */\n    InkManager.prototype.clear = function () {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Is The Strokes list is empty\n     *\n     * @deprecated\n     * @method isEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isEmpty = function () {\n        return this.strokes.length === 0;\n    };\n\n    /**\n     * Is the Undo/Redo Stack empty\n     *\n     * @method isRedoEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isRedoEmpty = function () {\n        return this.undoRedoStack.length === 0;\n    };\n\n    /**\n     * Make an undo\n     *\n     * @deprecated\n     * @method undo\n     */\n    InkManager.prototype.undo = function () {\n        if (!this.isEmpty()) {\n            this.undoRedoStack.push(this.strokes.pop());\n        }\n    };\n\n    /**\n     * Make a redo\n     *\n     * @deprecated\n     * @method redo\n     */\n    InkManager.prototype.redo = function () {\n        if (!this.isRedoEmpty()) {\n            this.strokes.push(this.undoRedoStack.pop());\n        }\n    };\n\n    /**\n     * Get the strokes list\n     *\n     * @deprecated\n     * @method getStokes\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getStrokes = function () {\n        return this.strokes;\n    };\n\n    /**\n     * Get the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method getUndoRedoStack\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getUndoRedoStack = function () {\n        return this.undoRedoStack;\n    };\n\n    /**\n     * Clear the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method clearUndoRedoStack\n     */\n    InkManager.prototype.clearUndoRedoStack = function () {\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Copy the strokes values from index on an other list of strokes\n     *\n     * @deprecated\n     * @method copy\n     * @param {Stroke[]} strokes List of strokes\n     * @param {Number} index Position to start the copy\n     */\n    InkManager.prototype.copy = function (strokes, index) {\n        for (index; index < this.strokes.length; index++) {\n            strokes.push(this.strokes[index]);\n        }\n    };\n\n    // Export\n    scope.InkManager = InkManager;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get the pressure renderer parameter\n     *\n     * @deprecated\n     * @method getPressureType\n     * @returns {String} The pressure type\n     */\n    PenParameters.prototype.getPressureType = function () {\n        return this.pressureType;\n    };\n\n    /**\n     * Set the pressure renderer parameter\n     *\n     * @deprecated\n     * @method setPressureType\n     * @param {String} pressureType\n     */\n    PenParameters.prototype.setPressureType = function (pressureType) {\n        this.pressureType = pressureType;\n    };\n\n    /**\n     * Get the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method getAlpha\n     * @returns {String} The alpha\n     */\n    PenParameters.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * Set the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method setAlpha\n     * @param {String} alpha\n     */\n    PenParameters.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @deprecated Use 'PenParameters' instead\n     * @class RenderingParameters\n     * @constructor\n     */\n    function RenderingParameters() {\n        scope.PenParameters.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    RenderingParameters.prototype = new scope.PenParameters();\n\n    /**\n     * Constructor property\n     */\n    RenderingParameters.prototype.constructor = RenderingParameters;\n\n    // Export\n    scope.RenderingParameters = RenderingParameters;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @deprecated Use StrokeComponent instead\n     * @class Stroke\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function Stroke(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.t = obj.t;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    Stroke.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    Stroke.prototype.constructor = Stroke;\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    Stroke.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    Stroke.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    Stroke.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    Stroke.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    Stroke.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    Stroke.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    Stroke.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    Stroke.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    // Export\n    scope.Stroke = Stroke;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @class StrokeComponent\n     * @extends Stroke\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.Stroke.call(this);\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            this.p = obj.p;\n            this.d = obj.p;\n            this.l = obj.l;\n            this.color = obj.color;\n            this.alpha = obj.alpha;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.Stroke();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**     *\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (this.filterPointByAcquisitionDelta(x, y)) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(this.computeP(x, y));\n            this.addD(this.computeD(x, y));\n            this.addL(this.computeL(x, y));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    StrokeComponent.prototype.computeD = function (x, y) {\n        var distance = Math.sqrt(Math.pow((y - this.getY()[this.getLastIndexPoint() - 1]), 2) + Math.pow((x - this.getX()[this.getLastIndexPoint() - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    };\n\n    StrokeComponent.prototype.computeL = function (x, y) {\n        var length = this.getL()[this.getLastIndexPoint() - 1] + this.computeD(x, y);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    };\n\n    StrokeComponent.prototype.computeP = function (x, y) {\n        var ratio = 1.0;\n        var distance = this.computeD(x, y);\n        var length = this.computeL(x, y);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    };\n\n    StrokeComponent.prototype.filterPointByAcquisitionDelta = function (x, y) {\n        var delta = (2 + (this.getWidth() / 4));\n        var ret = false;\n        if (this.getLength() === 0 || Math.abs(this.getX()[this.getLastIndexPoint()] - x) >= delta || Math.abs(this.getY()[this.getLastIndexPoint()] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    };\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent() {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(alternate, probability) {\n        this.alternate = alternate;\n        this.probability = probability;\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent() {\n        scope.AbstractComponent.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent() {\n        this.type = 'char';\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get character\n     *\n     * @deprecated Use 'getLabel'\n     * @method getCharacter\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getCharacter = function () {\n        return this.character;\n    };\n\n    /**\n     * Set character\n     *\n     * @deprecated Use 'setLabel'\n     * @method setCharacter\n     * @param {String} character\n     */\n    CharInputComponent.prototype.setCharacter = function (character) {\n        this.character = character;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent() {\n        this.type = 'string';\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get string\n     *\n     * @deprecated Use 'getLabel'\n     * @method getString\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getString = function () {\n        return this.string;\n    };\n\n    /**\n     * Set string\n     *\n     * @deprecated Use 'setLabel'\n     * @method setString\n     * @param {String} string\n     */\n    StringInputComponent.prototype.setString = function (string) {\n        this.string = string;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties() {\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getTextRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getTextRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setTextRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setTextRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method getDoBeautification\n     * @returns {Boolean}\n     */\n    ShapeRecognitionInput.prototype.getDoBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setDoBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeRecognitionInput.prototype.setDoBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Number}\n     */\n    ShapeRecognitionInput.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Number} rejectDetectionSensitivity\n     */\n    ShapeRecognitionInput.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getShapeRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getShapeRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setShapeRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setShapeRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathRecognitionInput.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathRecognitionInput.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n    /**\n     * Get math input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMathRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getMathRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMathRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setMathRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent() {\n        scope.AbstractComponent.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent() {\n        this.type = 'accidental';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent() {\n        this.type = 'arpeggiate';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent() {\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent() {\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent() {\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent() {\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent() {\n        this.type = 'dots';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent() {\n        this.type = 'head';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent() {\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent() {\n        this.type = 'rest';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent() {\n        this.type = 'stem';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent() {\n        this.type = 'tieOrSlur';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent() {\n        this.type = 'timeSignature';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff() {\n        this.count = 5;\n        this.gap = 20;\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the result types\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the result types\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicRecognitionInput.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRecognitionInput.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicRecognitionInput.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMusicRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getMusicRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMusicRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setMusicRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getAnalyzerRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getAnalyzerRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setAnalyzerRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setAnalyzerRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            var cpt = obj.split(/[:-]+/);\n            this.startUnit = Number(cpt[0]);\n            this.startComponent = Number(cpt[1]);\n            this.startPoint = Number(cpt[2]);\n            this.endUnit = Number(cpt[3]);\n            this.endComponent = Number(cpt[4]);\n            this.endPoint = Number(cpt[5]);\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordCandidates = [];\n        this.charCandidates = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordCandidates) {\n                this.wordCandidates.push(new scope.TextSegment(obj.wordCandidates[j]));\n            }\n            for (var k in obj.charCandidates) {\n                this.charCandidates.push(new scope.TextSegment(obj.charCandidates[k]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordCandidates;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charCandidates;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResult.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges.split(/[\\s]+/);\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges.split(/[\\s]+/);\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResponseWSMessage.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    /**\n     * Get shape document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getShapeDocument\n     * @returns {ShapeDocument}\n     */\n    ShapeResult.prototype.getShapeDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);\n(function (scope) {\n    \n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResult.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResponseWSMessage.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    /**\n     * Get music document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMusicDocument\n     * @returns {MusicDocument}\n     */\n    MusicResult.prototype.getMusicDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    /**\n     * Get analyzer document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getAnalyzerDocument\n     * @returns {AnalyzerDocument}\n     */\n    AnalyzerResult.prototype.getAnalyzerDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);\n\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        var deferred = Q.defer();\n\n        function onStateChange() {\n            if (request.readyState === 4) {\n                if (request.status >= 200 && request.status < 300) {\n                    deferred.resolve(NetworkInterface.parse(request));\n                }\n            }\n        }\n\n        function onLoad() {\n            if (request.status >= 200 && request.status < 300) {\n                deferred.resolve(NetworkInterface.parse(request));\n            } else {\n                deferred.reject(new Error(request.responseText));\n            }\n        }\n\n        function onError() {\n            deferred.reject(new Error('Can\\'t XHR ' + url));\n        }\n\n        function onProgress(event) {\n            deferred.notify(event.loaded / event.total);\n        }\n\n        var request = new XMLHttpRequest();\n        request.open(type, url, true);\n        request.withCredentials = true;\n        request.setRequestHeader('Accept', 'application/json');\n        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        request.onload = onLoad;\n        request.onerror = onError;\n        request.onprogress = onProgress;\n        request.onreadystatechange = onStateChange;\n        request.send(NetworkInterface.transformRequest(data));\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n\n\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface(url, callback) {\n        this._url = url;\n        this._callback = callback;\n    }\n\n    NetworkWSInterface.prototype.send = function (request) {\n        if (this._socket) {\n            this._socket.send(JSON.stringify(request));\n        }\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        if (this._socket) {\n            return this._socket.readyState === 3;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        if (this._socket) {\n            return this._socket.readyState === 2;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        if (this._socket) {\n            return this._socket.readyState === 1;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        if (this._socket) {\n            return this._socket.readyState === 0;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this._socket) {\n            this._socket.close(code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        var self = this;\n        this._socket = new WebSocket(this._url);\n\n        this._socket.onopen = function (e) {\n            self._callback(e);\n        };\n        this._socket.onclose = function (e) {\n            self._callback(e);\n        };\n        this._socket.onerror = function (e) {\n            self._callback(e);\n        };\n\n        this._socket.onmessage = function (e) {\n            self._callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        };\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n\n\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.host = 'cloud.myscript.com';\n        if (host) {\n            this.setHost(host);\n        }\n    }\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return this.host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.host = host;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get('https://' + this.getHost() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @method doRestRecognition\n     * @param {AbstractRecognitionData} data\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (data, applicationKey, hmacKey, instanceId) {\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n\n        if (data instanceof scope.TextRecognitionData) {\n            return _doTextRecognition(this.getHost(), data);\n        } else if (data instanceof scope.ShapeRecognitionData) {\n            return _doShapeRecognition(this.getHost(), data);\n        } else if (data instanceof scope.MathRecognitionData) {\n            return _doMathRecognition(this.getHost(), data);\n        } else if (data instanceof scope.MusicRecognitionData) {\n            return _doMusicRecognition(this.getHost(), data);\n        } else if (data instanceof scope.AnalyzerRecognitionData) {\n            return _doAnalyzerRecognition(this.getHost(), data);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getHost(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} host\n     * @param {TextRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} host\n     * @param {ShapeRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} host\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} host\n     * @param {MathRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} host\n     * @param {MusicRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} host\n     * @param {AnalyzerRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @deprecated\n     * @method computeHmac\n     * @param {String} applicationKey\n     * @param {String} data\n     * @param {String} hmacKey\n     */\n    AbstractRecognizer.prototype.computeHmac = function (applicationKey, data, hmacKey) {\n        return _computeHmac(data, applicationKey, hmacKey);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n\n\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractWSRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractWSRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AbstractWSRecognizer.prototype.constructor = AbstractWSRecognizer;\n\n    AbstractWSRecognizer.prototype._init = function (endpoint, callback) {\n        this._wsInterface = new scope.NetworkWSInterface(endpoint, callback);\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(this.computeHmac(applicationKey, challenge, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, inputUnits, hmacKey, parameters) {\n        var input = new scope.TextRecognitionInput();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n\n        var data = new scope.TextRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this, host);\n        this._endpoint = 'wss://' + this.getHost() + '/api/v3.0/recognition/ws/text';\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this._init(this._endpoint, function (message) {\n            switch (message.type) {\n                case 'open':\n                    callback(message);\n                    break;\n                case 'close':\n                    callback(message);\n                    break;\n                case 'error':\n                    callback(undefined, message);\n                    break;\n                default:\n                    switch (message.data.type) {\n                        case 'init':\n                            message.data = new scope.InitResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'reset':\n                            message.data = new scope.ResetResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'error':\n                            message.data = new scope.ErrorResponseWSMessage(message.data);\n                            callback(undefined, message.data);\n                            break;\n                        case 'hmacChallenge':\n                            message.data = new scope.ChallengeResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        default:\n                            message.data = new scope.TextResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                    }\n                    break;\n            }\n        });\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (inputUnits, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (inputUnits, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.ShapeRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setDoBeautification(params.hasBeautification());\n        input.setRejectDetectionSensitivity(params.getRejectDetectionSensitivity());\n\n        var data = new scope.ShapeRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.MathRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setResultTypes(params.getResultTypes());\n        input.setColumnar(params.isColumnar());\n        input.setScratchOutDetectionSensitivity(params.getScratchOutDetectionSensitivity());\n        input.setUserResources(params.getUserResources());\n\n        var data = new scope.MathRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this, host);\n        this._endpoint = 'wss://' + this.getHost() + '/api/v3.0/recognition/ws/math';\n        this.parameters = new scope.MathParameter();\n        this._init(this._endpoint, function (message) {\n            switch (message.type) {\n                case 'open':\n                    callback(message);\n                    break;\n                case 'close':\n                    callback(message);\n                    break;\n                case 'error':\n                    callback(undefined, message);\n                    break;\n                default:\n                    switch (message.data.type) {\n                        case 'init':\n                            message.data = new scope.InitResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'reset':\n                            message.data = new scope.ResetResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'error':\n                            message.data = new scope.ErrorResponseWSMessage(message.data);\n                            callback(undefined, message.data);\n                            break;\n                        case 'hmacChallenge':\n                            message.data = new scope.ChallengeResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        default:\n                            message.data = new scope.MathResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                    }\n                    break;\n            }\n        });\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);\n\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.MusicRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setStaff(params.getStaff());\n        input.setDivisions(params.getDivisions());\n        input.setResultTypes(params.getResultTypes());\n        input.setScratchOutDetectionSensitivity(params.getScratchOutDetectionSensitivity());\n        input.setUserResources(params.getUserResources());\n\n        var data = new scope.MusicRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setParameters(params);\n\n        var data = new scope.AnalyzerRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n        this.points = [];\n        this.drawing = false;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * Set the context (legacy code for non-regression)\n     *\n     * @private\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype._setContext = function (context) {\n        this.context = context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponents = function (components, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponent = function (component, context, parameters) {\n        if (component instanceof scope.Stroke) {\n            this.drawStroke(component, context, parameters);\n        } else if (component instanceof scope.CharacterInputComponent) {\n            this.drawCharacter(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @method drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRectangle = function (rectangle, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n\n        var params = this.getParameters();\n        this.getContext().save();\n        try {\n            this.getContext().fillStyle = params.getRectColor();\n            this.getContext().strokeStyle = params.getColor();\n            this.getContext().lineWidth = 0.5 * params.getWidth();\n            this.getContext().fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            this.getContext().restore();\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method drawStroke\n     * @param {Stroke} stroke\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStroke = function (stroke, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (stroke && stroke.getLength() > 0) {\n            if (stroke instanceof scope.StrokeComponent) {\n                _renderStroke(stroke, this.getContext());\n            } else {\n                this.drawStart(stroke.getX()[0], stroke.getY()[0]);\n                for (var i = 0; i < stroke.getLength(); ++i) {\n                    this.drawContinue(stroke.getX()[i], stroke.getY()[i], context, parameters);\n                }\n                this.drawEnd(stroke.getX()[stroke.getLength() - 1], stroke.getY()[stroke.getLength() - 1], context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw stroke components\n     *\n     * @private\n     * @method drawStrokes\n     * @param {Stroke[]} strokes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStrokes = function (strokes, context, parameters) {\n        for (var i = 0; i < strokes.length; i++) {\n            this.drawStroke(strokes[i], context, parameters);\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    /**\n     * DEPRECATED METHODS\n     */\n\n    /**\n     * Record the beginning of drawing\n     *\n     * @deprecated\n     * @method drawStart\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStart = function (x, y, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        this.points = [];\n        this.drawing = true;\n        this.points.push(new scope.QuadraticPoint({x: x, y: y}));\n    };\n\n    /**\n     * Record the drawing\n     *\n     * @deprecated\n     * @method drawContinue\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawContinue = function (x, y, context, parameters) {\n        if (this.drawing) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            var params = this.getParameters();\n            var delta = 2 + (params.getWidth() / 4);\n            var last = this.points[this.points.length - 1];\n\n            if (Math.abs(last.getX() - x) >= delta || Math.abs(last.getY() - y) >= delta) {\n\n                if (this.points.length === 1) { // firstPoint\n\n                    var pA = this.points[this.points.length - 1]; // firstPoint\n                    var pB = new scope.QuadraticPoint({x: x, y: y});\n                    var pAB = new scope.QuadraticPoint({\n                        x: 0.5 * (pA.getX() + pB.getX()),\n                        y: 0.5 * (pA.getY() + pB.getY())\n                    });\n                    _computePointParameters(pA, pAB, params.getPressureType());\n                    _computePointParameters(pAB, pB, params.getPressureType());\n\n                    _computeFirstControls(pA, pAB, params.getWidth());\n                    _computeControls(pAB, pB, params.getWidth());\n\n                    this.points.push(pAB);\n                    this.points.push(pB);\n\n                    _drawFirstSegment(pA, pAB, this.getContext(), params);\n\n                } else {\n                    var pAB = this.points[this.points.length - 2]; // jshint ignore:line\n                    var pB = this.points[this.points.length - 1]; // jshint ignore:line\n                    var pC = new scope.QuadraticPoint({x: x, y: y});\n                    var pBC = new scope.QuadraticPoint({\n                        x: 0.5 * (pB.getX() + pC.getX()),\n                        y: 0.5 * (pB.getY() + pC.getY())\n                    });\n                    _computePointParameters(pB, pBC, params.getPressureType());\n                    _computePointParameters(pBC, pC, params.getPressureType());\n\n                    _computeControls(pB, pBC, params.getWidth());\n                    _computeControls(pBC, pC, params.getWidth());\n\n                    this.points.push(pBC);\n                    this.points.push(pC);\n\n                    _drawSegment(pAB, pB, pBC, this.getContext(), params);\n                }\n            }\n        }\n    };\n\n    /**\n     * Stop record of drawing\n     *\n     * @deprecated\n     * @method drawEnd\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawEnd = function (x, y, context, parameters) {\n        if (this.drawing) {\n            var params = this.getParameters();\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            if (this.points.length === 1) {\n                _drawPoint(new scope.QuadraticPoint({x: x, y: y}), this.getContext(), params);\n            } else if (this.points.length > 1) {\n                var pA = this.points[this.points.length - 1];\n                var pB = new scope.QuadraticPoint({x: x, y: y});\n                var pAB = new scope.QuadraticPoint({\n                    x: 0.5 * (pA.getX() + pB.getX()),\n                    y: 0.5 * (pA.getY() + pB.getY())\n                });\n                _computePointParameters(pA, pAB, params.getPressureType());\n                _computePointParameters(pAB, pB, params.getPressureType());\n\n                _computeControls(pA, pAB, params.getWidth());\n                _computeLastControls(pB, params.getWidth());\n\n                this.points.push(pAB);\n                this.points.push(pB);\n\n                _drawLastSegment(pAB, pB, this.getContext(), params);\n            }\n            this.drawing = false;\n        }\n    };\n\n    /**\n     * Draw point on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawPoint\n     * @param {QuadraticPoint} point\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawPoint = function (point, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.arc(point.getX(), point.getY(), 0.25 * parameters.getWidth(), 0, 2 * Math.PI);\n            context.fill();\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw the first stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawFirstSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawFirstSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw middle stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {QuadraticPoint} pC\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawSegment = function (pA, pB, pC, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.quadraticCurveTo(pB.getP1().getX(), pB.getP1().getY(), pC.getP1().getX(), pC.getP1().getY());\n            context.lineTo(pC.getP2().getX(), pC.getP2().getY());\n            context.quadraticCurveTo(pB.getP2().getX(), pB.getP2().getY(), pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw the last stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawLastSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLastSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Compute distance and unit vector from the previous point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePointParameters\n     * @param {QuadraticPoint} previous\n     * @param {QuadraticPoint} point\n     * @param {String} pressureType\n     */\n    var _computePointParameters = function (previous, point, pressureType) {\n        var dx = point.getX() - previous.getX(),\n            dy = point.getY() - previous.getY(),\n            d = Math.sqrt((dx * dx) + (dy * dy));\n\n        if (d !== 0) {\n            point.setDistance(d);\n            point.setCos(dx / d);\n            point.setSin(dy / d);\n        }\n        point.setLength(previous.getLength() + point.getDistance());\n\n        switch (pressureType) {\n            case 'SIMULATED':\n                _computePressure(point);\n                break;\n            case 'CONSTANT':\n                point.setPressure(1.0);\n                break;\n            case 'REAL':\n                // keep the current pressure\n                break;\n            default:\n                throw new Error('Unknown pressure type');\n        }\n    };\n\n    /**\n     * Compute simulated pressure of given point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePressure\n     * @param {QuadraticPoint} point\n     */\n    var _computePressure = function (point) {\n        var k, pressure;\n        if (point.getDistance() < 10) {\n            k = 0.2 + Math.pow(0.1 * point.getDistance(), 0.4);\n        } else if (point.getDistance() > point.getLength() - 10) {\n            k = 0.2 + Math.pow(0.1 * (point.getLength() - point.getDistance()), 0.4);\n        } else {\n            k = 1.0;\n        }\n\n        pressure = k * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(point.getDistance()));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        point.setPressure(pressure);\n    };\n\n    /**\n     * Compute control points of the first point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeFirstControls\n     * @param {QuadraticPoint} first First point of the list to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeFirstControls = function (first, next, penWidth) {\n        var r = 0.5 * (penWidth * first.getPressure()),\n            nx = r * next.getSin(),\n            ny = r * next.getCos();\n\n        first.getP1().setX(first.getX() - nx);\n        first.getP1().setY(first.getY() + ny);\n        first.getP2().setX(first.getX() + nx);\n        first.getP2().setY(first.getY() - ny);\n    };\n\n    /**\n     * Compute control points between two points.\n     *\n     * @private\n     * @deprecated\n     * @method _computeControls\n     * @param {QuadraticPoint} point Point to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeControls = function (point, next, penWidth) {\n        var cos = point.getCos() + next.getCos(),\n            sin = point.getSin() + next.getSin(),\n            u = Math.sqrt((cos * cos) + (sin * sin));\n\n        if (u !== 0) {\n            // compute control points\n            var r = 0.5 * penWidth * point.getPressure();\n            var nx = -r * sin / u;\n            var ny = r * cos / u;\n            point.getP1().setX(point.getX() + nx);\n            point.getP1().setY(point.getY() + ny);\n            point.getP2().setX(point.getX() - nx);\n            point.getP2().setY(point.getY() - ny);\n        }\n    };\n\n    /**\n     * Compute control points of the last point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeLastControls\n     * @param {QuadraticPoint} last Last point to be computed\n     * @param {Number} penWidth Pen width\n     */\n    var _computeLastControls = function (last, penWidth) {\n        var r = 0.5 * penWidth * last.getPressure(),\n            nx = -r * last.getSin(),\n            ny = r * last.getCos();\n\n        last.getP1().setX(last.getX() + nx);\n        last.getP1().setY(last.getY() + ny);\n        last.getP2().setX(last.getX() - nx);\n        last.getP2().setY(last.getY() - ny);\n    };\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (inputUnits, recognitionResult, context, parameters) {\n        this.drawInputUnits(inputUnits, context, parameters);\n    };\n\n    /**\n     * Draw input units\n     *\n     * @method drawInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawInputUnits = function (inputUnits, context, parameters) {\n        for (var i in inputUnits) {\n            this.drawComponents(inputUnits[i].getComponents(), context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @deprecated\n     * @method drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawTextComponent = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawTextComponent(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (this.isTypesetting()) {\n            this.drawShapes(components, recognitionResult.getSegments(), context, parameters);\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes, context, parameters) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawShapeNotRecognized(components, segment.getInkRanges(), context, parameters);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @deprecated\n     * @method drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeRecognized(shapeRecognized, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges, context, parameters) {\n        var notRecognized = _extractShapeNotRecognized(components, inkRanges);\n        this.drawComponents(notRecognized, context, parameters);\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @deprecated\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @deprecated\n     * @method drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeLine = function (shapeLine, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeLine(shapeLine, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @deprecated\n     * @method drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeEllipse(shapeEllipse, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Get strokes from shape inkRange\n     *\n     * @deprecated\n     * @method extractStroke\n     * @param {Stroke[]} strokes\n     * @param {ShapeInkRange} inkRange\n     * @result {Stroke[]} List of strokes from inkRange\n     */\n    ShapeRenderer.prototype.extractStroke = function (strokes, inkRange) {\n        return _extractShapeNotRecognized(strokes, inkRange);\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {*}\n     */\n    var _extractShapeNotRecognized = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex - 1];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.Stroke(), x = [], y = [];\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    x.push(currentStroke.getX()[pointIndex]);\n                    y.push(currentStroke.getY()[pointIndex]);\n                }\n\n                newStroke.setX(x);\n                newStroke.setY(y);\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMathScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MathScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MathRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMathScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMathScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getErasedInkRanges()[n].getComponent());\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getInkRanges()[p].getComponent());\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MusicScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MusicRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMusicScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawStaff = function (staff, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw music node\n     *\n     * @method drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawMusicNode = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawMusicNode(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (this.isTypesetting()) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes(), context, parameters);\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component, context, parameters);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @deprecated\n     * @method drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTables = function (components, tables, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in tables) {\n            if (this.getShowBoundingBoxes()) {\n                for (var j in tables[i].getCells()) {\n                    _drawCell(tables[i].getCells()[j], this.getContext(), this.getParameters());\n                }\n            }\n        }\n        _drawTables(components, tables, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @deprecated\n     * @method drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTextLines = function (components, textLines, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data && this.getShowBoundingBoxes()) {\n                this.drawRectangle(data.getBoundingBox(), context, parameters);\n            }\n        }\n        _drawTextLines(components, textLines, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @deprecated\n     * @method drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawText(boundingBox, text, justificationType, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Underline\n     *\n     * @deprecated\n     * @method drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawUnderline(boundingBox, underline, text, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @deprecated\n     * @method drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        _drawGroups(components, groups, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @deprecated\n     * @method drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n            _drawCell(cell, this.getContext(), this.getParameters());\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n\n\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        // Capture\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer(options? options.host : undefined);\n        this._mathRecognizer = new scope.MathRecognizer(options? options.host : undefined);\n        this._shapeRecognizer = new scope.ShapeRecognizer(options? options.host : undefined);\n        this._musicRecognizer = new scope.MusicRecognizer(options? options.host : undefined);\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer(options? options.host : undefined);\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this), options? options.host : undefined);\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this), options? options.host : undefined);\n\n        this._attachListeners(element);\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        this._initialize(this._getOptions());\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        this._captureCanvas.width = width;\n        this._renderingCanvas.width = width;\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        this._captureCanvas.height = height;\n        this._renderingCanvas.height = height;\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @deprecated Use setTextParameters instead\n     * @method setLanguage\n     * @param  String language\n     */\n    InkPaper.prototype.setLanguage = function (language) {\n        if(this.options.type === scope.RecognitionType.TEXT){\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setLanguage(language);\n        }\n    };\n\n    /**\n     * Set math recognition format result types\n     *\n     * @deprecated Use setMathParameters instead\n     * @method setResultTypes\n     * @param  Array resultTypes\n     */\n    InkPaper.prototype.setResultTypes = function (resultTypes) {\n        if(this.options.type === scope.RecognitionType.MATH){\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setResultTypes(resultTypes.map(function(x) { return x.toUpperCase(); }));\n        }\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * @private\n     * @method _initialize\n     * @param {Object} options\n     */\n    InkPaper.prototype._initialize = function (options) {\n\n        this._setHost(options.host);\n\n        this.setTextParameters(options.textParameters); // jshint ignore:line\n        this.setMathParameters(options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(options.analyzerParameters); // jshint ignore:line\n\n        // Recognition type\n        this.setType(options.type);\n        this.setProtocol(options.protocol);\n        this.setTimeout(options.timeout);\n        this.setApplicationKey(options.applicationKey);\n        this.setHmacKey(options.hmacKey);\n\n        this.setPenParameters(options.penParameters);\n        this.setTypeset(options.typeset);\n\n        this.setWidth(options.width);\n        this.setHeight(options.height);\n    };\n\n    /**\n     * Get options\n     *\n     * @private\n     * @method _getOptions\n     * @returns {Object}\n     */\n    InkPaper.prototype._getOptions = function () {\n        return this.options;\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @returns {Promise}\n     */\n    InkPaper.prototype.getAvailableLanguages = function () {\n        return this._selectedRecognizer.getAvailableLanguageList(this.getApplicationKey(), this._textRecognizer.getParameters().getInputMode());\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the recognition callback\n     *\n     * @method setCallback\n     * @deprecated Use setResultCallback instead\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     */\n    InkPaper.prototype.setCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        return this._doRecognition(this.components);\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this.components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            this.redoComponents.push(this.components.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this.redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this.components.push(this.redoComponents.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            if (this._instanceId) {\n                this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                this._instanceId = undefined;\n            }\n        }\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this._inkGrabber.clear();\n        this._instanceId = undefined;\n\n        this._initRenderingCanvas();\n        this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n\n        if(this._captureCanvas.clientHeight != this._captureCanvas.height){\n            this._captureCanvas.height = this._captureCanvas.clientHeight;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight;\n        }\n        if(this._captureCanvas.clientWidth != this._captureCanvas.width){\n            this._captureCanvas.width = this._captureCanvas.clientWidth;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth;\n        }\n\n        if (this.canRedo()) {\n            this.redoComponents = [];\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n        }\n        this._inkGrabber.startCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this.components.push(stroke);\n        this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            }\n        }\n    };\n\n    /**\n     * Do recognition\n     *\n     * @private\n     * @method _doRecognition\n     * @param {AbstractComponent[]} components Input components\n     */\n    InkPaper.prototype._doRecognition = function (components) {\n        if (components.length > 0) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                if (this._initialized) {\n                    var inputWS = [];\n                    if (this._selectedRecognizer instanceof scope.TextWSRecognizer) {\n                        var inputUnitWS = new scope.TextInputUnit();\n                        inputUnitWS.setComponents(this._getOptions().components.concat(components.slice(this.lastNonRecoComponentIdx)));\n                        inputWS = [inputUnitWS];\n                    } else {\n                        inputWS = components.slice(this.lastNonRecoComponentIdx);\n                    }\n                    this.lastNonRecoComponentIdx = components.length;\n\n\n                    if (this.isStarted) {\n                        this._selectedRecognizer.continueWSRecognition(inputWS, this._instanceId);\n                    } else {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(inputWS);\n                    }\n                }\n            } else {\n                var input = [];\n                if (this._selectedRecognizer instanceof scope.TextRecognizer) {\n                    var inputUnit = new scope.TextInputUnit();\n                    inputUnit.setComponents(this._getOptions().components.concat(components));\n                    input = [inputUnit];\n                } else if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                    input = components.slice(this.lastNonRecoComponentIdx);\n                    this.lastNonRecoComponentIdx = components.length;\n                } else {\n                    input = input.concat(this._getOptions().components, components);\n                }\n                this._selectedRecognizer.doSimpleRecognition(\n                    this.getApplicationKey(),\n                    this._instanceId,\n                    input,\n                    this.getHmacKey()\n                ).then(\n                    function (data) {\n                        return this._parseResult(data, input);\n                    }.bind(this),\n                    function (error) {\n                        this._onResult(undefined, error);\n                        return error;\n                    }.bind(this)\n                ).done();\n            }\n        } else {\n            this.isStarted = false;\n            this._selectedRenderer.clear();\n            this._initRenderingCanvas();\n            this._onResult();\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('failure', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function (changes) {\n        if (this.changeCallback) {\n            this.changeCallback(changes)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: changes}));\n    };\n\n    InkPaper.prototype._parseResult = function (data, input) {\n\n        if (!this._instanceId) {\n            this._instanceId = data.getInstanceId();\n        } else if (this._instanceId !== data.getInstanceId()) {\n            this._onResult(data);\n            return data;\n        }\n\n        if (data.getDocument().hasScratchOutResults() || this._selectedRenderer.isTypesetting()) {\n            this._selectedRenderer.clear();\n            this._selectedRenderer.drawRecognitionResult(input, data.getDocument());\n        }\n\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service host\n     *\n     * @private\n     * @param {String} host\n     */\n    InkPaper.prototype._setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n                console.log('pointerenter');\n                console.log(e);\n            }\n        }, false);\n\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n        this._drawInput(this.components);\n    };\n\n    InkPaper.prototype._drawInput = function (components) {\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            } else {\n                throw new Error('Missing music staff');\n            }\n        }\n        this._selectedRenderer.drawComponents(this._getOptions().components.concat(components));\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this.lastNonRecoComponentIdx = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge (this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    break;\n                default: {\n                    this._parseResult(message, this.components);\n                    break;\n                }\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n","/**\n * Polyfills\n */\n(function () {\n    /**\n     * CustomEvent\n     */\n    function CustomEvent ( event, params ) {    // jshint ignore:line\n        params = params || { bubbles: false, cancelable: false, detail: undefined };\n        var evt = document.createEvent( 'CustomEvent' );\n        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    window.CustomEvent = CustomEvent;\n\n    /**\n     * bind()\n     */\n    if (!Function.prototype.bind) {\n        Function.prototype.bind = function(oThis) {\n            if (typeof this !== 'function') {\n                // closest thing possible to the ECMAScript 5\n                // internal IsCallable function\n                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n            }\n\n            var aArgs   = Array.prototype.slice.call(arguments, 1),\n                fToBind = this,\n                fNOP    = function() {},\n                fBound  = function() {\n                    return fToBind.apply(this instanceof fNOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n                };\n\n            fNOP.prototype = this.prototype;\n            fBound.prototype = new fNOP(); // jshint ignore:line\n\n            return fBound;\n        };\n    }\n})();\n\n/**\n * MyScript javascript library\n *\n * @module MyScript\n * @requires Q\n * @requires CryptoJS\n */\n/*global MyScript:true */\nMyScript = {\n    RecognitionType: {\n        TEXT: 'TEXT',\n        MATH: 'MATH',\n        SHAPE: 'SHAPE',\n        MUSIC: 'MUSIC',\n        ANALYZER: 'ANALYZER'\n    },\n    InputMode: {\n        CURSIVE: 'CURSIVE',\n        ISOLATED: 'ISOLATED',\n        SUPERIMPOSED: 'SUPERIMPOSED',\n        VERTICAL: 'VERTICAL'\n    },\n    InputType: {\n        CHAR: 'CHAR',\n        WORD: 'WORD',\n        SINGLE_LINE_TEXT: 'SINGLE_LINE_TEXT',\n        MULTI_LINE_TEXT: 'MULTI_LINE_TEXT'\n    },\n    ResultDetail: {\n        TEXT: 'TEXT',\n        WORD: 'WORD',\n        CHARACTER: 'CHARACTER'\n    },\n    ResultType: {\n        Math: {\n            LATEX: 'LATEX',\n            MATHML: 'MATHML',\n            SYMBOLTREE: 'SYMBOLTREE'\n        },\n        Music: {\n            MUSICXML: 'MUSICXML',\n            SCORETREE: 'SCORETREE'\n        }\n    },\n    Protocol: {\n        WS: 'WebSocket',\n        REST: 'REST'\n    }\n};\n","'use strict';\n\n(function (scope) {\n    /**\n     * Point\n     *\n     * @class Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Point(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Point.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Point.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Point.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Point.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    // Export\n    scope.Point = Point;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Complex Point object used for quadratic calculation\n     *\n     * @deprecated\n     * @class QuadraticPoint\n     * @extends Point\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function QuadraticPoint(obj) {\n        scope.Point.call(this, obj);\n        this.pressure = 0.5;\n        this.distance = 0.0;\n        this.length = 0.0;\n        this.cos = 0.0;\n        this.sin = 0.0;\n        this.p1 = new scope.Point(obj);\n        this.p2 = new scope.Point(obj);\n        if (obj) {\n            this.pressure = obj.pressure;\n            this.distance = obj.distance;\n            this.length = obj.length;\n            this.cos = obj.cos;\n            this.sin = obj.sin;\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    QuadraticPoint.prototype = new scope.Point();\n\n    /**\n     * Constructor property\n     */\n    QuadraticPoint.prototype.constructor = QuadraticPoint;\n\n    /**\n     * Get pressure\n     *\n     * @method getPressure\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getPressure = function () {\n        return this.pressure;\n    };\n\n    /**\n     * Set pressure\n     *\n     * @method setPressure\n     * @param {Number} pressure\n     */\n    QuadraticPoint.prototype.setPressure = function (pressure) {\n        this.pressure = pressure;\n    };\n\n    /**\n     * Get distance\n     *\n     * @method getDistance\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getDistance = function () {\n        return this.distance;\n    };\n\n    /**\n     * Set distance\n     *\n     * @method setDistance\n     * @param {Number} distance\n     */\n    QuadraticPoint.prototype.setDistance = function (distance) {\n        this.distance = distance;\n    };\n\n    /**\n     * Get length\n     *\n     * @method getLength\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getLength = function () {\n        return this.length;\n    };\n\n    /**\n     * Set length\n     *\n     * @method setLength\n     * @param {Number} length\n     */\n    QuadraticPoint.prototype.setLength = function (length) {\n        this.length = length;\n    };\n\n    /**\n     * Get cos\n     *\n     * @method getCos\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getCos = function () {\n        return this.cos;\n    };\n\n    /**\n     * Set cos\n     *\n     * @method setCos\n     * @param {Number} cos\n     */\n    QuadraticPoint.prototype.setCos = function (cos) {\n        this.cos = cos;\n    };\n\n    /**\n     * Get sin\n     *\n     * @method getSin\n     * @returns {Number}\n     */\n    QuadraticPoint.prototype.getSin = function () {\n        return this.sin;\n    };\n\n    /**\n     * Set sin\n     *\n     * @method setSin\n     * @param {Number} sin\n     */\n    QuadraticPoint.prototype.setSin = function (sin) {\n        this.sin = sin;\n    };\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Set p1\n     *\n     * @method setP1\n     * @param {Point} p1\n     */\n    QuadraticPoint.prototype.setP1 = function (p1) {\n        this.p1 = p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    QuadraticPoint.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    /**\n     * Set p2\n     *\n     * @method setP2\n     * @param {Point} p2\n     */\n    QuadraticPoint.prototype.setP2 = function (p2) {\n        this.p2 = p2;\n    };\n\n    // Export\n    scope.QuadraticPoint = QuadraticPoint;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Rectangle\n     *\n     * @class Rectangle\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function Rectangle(obj) {\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.width = obj.width;\n            this.height = obj.height;\n        }\n    }\n\n    /**\n     * Get top-left x\n     *\n     * @method getX\n     * @returns {Number}\n     */\n    Rectangle.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set top-left x\n     *\n     * @method setX\n     * @param {Number} x\n     */\n    Rectangle.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Get top-left y\n     *\n     * @method getY\n     * @returns {Number}\n     */\n    Rectangle.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set top-left y\n     *\n     * @method setY\n     * @param {Number} y\n     */\n    Rectangle.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    Rectangle.prototype.getTopLeftPoint = function () {\n        var point = new scope.Point();\n        point.setX(this.x);\n        point.setY(this.y);\n        return point;\n    };\n\n    /**\n     * Set top-left point\n     *\n     * @method setTopLeftPoint\n     * @param {Point} topLeftPoint\n     */\n    Rectangle.prototype.setTopLeftPoint = function (topLeftPoint) {\n        this.x = topLeftPoint.getX();\n        this.y = topLeftPoint.getY();\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    Rectangle.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    Rectangle.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    Rectangle.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Set height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    Rectangle.prototype.setHeight = function (height) {\n        this.height = height;\n    };\n\n    // Export\n    scope.Rectangle = Rectangle;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * The InkManager class that can use to store writing strokes and manage the undo/redo/clear system\n     *\n     * @deprecated\n     * @class InkManager\n     * @constructor\n     */\n    function InkManager() {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    }\n\n    /**\n     * Is Writing a stroke\n     *\n     * @deprecated\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last current Stroke write\n     *\n     * @deprecated\n     * @method getCurrentStroke\n     * @returns {Stroke}\n     */\n    InkManager.prototype.getCurrentStroke = function () {\n        return this.currentStroke;\n    };\n\n    /**\n     * Start ink capture\n     *\n     * @deprecated\n     * @method startInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.startInkCapture = function (x, y, t) {\n        if (!this.writing) {\n            if (!this.isRedoEmpty()) {\n                this.clearUndoRedoStack();\n            }\n            this.currentStroke = new scope.Stroke();\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n            this.writing = true;\n        } else {\n            throw new Error('Stroke capture already running');\n        }\n    };\n\n    /**\n     * Continue ink capture\n     *\n     * @deprecated\n     * @method continueInkCapture\n     * @param {Number} x abscissa coordinate\n     * @param {Number} y ordinate coordinate\n     * @param {Number} [t] event timestamp\n     */\n    InkManager.prototype.continueInkCapture = function (x, y, t) {\n        if (this.writing) {\n            this.currentStroke.addX(x);\n            this.currentStroke.addY(y);\n            this.currentStroke.addT(t);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * End ink capture\n     *\n     * @deprecated\n     * @method endInkCapture\n     */\n    InkManager.prototype.endInkCapture = function () {\n        if (this.writing) {\n            this.strokes.push(this.currentStroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    /**\n     * Clear the strokes list\n     *\n     * @deprecated\n     * @method clear\n     */\n    InkManager.prototype.clear = function () {\n        this.writing = false;\n        this.strokes = [];\n        this.currentStroke = null;\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Is The Strokes list is empty\n     *\n     * @deprecated\n     * @method isEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isEmpty = function () {\n        return this.strokes.length === 0;\n    };\n\n    /**\n     * Is the Undo/Redo Stack empty\n     *\n     * @method isRedoEmpty\n     * @returns {Boolean}\n     */\n    InkManager.prototype.isRedoEmpty = function () {\n        return this.undoRedoStack.length === 0;\n    };\n\n    /**\n     * Make an undo\n     *\n     * @deprecated\n     * @method undo\n     */\n    InkManager.prototype.undo = function () {\n        if (!this.isEmpty()) {\n            this.undoRedoStack.push(this.strokes.pop());\n        }\n    };\n\n    /**\n     * Make a redo\n     *\n     * @deprecated\n     * @method redo\n     */\n    InkManager.prototype.redo = function () {\n        if (!this.isRedoEmpty()) {\n            this.strokes.push(this.undoRedoStack.pop());\n        }\n    };\n\n    /**\n     * Get the strokes list\n     *\n     * @deprecated\n     * @method getStokes\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getStrokes = function () {\n        return this.strokes;\n    };\n\n    /**\n     * Get the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method getUndoRedoStack\n     * @returns {Stroke[]}\n     */\n    InkManager.prototype.getUndoRedoStack = function () {\n        return this.undoRedoStack;\n    };\n\n    /**\n     * Clear the Undo/Redo Stack\n     *\n     * @deprecated\n     * @method clearUndoRedoStack\n     */\n    InkManager.prototype.clearUndoRedoStack = function () {\n        this.undoRedoStack = [];\n    };\n\n    /**\n     * Copy the strokes values from index on an other list of strokes\n     *\n     * @deprecated\n     * @method copy\n     * @param {Stroke[]} strokes List of strokes\n     * @param {Number} index Position to start the copy\n     */\n    InkManager.prototype.copy = function (strokes, index) {\n        for (index; index < this.strokes.length; index++) {\n            strokes.push(this.strokes[index]);\n        }\n    };\n\n    // Export\n    scope.InkManager = InkManager;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @class PenParameters\n     * @constructor\n     */\n    function PenParameters(obj) {\n        this.color = 'rgba(0, 0, 0, 0.9)';\n        this.rectColor = 'rgba(0, 0, 0, 0.2)';\n        this.font = 'Times New Roman';\n        this.decoration = 'normal';\n        this.width = 4;\n        this.pressureType = 'SIMULATED';\n        this.alpha = '1.0';\n        if (obj) {\n            this.color = obj.color;\n            this.rectColor = obj.rectColor;\n            this.font = obj.font;\n            this.decoration = obj.decoration;\n            this.width = obj.width;\n            this.pressureType = obj.pressureType;\n            this.alpha = obj.alpha;\n        }\n    }\n\n    /**\n     * Get the color renderer parameter\n     *\n     * @method getColor\n     * @returns {String} The color of the ink\n     */\n    PenParameters.prototype.getColor = function () {\n        return this.color;\n    };\n\n    /**\n     * Set the color renderer parameter\n     *\n     * @method setColor\n     * @param {String} color\n     */\n    PenParameters.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * Get the rect renderer parameter\n     *\n     * @method getRectColor\n     * @returns {String} the rectangle color\n     */\n    PenParameters.prototype.getRectColor = function () {\n        return this.rectColor;\n    };\n\n    /**\n     * Set the rect renderer parameter\n     *\n     * @method setRectColor\n     * @param {String} rectColor\n     */\n    PenParameters.prototype.setRectColor = function (rectColor) {\n        this.rectColor = rectColor;\n    };\n\n    /**\n     * Get the font renderer parameter\n     *\n     * @method getFont\n     * @returns {String} The font\n     */\n    PenParameters.prototype.getFont = function () {\n        return this.font;\n    };\n\n    /**\n     * Set the font renderer parameter\n     *\n     * @method setFont\n     * @param {String} font\n     */\n    PenParameters.prototype.setFont = function (font) {\n        this.font = font;\n    };\n\n    /**\n     * Get the decoration renderer parameter\n     *\n     * @method getDecoration\n     * @returns {String} The decoration\n     */\n    PenParameters.prototype.getDecoration = function () {\n        return this.decoration;\n    };\n\n    /**\n     * Set the decoration renderer parameter\n     *\n     * @method setDecoration\n     * @param {String} decoration\n     */\n    PenParameters.prototype.setDecoration = function (decoration) {\n        this.decoration = decoration;\n    };\n\n    /**\n     * Get the width renderer parameter\n     *\n     * @method getWidth\n     * @returns {Number} The ink width\n     */\n    PenParameters.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Set the width renderer parameter\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    PenParameters.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    /**\n     * Get the pressure renderer parameter\n     *\n     * @deprecated\n     * @method getPressureType\n     * @returns {String} The pressure type\n     */\n    PenParameters.prototype.getPressureType = function () {\n        return this.pressureType;\n    };\n\n    /**\n     * Set the pressure renderer parameter\n     *\n     * @deprecated\n     * @method setPressureType\n     * @param {String} pressureType\n     */\n    PenParameters.prototype.setPressureType = function (pressureType) {\n        this.pressureType = pressureType;\n    };\n\n    /**\n     * Get the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method getAlpha\n     * @returns {String} The alpha\n     */\n    PenParameters.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * Set the alpha renderer parameter\n     *\n     * @deprecated Use a rgba() color\n     * @method setAlpha\n     * @param {String} alpha\n     */\n    PenParameters.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    // Export\n    scope.PenParameters = PenParameters;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for both input and output canvas draw.\n     *\n     * @deprecated Use 'PenParameters' instead\n     * @class RenderingParameters\n     * @constructor\n     */\n    function RenderingParameters() {\n        scope.PenParameters.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    RenderingParameters.prototype = new scope.PenParameters();\n\n    /**\n     * Constructor property\n     */\n    RenderingParameters.prototype.constructor = RenderingParameters;\n\n    // Export\n    scope.RenderingParameters = RenderingParameters;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * The mathUtil class is use to calculate lines\n     *\n     * @class MathUtil\n     * @constructor\n     */\n    function MathUtils() {\n    }\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains an ellipse arc.\n     *\n     * @method getEllipseArcRect\n     * @param {Point} center\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {Number} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @returns {Rectangle}\n     */\n    MathUtils.getEllipseArcRect = function (center, maxRadius, minRadius, orientation, startAngle, sweepAngle) {\n\n        var angleStep = 0.02, // angle delta between interpolated points on the arc, in radian\n            angle, // angle\n            alpha, // angle\n            z1,\n            z2,\n            z3,\n            z4,\n            cosAlpha,\n            sinAlpha,\n            n,\n            xList,\n            yList,\n            i,\n            x,\n            y,\n            xMin,\n            xMax,\n            yMin,\n            yMax,\n            sortFloat = function (a, b) {\n                return a - b;\n            };\n\n        z1 = z2 = Math.cos(orientation);\n        z3 = z4 = Math.sin(orientation);\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        n = Math.abs(sweepAngle) / angleStep;\n\n        xList = [];\n        yList = [];\n\n        for (i = 0; i <= n; i++) {\n\n            angle = startAngle + (i / n) * sweepAngle;\n            alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n            cosAlpha = Math.cos(alpha);\n            sinAlpha = Math.sin(alpha);\n\n            // current point\n            x = center.x + z1 * cosAlpha - z4 * sinAlpha;\n            y = center.y + z2 * sinAlpha + z3 * cosAlpha;\n\n            xList.push(x);\n            yList.push(y);\n        }\n\n        xList.sort(sortFloat);\n        yList.sort(sortFloat);\n\n        xMin = xList[0];\n        xMax = xList[xList.length - 1];\n        yMin = yList[0];\n        yMax = yList[yList.length - 1];\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains a line.\n     *\n     * @method getLineRect\n     * @param {Point} firstPoint\n     * @param {Point} lastPoint\n     * @returns {Rectangle}\n     */\n    MathUtils.getLineRect = function (firstPoint, lastPoint) {\n\n        var xFirst = firstPoint.x,\n            xLast = lastPoint.x,\n            xMin = Math.min(xFirst, xLast),\n            xMax = Math.max(xFirst, xLast),\n\n            yFirst = firstPoint.y,\n            yLast = lastPoint.y,\n            yMin = Math.min(yFirst, yLast),\n            yMax = Math.max(yFirst, yLast);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    /**\n     * This method is use to calculate the size of the rectangle that contains bounding boxes.\n     *\n     * @method getBoundingRect\n     * @param {Rectangle[]} boundingBoxes List of bounding box\n     * @returns {Rectangle}\n     */\n    MathUtils.getBoundingRect = function (boundingBoxes) {\n\n        var xList = [],\n            yList = [];\n\n        for (var i in boundingBoxes) {\n            var rectangle = boundingBoxes[i];\n            xList.push(rectangle.getX());\n            xList.push(rectangle.getX() + rectangle.getWidth());\n            yList.push(rectangle.getY());\n            yList.push(rectangle.getY() + rectangle.getHeight());\n        }\n\n        var xMin = Math.min.apply(Math, xList);\n        var xMax = Math.max.apply(Math, xList);\n        var yMin = Math.min.apply(Math, yList);\n        var yMax = Math.max.apply(Math, yList);\n\n        return new scope.Rectangle({x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin});\n    };\n\n    // Export\n    scope.MathUtils = MathUtils;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognition message\n     *\n     * @class AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractWSMessage(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get the message type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractWSMessage.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AbstractWSMessage = AbstractWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent an abstract input component\n     *\n     * @class AbstractComponent\n     * @constructor\n     */\n    function AbstractComponent() {\n    }\n\n    /**\n     * Get the type of the input component\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractComponent.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Set the type of the input component\n     *\n     * @method setType\n     * @param {String} type\n     */\n    AbstractComponent.prototype.setType = function (type) {\n        this.type = type;\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractComponent.prototype.getBoundingBox = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractComponent.prototype.setBoundingBox = function (boundingBox) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractComponent = AbstractComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @deprecated Use StrokeComponent instead\n     * @class Stroke\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function Stroke(obj) {\n        scope.AbstractComponent.call(this);\n        this.type = 'stroke';\n        this.x = [];\n        this.y = [];\n        this.t = [];\n        if (obj) {\n            this.x = obj.x;\n            this.y = obj.y;\n            this.t = obj.t;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    Stroke.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    Stroke.prototype.constructor = Stroke;\n\n    /**\n     * Get the list of x coordinates\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Set the list of x coordinates\n     *\n     * @method setX\n     * @param {Number[]} x\n     */\n    Stroke.prototype.setX = function (x) {\n        this.x = x;\n    };\n\n    /**\n     * Add a x to the list of x coordinates\n     *\n     * @method addX\n     * @param {Number} x\n     */\n    Stroke.prototype.addX = function (x) {\n        if ((x !== null) && (x !== undefined)) {\n            this.x.push(x);\n        }\n    };\n\n    /**\n     * Get the list of y coordinates\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    /**\n     * Set the list of y coordinates\n     *\n     * @method setY\n     * @param {Number[]} y\n     */\n    Stroke.prototype.setY = function (y) {\n        this.y = y;\n    };\n\n    /**\n     * Add a y to the list of y coordinates\n     *\n     * @method addY\n     * @param {Number} y\n     */\n    Stroke.prototype.addY = function (y) {\n        if ((y !== null) && (y !== undefined)) {\n            this.y.push(y);\n        }\n    };\n\n    /**\n     * Get the list of timestamps\n     *\n     * @method getT\n     * @returns {Number[]}\n     */\n    Stroke.prototype.getT = function () {\n        return this.t;\n    };\n\n    /**\n     * Set the list of timestamps\n     *\n     * @method setT\n     * @param {Number[]} t\n     */\n    Stroke.prototype.setT = function (t) {\n        this.t = t;\n    };\n\n    /**\n     * Add a timestamp to the list\n     *\n     * @method addT\n     * @param {Number} t\n     */\n    Stroke.prototype.addT = function (t) {\n        if ((t !== null) && (t !== undefined)) {\n            this.t.push(t);\n        }\n    };\n\n    Stroke.prototype.getLength = function () {\n        return this.x.length;\n    };\n\n    /**\n     * Get the boundingBox\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    Stroke.prototype.getBoundingBox = function () {\n        var boundingBox = new scope.Rectangle();\n        boundingBox.setX(Math.min.apply(Math, this.getX()));\n        boundingBox.setY(Math.min.apply(Math, this.getY()));\n        boundingBox.setWidth(Math.max.apply(Math, this.getX()) - boundingBox.getX());\n        boundingBox.setHeight(Math.max.apply(Math, this.getY()) - boundingBox.getY());\n        return boundingBox;\n    };\n\n    // Export\n    scope.Stroke = Stroke;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represent a simple stroke input component\n     *\n     * @class StrokeComponent\n     * @extends Stroke\n     * @constructor\n     */\n    function StrokeComponent(obj) {\n        scope.Stroke.call(this);\n        this.p = [];\n        this.d = [];\n        this.l = [];\n        this.color = undefined;\n        this.alpha = undefined;\n        this.width = 0;\n        if (obj) {\n            this.p = obj.p;\n            this.d = obj.p;\n            this.l = obj.l;\n            this.color = obj.color;\n            this.alpha = obj.alpha;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    StrokeComponent.prototype = new scope.Stroke();\n\n    /**\n     * Constructor property\n     */\n    StrokeComponent.prototype.constructor = StrokeComponent;\n\n    /**     *\n     * @method toJSON\n     * @returns {Object}\n     */\n    StrokeComponent.prototype.toJSON = function () {\n        return {type: this.type, x: this.x, y: this.y, t: this.t};\n    };\n\n    StrokeComponent.prototype.getP = function () {\n        return this.p;\n    };\n\n    StrokeComponent.prototype.setP = function (p) {\n        this.p = p;\n    };\n\n    StrokeComponent.prototype.addP = function (p) {\n        if ((p !== null) && (p !== undefined)) {\n            this.p.push(p);\n        }\n    };\n\n    StrokeComponent.prototype.getD = function () {\n        return this.d;\n    };\n\n    StrokeComponent.prototype.setD = function (d) {\n        this.d = d;\n    };\n\n    StrokeComponent.prototype.addD = function (d) {\n        if ((d !== null) && (d !== undefined)) {\n            this.d.push(d);\n        }\n    };\n\n    StrokeComponent.prototype.getL = function () {\n        return this.l;\n    };\n\n    StrokeComponent.prototype.setL = function (l) {\n        this.l = l;\n    };\n\n    StrokeComponent.prototype.addL = function (l) {\n        if ((l !== null) && (l !== undefined)) {\n            this.l.push(l);\n        }\n    };\n\n    StrokeComponent.prototype.getColor = function () {\n        return this.color;\n    };\n\n    StrokeComponent.prototype.setColor = function (color) {\n        this.color = color;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.getAlpha = function () {\n        return this.alpha;\n    };\n\n    /**\n     * @deprecated Use a rgba() color\n     * @param alpha\n     */\n    StrokeComponent.prototype.setAlpha = function (alpha) {\n        this.alpha = alpha;\n    };\n\n    StrokeComponent.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    StrokeComponent.prototype.setWidth = function (width) {\n        this.width = width;\n    };\n\n    StrokeComponent.prototype.addPoint = function (x, y, t) {\n        if (this.filterPointByAcquisitionDelta(x, y)) {\n            this.addX(x);\n            this.addY(y);\n            this.addT(t);\n            this.addP(this.computeP(x, y));\n            this.addD(this.computeD(x, y));\n            this.addL(this.computeL(x, y));\n        }\n    };\n\n    StrokeComponent.prototype.getLastIndexPoint = function () {\n        return this.x.length - 1;\n    };\n\n    StrokeComponent.prototype.getPointByIndex = function (index) {\n        var point;\n        if (index !== undefined && index >= 0 && index < this.getLength()) {\n            point = {\n                x: this.getX()[index],\n                y: this.getY()[index],\n                t: this.getT()[index],\n                p: this.getP()[index],\n                d: this.getD()[index],\n                l: this.getL()[index]\n            };\n        }\n        return point;\n    };\n\n    StrokeComponent.prototype.computeD = function (x, y) {\n        var distance = Math.sqrt(Math.pow((y - this.getY()[this.getLastIndexPoint() - 1]), 2) + Math.pow((x - this.getX()[this.getLastIndexPoint() - 1]), 2));\n\n        if (isNaN(distance)) {\n            distance = 0;\n        }\n\n        return distance;\n    };\n\n    StrokeComponent.prototype.computeL = function (x, y) {\n        var length = this.getL()[this.getLastIndexPoint() - 1] + this.computeD(x, y);\n\n        if (isNaN(length)) {\n            length = 0;\n        }\n\n        return length;\n    };\n\n    StrokeComponent.prototype.computeP = function (x, y) {\n        var ratio = 1.0;\n        var distance = this.computeD(x, y);\n        var length = this.computeL(x, y);\n\n        if(length === 0) {\n            ratio = 0.5;\n        } else if(distance == length){\n            ratio = 1.0;\n        } else  if (distance < 10) {\n            ratio = 0.2 + Math.pow(0.1 * distance, 0.4);\n        } else if (distance > length - 10) {\n            ratio = 0.2 + Math.pow(0.1 * (length - distance), 0.4);\n        }\n        var pressure = ratio * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(distance));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        return pressure;\n    };\n\n    StrokeComponent.prototype.filterPointByAcquisitionDelta = function (x, y) {\n        var delta = (2 + (this.getWidth() / 4));\n        var ret = false;\n        if (this.getLength() === 0 || Math.abs(this.getX()[this.getLastIndexPoint()] - x) >= delta || Math.abs(this.getY()[this.getLastIndexPoint()] - y) >= delta) {\n            ret = true;\n        }\n        return ret;\n    };\n\n    // Export\n    scope.StrokeComponent = StrokeComponent;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharacterInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function CharacterInputComponent() {\n        scope.AbstractComponent.call(this);\n        this.type = 'inputCharacter';\n        this.alternates = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharacterInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    CharacterInputComponent.prototype.constructor = CharacterInputComponent;\n\n    /**\n     * Get character input alternates\n     *\n     * @method getAlternates\n     * @returns {CharacterInputComponentAlternate[]}\n     */\n    CharacterInputComponent.prototype.getAlternates = function () {\n        return this.alternates;\n    };\n\n    /**\n     * Set character input alternates\n     *\n     * @method setAlternates\n     * @param {CharacterInputComponentAlternate[]} alternates\n     */\n    CharacterInputComponent.prototype.setAlternates = function (alternates) {\n        this.alternates = alternates;\n    };\n\n    /**\n     * Add a character input alternate\n     *\n     * @method addAlternate\n     * @param {CharacterInputComponent} alternate\n     */\n    CharacterInputComponent.prototype.addAlternate = function (alternate) {\n        this.alternates.push(alternate);\n    };\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    CharacterInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    CharacterInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.CharacterInputComponent = CharacterInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Character input component alternate\n     *\n     * @class CharacterInputComponentAlternate\n     * @constructor\n     */\n    function CharacterInputComponentAlternate(alternate, probability) {\n        this.alternate = alternate;\n        this.probability = probability;\n    }\n\n    /**\n     * Get alternate\n     *\n     * @method getAlternate\n     * @returns {String}\n     */\n    CharacterInputComponentAlternate.prototype.getAlternate = function () {\n        return this.alternate;\n    };\n\n    /**\n     * Set alternate\n     *\n     * @method setAlternate\n     * @param {String} alternate\n     */\n    CharacterInputComponentAlternate.prototype.setAlternate = function (alternate) {\n        this.alternate = alternate;\n    };\n\n    /**\n     * Get probability\n     *\n     * @method getProbability\n     * @returns {Number}\n     */\n    CharacterInputComponentAlternate.prototype.getProbability = function () {\n        return this.probability;\n    };\n\n    /**\n     * Set probability\n     *\n     * @method setProbability\n     * @param {Number} probability\n     */\n    CharacterInputComponentAlternate.prototype.setProbability = function (probability) {\n        this.probability = probability;\n    };\n\n    // Export\n    scope.CharacterInputComponentAlternate = CharacterInputComponentAlternate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract parameters used for recognition\n     *\n     * @class AbstractParameter\n     * @constructor\n     */\n    function AbstractParameter() {\n    }\n\n    // Export\n    scope.AbstractParameter = AbstractParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstraction of recognizer input\n     *\n     * @class AbstractRecognitionInput\n     * @constructor\n     */\n    function AbstractRecognitionInput() {\n    }\n\n    // Export\n    scope.AbstractRecognitionInput = AbstractRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract input recognition data\n     *\n     * @class AbstractRecognitionData\n     * @constructor\n     */\n    function AbstractRecognitionData() {\n    }\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    AbstractRecognitionData.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecognitionData.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set the instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractRecognitionData.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    /**\n     * @returns {string}\n     */\n    AbstractRecognitionData.prototype.getHmac = function () {\n        return this.hmac;\n    };\n\n    /**\n     * @param {string} hmac\n     */\n    AbstractRecognitionData.prototype.setHmac = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    /**\n     * Get recognition input\n     *\n     * @method getRecognitionInput\n     * @returns {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.getRecognitionInput = function () {\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {AbstractRecognitionInput} input\n     */\n    AbstractRecognitionData.prototype.setRecognitionInput = function (input) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.AbstractRecognitionData = AbstractRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * List of languages recognition input\n     *\n     * @class RecognitionLanguagesData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function RecognitionLanguagesData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    RecognitionLanguagesData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    RecognitionLanguagesData.prototype.constructor = RecognitionLanguagesData;\n\n    /**\n     * Get the recognition input mode\n     *\n     * @method getInputMode\n     * @returns {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.getInputMode = function () {\n        return this.inputMode;\n    };\n\n    /**\n     * Set the recognition input mode\n     *\n     * @method setInputMode\n     * @param {String} inputMode\n     */\n    RecognitionLanguagesData.prototype.setInputMode = function (inputMode) {\n        this.inputMode = inputMode;\n    };\n\n    // Export\n    scope.RecognitionLanguagesData = RecognitionLanguagesData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class AbstractStartRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractStartRequestWSMessage(obj) {\n        this.type = 'start';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractStartRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractStartRequestWSMessage.prototype.constructor = AbstractStartRequestWSMessage;\n\n    // Export\n    scope.AbstractStartRequestWSMessage = AbstractStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class AbstractContinueRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractContinueRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractContinueRequestWSMessage.prototype.constructor = AbstractContinueRequestWSMessage;\n\n    /**\n     * Get instanceId\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractContinueRequestWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Set instanceId\n     *\n     * @method setInstanceId\n     * @param {String} instanceId\n     */\n    AbstractContinueRequestWSMessage.prototype.setInstanceId = function (instanceId) {\n        this.instanceId = instanceId;\n    };\n\n    // Export\n    scope.AbstractContinueRequestWSMessage = AbstractContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeRequestWSMessage(obj) {\n        this.type = 'hmac';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeRequestWSMessage.prototype.constructor = ChallengeRequestWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    /**\n     * Set the challenge\n     *\n     * @method setChallenge\n     * @param {String} challenge\n     */\n    ChallengeRequestWSMessage.prototype.setChallenge = function (challenge) {\n        this.challenge = challenge;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    ChallengeRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get HMAC signature\n     *\n     * @method getHmacSignature\n     * @returns {String}\n     */\n    ChallengeRequestWSMessage.prototype.getHmacSignature = function () {\n        return this.hmac;\n    };\n\n    /**\n     * Set HMAC signature\n     *\n     * @method setHmacSignature\n     * @param {String} hmac\n     */\n    ChallengeRequestWSMessage.prototype.setHmacSignature = function (hmac) {\n        this.hmac = hmac;\n    };\n\n    // Export\n    scope.ChallengeRequestWSMessage = ChallengeRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class InitRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitRequestWSMessage(obj) {\n        this.type = 'applicationKey';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitRequestWSMessage.prototype.constructor = InitRequestWSMessage;\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InitRequestWSMessage.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InitRequestWSMessage.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    // Export\n    scope.InitRequestWSMessage = InitRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ResetRequestWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetRequestWSMessage(obj) {\n        this.type = 'reset';\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetRequestWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetRequestWSMessage.prototype.constructor = ResetRequestWSMessage;\n\n    // Export\n    scope.ResetRequestWSMessage = ResetRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract text input component\n     *\n     * @class AbstractTextInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractTextInputComponent() {\n        scope.AbstractComponent.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractTextInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractTextInputComponent.prototype.constructor = AbstractTextInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractTextInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractTextInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractTextInputComponent = AbstractTextInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Char input component\n     *\n     * @class CharInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function CharInputComponent() {\n        this.type = 'char';\n    }\n\n    /**\n     * Inheritance property\n     */\n    CharInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    CharInputComponent.prototype.constructor = CharInputComponent;\n\n    /**\n     * Get character\n     *\n     * @deprecated Use 'getLabel'\n     * @method getCharacter\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getCharacter = function () {\n        return this.character;\n    };\n\n    /**\n     * Set character\n     *\n     * @deprecated Use 'setLabel'\n     * @method setCharacter\n     * @param {String} character\n     */\n    CharInputComponent.prototype.setCharacter = function (character) {\n        this.character = character;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    CharInputComponent.prototype.getLabel = function () {\n        return this.character;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    CharInputComponent.prototype.setLabel = function (label) {\n        this.character = label;\n    };\n\n    // Export\n    scope.CharInputComponent = CharInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * String input component\n     *\n     * @class StringInputComponent\n     * @extends AbstractTextInputComponent\n     * @constructor\n     */\n    function StringInputComponent() {\n        this.type = 'string';\n    }\n\n    /**\n     * Inheritance property\n     */\n    StringInputComponent.prototype = new scope.AbstractTextInputComponent();\n\n    /**\n     * Constructor property\n     */\n    StringInputComponent.prototype.constructor = StringInputComponent;\n\n    /**\n     * Get string\n     *\n     * @deprecated Use 'getLabel'\n     * @method getString\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getString = function () {\n        return this.string;\n    };\n\n    /**\n     * Set string\n     *\n     * @deprecated Use 'setLabel'\n     * @method setString\n     * @param {String} string\n     */\n    StringInputComponent.prototype.setString = function (string) {\n        this.string = string;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    StringInputComponent.prototype.getLabel = function () {\n        return this.string;\n    };\n\n    /**\n     * Set label\n     *\n     * @method setLabel\n     * @param {String} label\n     */\n    StringInputComponent.prototype.setLabel = function (label) {\n        this.string = label;\n    };\n\n    // Export\n    scope.StringInputComponent = StringInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Input unit used for text recognition\n     *\n     * @class TextInputUnit\n     * @constructor\n     */\n    function TextInputUnit() {\n        this.textInputType = 'MULTI_LINE_TEXT';\n        this.components = [];\n    }\n\n    /**\n     * Get the input type\n     *\n     * @method getInputType\n     * @returns {String}\n     */\n    TextInputUnit.prototype.getInputType = function () {\n        return this.textInputType;\n    };\n\n    /**\n     * Set the input type\n     *\n     * @method setInputType\n     * @returns {String} inputType\n     */\n    TextInputUnit.prototype.setInputType = function (inputType) {\n        this.textInputType = inputType;\n    };\n\n    /**\n     * Get components for this input unit\n     *\n     * @method getComponents\n     * @param {TextInkRange} [inkRange]\n     * @returns {AbstractComponent[]}\n     */\n    TextInputUnit.prototype.getComponents = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.components.slice(inkRange.getStartComponent(), inkRange.getEndComponent() + 1);\n        }\n        return this.components;\n    };\n\n    /**\n     * Set components for this input unit\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    TextInputUnit.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.TextInputUnit = TextInputUnit;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for text recognition\n     *\n     * @class TextParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function TextParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textProperties = new scope.TextProperties();\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    TextParameter.prototype.constructor = TextParameter;\n\n    /**\n     * Get recognition language\n     *\n     * @method getLanguage\n     * @returns {String}\n     */\n    TextParameter.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @method getLanguage\n     * @param {String} language\n     */\n    TextParameter.prototype.setLanguage = function (language) {\n        this.language = language;\n    };\n\n    /**\n     * Get input mode\n     *\n     * @method getInputMode\n     * @returns {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'}\n     */\n    TextParameter.prototype.getInputMode = function () {\n        return this.textInputMode;\n    };\n\n    /**\n     * Set input mode\n     *\n     * @method setInputMode\n     * @param {'CURSIVE'|'ISOLATED'|'SUPERIMPOSED'|'VERTICAL'} inputMode\n     */\n    TextParameter.prototype.setInputMode = function (inputMode) {\n        this.textInputMode = inputMode;\n    };\n\n    /**\n     * Get content types\n     *\n     * @method getContentTypes\n     * @returns {Array}\n     */\n    TextParameter.prototype.getContentTypes = function () {\n        return this.contentTypes;\n    };\n\n    /**\n     * Set content types\n     *\n     * @method setContentTypes\n     * @param {Array} contentTypes\n     */\n    TextParameter.prototype.setContentTypes = function (contentTypes) {\n        this.contentTypes = contentTypes;\n    };\n\n    /**\n     * Get SK\n     *\n     * @method getSubsetKnowledges\n     * @returns {Array}\n     */\n    TextParameter.prototype.getSubsetKnowledges = function () {\n        return this.subsetKnowledges;\n    };\n\n    /**\n     * Set SK\n     *\n     * @method setSubsetKnowledges\n     * @param {Array} subsetKnowledges\n     */\n    TextParameter.prototype.setSubsetKnowledges = function (subsetKnowledges) {\n        this.subsetKnowledges = subsetKnowledges;\n    };\n\n    /**\n     * Get user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    TextParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get user LK words\n     *\n     * @method getUserLkWords\n     * @returns {Array}\n     */\n    TextParameter.prototype.getUserLkWords = function () {\n        return this.userLkWords;\n    };\n\n    /**\n     * Set user LK words\n     *\n     * @method setUserLkWords\n     * @param {Array} userLkWords\n     */\n    TextParameter.prototype.setUserLkWords = function (userLkWords) {\n        this.userLkWords = userLkWords;\n    };\n\n    /**\n     * Get result detail (e.g. TEXT, WORD ...)\n     *\n     * @method getResultDetail\n     * @returns {'TEXT'|'WORD'|'CHARACTER'}\n     */\n    TextParameter.prototype.getResultDetail = function () {\n        return this.resultDetail;\n    };\n\n    /**\n     * Set result detail (e.g. TEXT, WORD ...)\n     *\n     * @method setResultDetail\n     * @param {'TEXT'|'WORD'|'CHARACTER'} resultDetail\n     */\n    TextParameter.prototype.setResultDetail = function (resultDetail) {\n        this.resultDetail = resultDetail;\n    };\n\n    /**\n     * Get text properties\n     *\n     * @method getTextProperties\n     * @returns {TextProperties}\n     */\n    TextParameter.prototype.getTextProperties = function () {\n        return this.textProperties;\n    };\n\n    /**\n     * Set text properties\n     *\n     * @method setTextProperties\n     * @param {TextProperties} properties\n     */\n    TextParameter.prototype.setTextProperties = function (textProperties) {\n        this.textProperties = textProperties;\n    };\n\n    // Export\n    scope.TextParameter = TextParameter;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognition properties\n     *\n     * @class TextProperties\n     * @constructor\n     */\n    function TextProperties() {\n    }\n\n    /**\n     * Get the number of text candidates requested\n     *\n     * @method getTextCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getTextCandidateListSize = function () {\n        return this.textCandidateListSize;\n    };\n\n    /**\n     * Set the number of text candidates requested\n     *\n     * @method setTextCandidateListSize\n     * @param {Number} textCandidateListSize\n     */\n    TextProperties.prototype.setTextCandidateListSize = function (textCandidateListSize) {\n        this.textCandidateListSize = textCandidateListSize;\n    };\n\n    /**\n     * Get the number of word candidates requested\n     *\n     * @method getWordCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCandidateListSize = function () {\n        return this.wordCandidateListSize;\n    };\n\n    /**\n     * Set the number of word candidates requested\n     *\n     * @method setWordCandidateListSize\n     * @param {Number} wordCandidateListSize\n     */\n    TextProperties.prototype.setWordCandidateListSize = function (wordCandidateListSize) {\n        this.wordCandidateListSize = wordCandidateListSize;\n    };\n\n    /**\n     * Get the number of word prediction candidates requested\n     *\n     * @method getWordPredictionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordPredictionListSize = function () {\n        return this.wordPredictionListSize;\n    };\n\n    /**\n     * Set the number of word prediction candidates requested\n     *\n     * @method setWordPredictionListSize\n     * @param {Number} wordPredictionListSize\n     */\n    TextProperties.prototype.setWordPredictionListSize = function (wordPredictionListSize) {\n        this.wordPredictionListSize = wordPredictionListSize;\n    };\n\n    /**\n     * Get the number of word completion candidates requested\n     *\n     * @method getWordCompletionListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getWordCompletionListSize = function () {\n        return this.wordCompletionListSize;\n    };\n\n    /**\n     * Set the number of word completion candidates requested\n     *\n     * @method setWordCompletionListSize\n     * @param {Number} wordCompletionListSize\n     */\n    TextProperties.prototype.setWordCompletionListSize = function (wordCompletionListSize) {\n        this.wordCompletionListSize = wordCompletionListSize;\n    };\n\n    /**\n     * Get the number of character candidates requested\n     *\n     * @method getCharacterCandidateListSize\n     * @returns {Number}\n     */\n    TextProperties.prototype.getCharacterCandidateListSize = function () {\n        return this.characterCandidateListSize;\n    };\n\n    /**\n     * Set the number of character candidates requested\n     *\n     * @method setCharacterCandidateListSize\n     * @param {Number} characterCandidateListSize\n     */\n    TextProperties.prototype.setCharacterCandidateListSize = function (characterCandidateListSize) {\n        this.characterCandidateListSize = characterCandidateListSize;\n    };\n\n    /**\n     * Get the discard case variations\n     *\n     * @method getDiscardCaseVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardCaseVariations = function () {\n        return this.discardCaseVariations;\n    };\n\n    /**\n     * Set the discard case variations\n     *\n     * @method setDiscardCaseVariations\n     * @param {boolean} discardCaseVariations\n     */\n    TextProperties.prototype.setDiscardCaseVariations = function (discardCaseVariations) {\n        this.discardCaseVariations = discardCaseVariations;\n    };\n\n    /**\n     * Get the discard accentuation variations\n     *\n     * @method getDiscardAccentuationVariations\n     * @returns {boolean}\n     */\n    TextProperties.prototype.getDiscardAccentuationVariations = function () {\n        return this.discardAccentuationVariations;\n    };\n\n    /**\n     * Set the discard accentuation variations\n     *\n     * @method setDiscardAccentuationVariations\n     * @param {boolean} discardAccentuationVariations\n     */\n    TextProperties.prototype.setDiscardAccentuationVariations = function (discardAccentuationVariations) {\n        this.discardAccentuationVariations = discardAccentuationVariations;\n    };\n\n    /**\n     * Get disable spatial ordering\n     *\n     * @method getDisableSpatialOrdering\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getDisableSpatialOrdering = function () {\n        return this.disableSpatialOrdering;\n    };\n\n    /**\n     * Set disable spatial ordering\n     *\n     * @method setDisableSpatialOrdering\n     * @param {Boolean} disableSpatialOrdering\n     */\n    TextProperties.prototype.setDisableSpatialOrdering = function (disableSpatialOrdering) {\n        this.disableSpatialOrdering = disableSpatialOrdering;\n    };\n\n    /**\n     * Get glyph distortion\n     *\n     * @method getGlyphDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getGlyphDistortion = function () {\n        return this.glyphDistortion;\n    };\n\n    /**\n     * Set glyph distortion\n     *\n     * @method setGlyphDistortion\n     * @param {Number} glyphDistortion\n     */\n    TextProperties.prototype.setGlyphDistortion = function (glyphDistortion) {\n        this.glyphDistortion = glyphDistortion;\n    };\n\n    /**\n     * Get enable out of lexicon\n     *\n     * @method getEnableOutOfLexicon\n     * @returns {Boolean}\n     */\n    TextProperties.prototype.getEnableOutOfLexicon = function () {\n        return this.enableOutOfLexicon;\n    };\n\n    /**\n     * Set enable out of lexicon\n     *\n     * @method setEnableOutOfLexicon\n     * @param {Boolean} enableOutOfLexicon\n     */\n    TextProperties.prototype.setEnableOutOfLexicon = function (enableOutOfLexicon) {\n        this.enableOutOfLexicon = enableOutOfLexicon;\n    };\n\n    /**\n     * Get spelling distortion\n     *\n     * @method getSpellingDistortion\n     * @returns {Number}\n     */\n    TextProperties.prototype.getSpellingDistortion = function () {\n        return this.spellingDistortion;\n    };\n\n    /**\n     * Set spelling distortion\n     *\n     * @method setSpellingDistortion\n     * @param {Number} spellingDistortion\n     */\n    TextProperties.prototype.setSpellingDistortion = function (spellingDistortion) {\n        this.spellingDistortion = spellingDistortion;\n    };\n\n    // Export\n    scope.TextProperties = TextProperties;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for text recognition\n     *\n     * @class TextRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function TextRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionInput.prototype.constructor = TextRecognitionInput;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextRecognitionInput.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextRecognitionInput.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @param {TextInkRange} [inkRange]\n     * @returns {TextInputUnit[]}\n     */\n    TextRecognitionInput.prototype.getInputUnits = function (inkRange) {\n        if (inkRange && (inkRange instanceof scope.TextInkRange)) {\n            return this.inputUnits.slice(inkRange.getStartUnit(), inkRange.getEndUnit() + 1);\n        }\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextRecognitionInput.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextRecognitionInput = TextRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for text input\n     *\n     * @class TextRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function TextRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    TextRecognitionData.prototype.constructor = TextRecognitionData;\n\n    /**\n     * Get text input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getTextRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getTextRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setTextRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setTextRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get text input\n     *\n     * @method getRecognitionInput\n     * @returns {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.getRecognitionInput = function () {\n        return this.textInput;\n    };\n\n    /**\n     * Set text input\n     *\n     * @method setRecognitionInput\n     * @param {TextRecognitionInput} input\n     */\n    TextRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.textInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.TextRecognitionData = TextRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start text recognition message\n     *\n     * @class TextStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextStartRequestWSMessage.prototype.constructor = TextStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextStartRequestWSMessage.prototype.getParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextStartRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextStartRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextStartRequestWSMessage = TextStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue text recognition message\n     *\n     * @class TextContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextContinueRequestWSMessage(obj) {\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextContinueRequestWSMessage.prototype.constructor = TextContinueRequestWSMessage;\n\n    /**\n     * Get input units\n     *\n     * @method getInputUnits\n     * @returns {TextInputUnit[]}\n     */\n    TextContinueRequestWSMessage.prototype.getInputUnits = function () {\n        return this.inputUnits;\n    };\n\n    /**\n     * Set input units\n     *\n     * @method setInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     */\n    TextContinueRequestWSMessage.prototype.setInputUnits = function (inputUnits) {\n        this.inputUnits = inputUnits;\n    };\n\n    // Export\n    scope.TextContinueRequestWSMessage = TextContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for shape recognition\n     *\n     * @class ShapeParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function ShapeParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    ShapeParameter.prototype.constructor = ShapeParameter;\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Boolean} rejectDetectionSensitivity\n     */\n    ShapeParameter.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method hasBeautification\n     * @returns {Boolean}\n     */\n    ShapeParameter.prototype.hasBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeParameter.prototype.setBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    ShapeParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    ShapeParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    // Export\n    scope.ShapeParameter = ShapeParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for shape recognition\n     *\n     * @class ShapeRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function ShapeRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionInput.prototype.constructor = ShapeRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    ShapeRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    ShapeRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the beautification\n     *\n     * @method getDoBeautification\n     * @returns {Boolean}\n     */\n    ShapeRecognitionInput.prototype.getDoBeautification = function () {\n        return this.doBeautification;\n    };\n\n    /**\n     * Set the beautification\n     *\n     * @method setDoBeautification\n     * @param {Boolean} doBeautification\n     */\n    ShapeRecognitionInput.prototype.setDoBeautification = function (doBeautification) {\n        this.doBeautification = doBeautification;\n    };\n\n    /**\n     * Get the sensitivity of the reject detection\n     *\n     * @method getRejectDetectionSensitivity\n     * @returns {Number}\n     */\n    ShapeRecognitionInput.prototype.getRejectDetectionSensitivity = function () {\n        return this.rejectDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the reject detection\n     *\n     * @method setRejectDetectionSensitivity\n     * @param {Number} rejectDetectionSensitivity\n     */\n    ShapeRecognitionInput.prototype.setRejectDetectionSensitivity = function (rejectDetectionSensitivity) {\n        this.rejectDetectionSensitivity = rejectDetectionSensitivity;\n    };\n\n    // Export\n    scope.ShapeRecognitionInput = ShapeRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for shape input\n     *\n     * @class ShapeRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function ShapeRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognitionData.prototype.constructor = ShapeRecognitionData;\n\n    /**\n     * Get shape input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getShapeRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getShapeRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setShapeRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setShapeRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get shape input\n     *\n     * @method getRecognitionInput\n     * @returns {ShapeRecognitionInput}\n     */\n    ShapeRecognitionData.prototype.getRecognitionInput = function () {\n        return this.shapeInput;\n    };\n\n    /**\n     * Set shape input\n     *\n     * @method setRecognitionInput\n     * @param {ShapeRecognitionInput} input\n     */\n    ShapeRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.shapeInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.ShapeRecognitionData = ShapeRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for math recognition\n     *\n     * @class MathParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MathParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MathParameter.prototype.constructor = MathParameter;\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathParameter.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathParameter.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    // Export\n    scope.MathParameter = MathParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for math recognition\n     *\n     * @class MathRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MathRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionInput.prototype.constructor = MathRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MathRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MathRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the math result types (e.g. LaTex, MathML, SymbolTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MathRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the math result result orientation to columnar operations\n     *\n     * @method isColumnar\n     * @returns {Boolean}\n     */\n    MathRecognitionInput.prototype.isColumnar = function () {\n        return this.columnarOperation;\n    };\n\n    /**\n     * Set the math result orientation to columnar operations\n     *\n     * @method setColumnar\n     * @param  {Boolean} columnar\n     */\n    MathRecognitionInput.prototype.setColumnar = function (columnar) {\n        this.columnarOperation = columnar;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MathRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MathRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MathRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MathRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n    // Export\n    scope.MathRecognitionInput = MathRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for math input\n     *\n     * @class MathRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MathRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MathRecognitionData.prototype.constructor = MathRecognitionData;\n\n    /**\n     * Get math input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMathRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getMathRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMathRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setMathRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get math input\n     *\n     * @method getRecognitionInput\n     * @returns {MathRecognitionInput}\n     */\n    MathRecognitionData.prototype.getRecognitionInput = function () {\n        return this.mathInput;\n    };\n\n    /**\n     * Set math input\n     *\n     * @method setRecognitionInput\n     * @param {MathRecognitionInput} input\n     */\n    MathRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.mathInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MathRecognitionData = MathRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket start math recognition message\n     *\n     * @class MathStartRequestWSMessage\n     * @extends AbstractStartRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathStartRequestWSMessage(obj) {\n        scope.AbstractStartRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathStartRequestWSMessage.prototype = new scope.AbstractStartRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathStartRequestWSMessage.prototype.constructor = MathStartRequestWSMessage;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathStartRequestWSMessage.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathStartRequestWSMessage.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathStartRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathStartRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathStartRequestWSMessage = MathStartRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket continue math recognition message\n     *\n     * @class MathContinueRequestWSMessage\n     * @extends AbstractContinueRequestWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathContinueRequestWSMessage(obj) {\n        this.type = 'continue';\n        scope.AbstractContinueRequestWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathContinueRequestWSMessage.prototype = new scope.AbstractContinueRequestWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathContinueRequestWSMessage.prototype.constructor = MathContinueRequestWSMessage;\n\n    /**\n     * Get components\n     *\n     * @method getComponents\n     * @returns {MathInputUnit[]}\n     */\n    MathContinueRequestWSMessage.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set components\n     *\n     * @method setComponents\n     * @param {MathInputUnit[]} components\n     */\n    MathContinueRequestWSMessage.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.MathContinueRequestWSMessage = MathContinueRequestWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music input component\n     *\n     * @class AbstractMusicInputComponent\n     * @extends AbstractComponent\n     * @constructor\n     */\n    function AbstractMusicInputComponent() {\n        scope.AbstractComponent.call(this);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractMusicInputComponent.prototype = new scope.AbstractComponent();\n\n    /**\n     * Constructor property\n     */\n    AbstractMusicInputComponent.prototype.constructor = AbstractMusicInputComponent;\n\n    /**\n     * Get input component bounding-box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AbstractMusicInputComponent.prototype.getBoundingBox = function () {\n        return this.boundingBox;\n    };\n\n    /**\n     * Set input component bounding-box\n     *\n     * @method setBoundingBox\n     * @param {Rectangle} boundingBox\n     */\n    AbstractMusicInputComponent.prototype.setBoundingBox = function (boundingBox) {\n        this.boundingBox = boundingBox;\n    };\n\n    // Export\n    scope.AbstractMusicInputComponent = AbstractMusicInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Accidental input component\n     *\n     * @class MusicAccidentalInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicAccidentalInputComponent() {\n        this.type = 'accidental';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidentalInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidentalInputComponent.prototype.constructor = MusicAccidentalInputComponent;\n\n    /**\n     * Get accidental input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicAccidentalInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set accidental input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicAccidentalInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicAccidentalInputComponent = MusicAccidentalInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Arpeggiate input component\n     *\n     * @class MusicArpeggiateInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicArpeggiateInputComponent() {\n        this.type = 'arpeggiate';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiateInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiateInputComponent.prototype.constructor = MusicArpeggiateInputComponent;\n\n    /**\n     * Get arpeggiate input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicArpeggiateInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set arpeggiate input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicArpeggiateInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicArpeggiateInputComponent = MusicArpeggiateInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Bar input component\n     *\n     * @class MusicBarInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBarInputComponent() {\n        this.type = 'bar';\n        this.value = new scope.MusicBar();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBarInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBarInputComponent.prototype.constructor = MusicBarInputComponent;\n\n    /**\n     * Get bar component value\n     *\n     * @method getValue\n     * @returns {MusicBar}\n     */\n    MusicBarInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set bar component value\n     *\n     * @method setValue\n     * @param {MusicBar} value\n     */\n    MusicBarInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBarInputComponent = MusicBarInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Beam input component\n     *\n     * @class MusicBeamInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicBeamInputComponent() {\n        this.type = 'beam';\n        this.value = new scope.MusicBeam();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeamInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicBeamInputComponent.prototype.constructor = MusicBeamInputComponent;\n\n    /**\n     * Get beam input component value\n     *\n     * @method getValue\n     * @returns {MusicBeam}\n     */\n    MusicBeamInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set beam input component value\n     *\n     * @method setValue\n     * @param {MusicBeam} value\n     */\n    MusicBeamInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicBeamInputComponent = MusicBeamInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Clef input component\n     * default clef values: symbol='G', octave=0\n     *\n     * @class MusicClefInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicClefInputComponent() {\n        this.type = 'clef';\n        this.value = new scope.MusicClef();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClefInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicClefInputComponent.prototype.constructor = MusicClefInputComponent;\n\n    /**\n     * Get clef input component value\n     *\n     * @method getValue\n     * @returns {MusicClef}\n     */\n    MusicClefInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set clef input component value\n     *\n     * @method setValue\n     * @param {MusicClef} value\n     */\n    MusicClefInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicClefInputComponent = MusicClefInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Decoration input component\n     *\n     * @class MusicDecorationInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDecorationInputComponent() {\n        this.type = 'decoration';\n        this.value = new scope.MusicDecoration();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecorationInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDecorationInputComponent.prototype.constructor = MusicDecorationInputComponent;\n\n    /**\n     * Get decoration input component value\n     *\n     * @method getValue\n     * @returns {MusicDecoration}\n     */\n    MusicDecorationInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set decoration input component value\n     *\n     * @method setValue\n     * @param {MusicDecoration} value\n     */\n    MusicDecorationInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDecorationInputComponent = MusicDecorationInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Dots input component\n     *\n     * @class MusicDotsInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicDotsInputComponent() {\n        this.type = 'dots';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDotsInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicDotsInputComponent.prototype.constructor = MusicDotsInputComponent;\n\n    /**\n     * Get dots input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicDotsInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set dots input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicDotsInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicDotsInputComponent = MusicDotsInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Head input component\n     *\n     * @class MusicHeadInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicHeadInputComponent() {\n        this.type = 'head';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHeadInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicHeadInputComponent.prototype.constructor = MusicHeadInputComponent;\n\n    /**\n     * Get head input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicHeadInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set head input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicHeadInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicHeadInputComponent = MusicHeadInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Ledger line input component\n     *\n     * @class MusicLedgerLineInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicLedgerLineInputComponent() {\n        this.type = 'ledgerLine';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLineInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLineInputComponent.prototype.constructor = MusicLedgerLineInputComponent;\n\n    // Export\n    scope.MusicLedgerLineInputComponent = MusicLedgerLineInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Rest input component\n     *\n     * @class MusicRestInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicRestInputComponent() {\n        this.type = 'rest';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRestInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicRestInputComponent.prototype.constructor = MusicRestInputComponent;\n\n    /**\n     * Get rest input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicRestInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set rest input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicRestInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicRestInputComponent = MusicRestInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Stem input component\n     *\n     * @class MusicStemInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicStemInputComponent() {\n        this.type = 'stem';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStemInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicStemInputComponent.prototype.constructor = MusicStemInputComponent;\n\n    /**\n     * Get stem input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicStemInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set stem input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicStemInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicStemInputComponent = MusicStemInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Tie ro slur input component\n     *\n     * @class MusicTieOrSlurInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTieOrSlurInputComponent() {\n        this.type = 'tieOrSlur';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTieOrSlurInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTieOrSlurInputComponent.prototype.constructor = MusicTieOrSlurInputComponent;\n\n    /**\n     * Get tie or slur input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTieOrSlurInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set tie or slur input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTieOrSlurInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTieOrSlurInputComponent = MusicTieOrSlurInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Time signature input component\n     *\n     * @class MusicTimeSignatureInputComponent\n     * @extends AbstractMusicInputComponent\n     * @constructor\n     */\n    function MusicTimeSignatureInputComponent() {\n        this.type = 'timeSignature';\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignatureInputComponent.prototype = new scope.AbstractMusicInputComponent();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignatureInputComponent.prototype.constructor = MusicTimeSignatureInputComponent;\n\n    /**\n     * Get time signature input component value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicTimeSignatureInputComponent.prototype.getValue = function () {\n        return this.value;\n    };\n\n    /**\n     * Set time signature input component value\n     *\n     * @method setValue\n     * @param {String} value\n     */\n    MusicTimeSignatureInputComponent.prototype.setValue = function (value) {\n        this.value = value;\n    };\n\n    // Export\n    scope.MusicTimeSignatureInputComponent = MusicTimeSignatureInputComponent;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Represents a staff used for music recognition\n     * default values: count=5, gap=20\n     *\n     * @class MusicStaff\n     * @constructor\n     */\n    function MusicStaff() {\n        this.count = 5;\n        this.gap = 20;\n    }\n\n    /**\n     * Get the lines count\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getCount = function () {\n        return this.count;\n    };\n\n    /**\n     * Set the lines count\n     *\n     * @method setCount\n     * @param {Number} count\n     */\n    MusicStaff.prototype.setCount = function (count) {\n        this.count = count;\n    };\n\n    /**\n     * Get the spacing from the top\n     *\n     * @method getTop\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Set the spacing from the top\n     *\n     * @method setTop\n     * @param {Number} top\n     */\n    MusicStaff.prototype.setTop = function (top) {\n        this.top = top;\n    };\n\n    /**\n     * Get the gap between lines\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicStaff.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set the gap between lines\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicStaff.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    // Export\n    scope.MusicStaff = MusicStaff;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for music recognition\n     *\n     * @class MusicParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function MusicParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.resultTypes = [];\n        this.userResources = [];\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    MusicParameter.prototype.constructor = MusicParameter;\n\n    /**\n     * Get the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the music result types (e.g. MusicXML, ScoreTree)\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicParameter.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicParameter.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicParameter.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicParameter.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicParameter.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicParameter.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicParameter.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicParameter.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicParameter = MusicParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for music recognition\n     *\n     * @class MusicRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function MusicRecognitionInput() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionInput.prototype.constructor = MusicRecognitionInput;\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    MusicRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    MusicRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    /**\n     * Get the result types\n     *\n     * @method getResultTypes\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getResultTypes = function () {\n        return this.resultTypes;\n    };\n\n    /**\n     * Set the result types\n     *\n     * @method setResultTypes\n     * @param {Array} resultTypes\n     */\n    MusicRecognitionInput.prototype.setResultTypes = function (resultTypes) {\n        this.resultTypes = resultTypes;\n    };\n\n    /**\n     * Get the user resources\n     *\n     * @method getUserResources\n     * @returns {Array}\n     */\n    MusicRecognitionInput.prototype.getUserResources = function () {\n        return this.userResources;\n    };\n\n    /**\n     * Set the user resources\n     *\n     * @method setUserResources\n     * @param {Array} userResources\n     */\n    MusicRecognitionInput.prototype.setUserResources = function (userResources) {\n        this.userResources = userResources;\n    };\n\n    /**\n     * Get the sensitivity of the scratch-out detection\n     *\n     * @method getScratchOutDetectionSensitivity\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getScratchOutDetectionSensitivity = function () {\n        return this.scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Set the sensitivity of the scratch-out detection\n     *\n     * @method setScratchOutDetectionSensitivity\n     * @param {Number} scratchOutDetectionSensitivity\n     */\n    MusicRecognitionInput.prototype.setScratchOutDetectionSensitivity = function (scratchOutDetectionSensitivity) {\n        this.scratchOutDetectionSensitivity = scratchOutDetectionSensitivity;\n    };\n\n    /**\n     * Get the staff\n     *\n     * @method getStaff\n     * @returns {MusicStaff}\n     */\n    MusicRecognitionInput.prototype.getStaff = function () {\n        return this.staff;\n    };\n\n    /**\n     * Set the staff\n     *\n     * @method setStaff\n     * @param {MusicStaff} staff\n     */\n    MusicRecognitionInput.prototype.setStaff = function (staff) {\n        this.staff = staff;\n    };\n\n    /**\n     * Get the number of divisions\n     *\n     * @method getDivisions\n     * @returns {Number}\n     */\n    MusicRecognitionInput.prototype.getDivisions = function () {\n        return this.divisions;\n    };\n\n    /**\n     * Set the number of divisions\n     *\n     * @method setDivisions\n     * @param {Number} divisions\n     */\n    MusicRecognitionInput.prototype.setDivisions = function (divisions) {\n        this.divisions = divisions;\n    };\n\n    // Export\n    scope.MusicRecognitionInput = MusicRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for music input\n     *\n     * @class MusicRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function MusicRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognitionData.prototype.constructor = MusicRecognitionData;\n\n    /**\n     * Get music input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getMusicRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getMusicRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setMusicRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setMusicRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get music input\n     *\n     * @method getRecognitionInput\n     * @returns {MusicRecognitionInput}\n     */\n    MusicRecognitionData.prototype.getRecognitionInput = function () {\n        return this.musicInput;\n    };\n\n    /**\n     * Set music input\n     *\n     * @method setRecognitionInput\n     * @param {MusicRecognitionInput} input\n     */\n    MusicRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.musicInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.MusicRecognitionData = MusicRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Parameters used for analyzer recognition\n     *\n     * @class AnalyzerParameter\n     * @extends AbstractParameter\n     * @constructor\n     */\n    function AnalyzerParameter(obj) {\n        scope.AbstractParameter.call(this, obj);\n        this.textParameter = new scope.TextParameter();\n        this.textParameter.setLanguage('en_US');\n        this.textParameter.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerParameter.prototype = new scope.AbstractParameter();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerParameter.prototype.constructor = AnalyzerParameter;\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter}\n     */\n    AnalyzerParameter.prototype.getTextParameters = function () {\n        return this.textParameter;\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} parameters\n     */\n    AnalyzerParameter.prototype.setTextParameters = function (parameters) {\n        this.textParameter = parameters;\n    };\n\n    /**\n     * Get analyzer coordinate resolution\n     *\n     * @method getCoordinateResolution\n     * @returns {Number}\n     */\n    AnalyzerParameter.prototype.getCoordinateResolution = function () {\n        return this.coordinateResolution;\n    };\n\n    /**\n     * Set analyzer coordinate resolution\n     *\n     * @method setCoordinateResolution\n     * @param {Number} coordinateResolution\n     */\n    AnalyzerParameter.prototype.setCoordinateResolution = function (coordinateResolution) {\n        this.coordinateResolution = coordinateResolution;\n    };\n\n    // Export\n    scope.AnalyzerParameter = AnalyzerParameter;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition input object for analyzer recognition\n     *\n     * @class AnalyzerRecognitionInput\n     * @extends AbstractRecognitionInput\n     * @constructor\n     */\n    function AnalyzerRecognitionInput() {\n\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionInput.prototype = new scope.AbstractRecognitionInput();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionInput.prototype.constructor = AnalyzerRecognitionInput;\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getParameters\n     * @returns {AnalyzerParameter}\n     */\n    AnalyzerRecognitionInput.prototype.getParameters = function () {\n        return this.parameter;\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setParameters\n     * @param {AnalyzerParameter} parameters\n     */\n    AnalyzerRecognitionInput.prototype.setParameters = function (parameters) {\n        this.parameter = parameters;\n    };\n\n    /**\n     * Get input components\n     *\n     * @method getComponents\n     * @returns {AbstractComponent[]}\n     */\n    AnalyzerRecognitionInput.prototype.getComponents = function () {\n        return this.components;\n    };\n\n    /**\n     * Set input components\n     *\n     * @method setComponents\n     * @param {AbstractComponent[]} components\n     */\n    AnalyzerRecognitionInput.prototype.setComponents = function (components) {\n        this.components = components;\n    };\n\n    // Export\n    scope.AnalyzerRecognitionInput = AnalyzerRecognitionInput;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Recognition data for analyzer input\n     *\n     * @class AnalyzerRecognitionData\n     * @extends AbstractRecognitionData\n     * @constructor\n     */\n    function AnalyzerRecognitionData() {\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognitionData.prototype = new scope.AbstractRecognitionData();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognitionData.prototype.constructor = AnalyzerRecognitionData;\n\n    /**\n     * Get analyzer input\n     *\n     * @deprecated Use getRecognitionInput instead\n     * @method getAnalyzerRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getAnalyzerRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @deprecated Use setRecognitionInput instead\n     * @method setAnalyzerRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setAnalyzerRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    /**\n     * Get analyzer input\n     *\n     * @method getRecognitionInput\n     * @returns {AnalyzerRecognitionInput}\n     */\n    AnalyzerRecognitionData.prototype.getRecognitionInput = function () {\n        return this.analyzerInput;\n    };\n\n    /**\n     * Set analyzer input\n     *\n     * @method setRecognitionInput\n     * @param {AnalyzerRecognitionInput} input\n     */\n    AnalyzerRecognitionData.prototype.setRecognitionInput = function (input) {\n        this.analyzerInput = JSON.stringify(input);\n    };\n\n    // Export\n    scope.AnalyzerRecognitionData = AnalyzerRecognitionData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract result\n     *\n     * @class AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractResult(obj) {\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractResult.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractResult.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractResult = AbstractResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class AbstractRecoResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function AbstractRecoResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.instanceId = obj.instanceId;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractRecoResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    AbstractRecoResponseWSMessage.prototype.constructor = AbstractRecoResponseWSMessage;\n\n    /**\n     * Get instance id\n     *\n     * @method getInstanceId\n     * @returns {String}\n     */\n    AbstractRecoResponseWSMessage.prototype.getInstanceId = function () {\n        return this.instanceId;\n    };\n\n    /**\n     * Get document\n     *\n     * @method getDocument\n     * @returns {TextDocument|ShapeDocument|MathDocument|MusicDocument|AnalyzerDocument}\n     */\n    AbstractRecoResponseWSMessage.prototype.getDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AbstractRecoResponseWSMessage = AbstractRecoResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition hmac challenge message\n     *\n     * @class ChallengeResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ChallengeResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.challenge = obj.challenge;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ChallengeResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ChallengeResponseWSMessage.prototype.constructor = ChallengeResponseWSMessage;\n\n    /**\n     * Get the challenge\n     *\n     * @method getChallenge\n     * @returns {String}\n     */\n    ChallengeResponseWSMessage.prototype.getChallenge = function () {\n        return this.challenge;\n    };\n\n    // Export\n    scope.ChallengeResponseWSMessage = ChallengeResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition error message\n     *\n     * @class ErrorResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ErrorResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n        if (obj) {\n            this.error = obj.error;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ErrorResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ErrorResponseWSMessage.prototype.constructor = ErrorResponseWSMessage;\n\n    /**\n     * Get the error\n     *\n     * @method getError\n     * @returns {String}\n     */\n    ErrorResponseWSMessage.prototype.getError = function () {\n        return this.error;\n    };\n\n    // Export\n    scope.ErrorResponseWSMessage = ErrorResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition init message\n     *\n     * @class InitResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function InitResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    InitResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    InitResponseWSMessage.prototype.constructor = InitResponseWSMessage;\n\n    // Export\n    scope.InitResponseWSMessage = InitResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition reset message\n     *\n     * @class ResetResponseWSMessage\n     * @extends AbstractWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function ResetResponseWSMessage(obj) {\n        scope.AbstractWSMessage.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ResetResponseWSMessage.prototype = new scope.AbstractWSMessage();\n\n    /**\n     * Constructor property\n     */\n    ResetResponseWSMessage.prototype.constructor = ResetResponseWSMessage;\n\n    // Export\n    scope.ResetResponseWSMessage = ResetResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text ink ranges\n     *\n     * @class TextInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextInkRange(obj) {\n        if (obj) {\n            var cpt = obj.split(/[:-]+/);\n            this.startUnit = Number(cpt[0]);\n            this.startComponent = Number(cpt[1]);\n            this.startPoint = Number(cpt[2]);\n            this.endUnit = Number(cpt[3]);\n            this.endComponent = Number(cpt[4]);\n            this.endPoint = Number(cpt[5]);\n        }\n    }\n\n    /**\n     * Get start unit\n     *\n     * @method getStartUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartUnit = function () {\n        return this.startUnit;\n    };\n\n    /**\n     * Get end unit\n     *\n     * @method getEndUnit\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndUnit = function () {\n        return this.endUnit;\n    };\n\n    /**\n     * Get start component\n     *\n     * @method getStartComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartComponent = function () {\n        return this.startComponent;\n    };\n\n    /**\n     * Get end component\n     *\n     * @method getEndComponent\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndComponent = function () {\n        return this.endComponent;\n    };\n\n    /**\n     * Get start point\n     *\n     * @method getStartPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getStartPoint = function () {\n        return this.startPoint;\n    };\n\n    /**\n     * Get end point\n     *\n     * @method getEndPoint\n     * @returns {Number}\n     */\n    TextInkRange.prototype.getEndPoint = function () {\n        return this.endPoint;\n    };\n\n    // Export\n    scope.TextInkRange = TextInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text candidate\n     *\n     * @class TextCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextCandidate(obj) {\n        this.flags = [];\n        this.children = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedScore = obj.normalizedScore;\n            this.spellingDistortionRatio = obj.spellingDistortionRatio;\n            for (var i in obj.flags) {\n                this.flags.push(obj.flags[i]);\n            }\n            for (var j in obj.children) {\n                this.children.push(new scope.TextSegment(obj.children[j]));\n            }\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    TextCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getNormalizedScore = function () {\n        return this.normalizedScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    /**\n     * Get spelling distortion ratio\n     *\n     * @method getSpellingDistortionRatio\n     * @returns {Number}\n     */\n    TextCandidate.prototype.getSpellingDistortionRatio = function () {\n        return this.spellingDistortionRatio;\n    };\n\n    /**\n     * Get flags\n     *\n     * @method getFlags\n     * @returns {Array}\n     */\n    TextCandidate.prototype.getFlags = function () {\n        return this.flags;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {TextSegment[]}\n     */\n    TextCandidate.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    // Export\n    scope.TextCandidate = TextCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text document\n     *\n     * @class TextDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextDocument(obj) {\n        this.tagItems = [];\n        this.wordCandidates = [];\n        this.charCandidates = [];\n        if (obj) {\n            if (obj.textSegmentResult) {\n                this.textSegmentResult = new scope.TextSegment(obj.textSegmentResult);\n            }\n            for (var i in obj.tagItems) {\n                this.tagItems.push(new scope.TextTagItem(obj.tagItems[i]));\n            }\n            for (var j in obj.wordCandidates) {\n                this.wordCandidates.push(new scope.TextSegment(obj.wordCandidates[j]));\n            }\n            for (var k in obj.charCandidates) {\n                this.charCandidates.push(new scope.TextSegment(obj.charCandidates[k]));\n            }\n        }\n    }\n\n    /**\n     * Get tag items\n     *\n     * @method getTagItems\n     * @returns {TextTagItem[]}\n     */\n    TextDocument.prototype.getTagItems = function () {\n        return this.tagItems;\n    };\n\n    /**\n     * Get word segments\n     *\n     * @method getWordSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getWordSegments = function () {\n        return this.wordCandidates;\n    };\n\n    /**\n     * Get word segment\n     *\n     * @method getWordSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getWordSegment = function (inkRanges) {\n        for (var i = 0; i < this.getWordSegments().length; i++) {\n            if (JSON.stringify(this.getWordSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getWordSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get char segments\n     *\n     * @method getCharSegments\n     * @returns {TextSegment[]}\n     */\n    TextDocument.prototype.getCharSegments = function () {\n        return this.charCandidates;\n    };\n\n    /**\n     * Get char segment\n     *\n     * @method getCharSegment\n     * @param {TextInkRange[]} inkRanges\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getCharSegment = function (inkRanges) {\n        for (var i = 0; i < this.getCharSegments().length; i++) {\n            if (JSON.stringify(this.getCharSegments()[i].getInkRanges()) === JSON.stringify(inkRanges)) {\n                return this.getCharSegments()[i];\n            }\n        }\n        return undefined;\n    };\n\n    /**\n     * Get text segment\n     *\n     * @method getTextSegment\n     * @returns {TextSegment}\n     */\n    TextDocument.prototype.getTextSegment = function () {\n        return this.textSegmentResult;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    TextDocument.prototype.hasScratchOutResults = function () {\n        return false;\n    };\n\n    // Export\n    scope.TextDocument = TextDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text result\n     *\n     * @class TextResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    TextResult.prototype.constructor = TextResult;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResult.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResult = TextResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text segment\n     *\n     * @class TextSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextSegment(obj) {\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidateIdx = obj.selectedCandidateIdx;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges.split(/[\\s]+/);\n                for (var j in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[j]));\n                }\n            }\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.TextCandidate(obj.candidates[i]));\n            }\n        }\n    }\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {TextCandidate[]}\n     */\n    TextSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    TextSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIdx;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {TextCandidate}\n     */\n    TextSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextSegment = TextSegment;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text tag item\n     *\n     * @class TextTagItem\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function TextTagItem(obj) {\n        this.inkRanges = [];\n        if (obj) {\n            this.tagType = obj.tagType;\n            if (obj.inkRanges) {\n                var ranges = obj.inkRanges.split(/[\\s]+/);\n                for (var i in ranges) {\n                    this.inkRanges.push(new scope.TextInkRange(ranges[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * Get tag type\n     *\n     * @method getTagType\n     * @returns {String}\n     */\n    TextTagItem.prototype.getTagType = function () {\n        return this.tagType;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {TextInkRange[]}\n     */\n    TextTagItem.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.TextTagItem = TextTagItem;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition text result message\n     *\n     * @class TextResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function TextResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.TextDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    TextResponseWSMessage.prototype.constructor = TextResponseWSMessage;\n\n    /**\n     * Get text document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    TextResponseWSMessage.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.TextResponseWSMessage = TextResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract shape primitive\n     *\n     * @class AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AbstractShapePrimitive(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.beginDecoration = obj.beginDecoration;\n            this.beginTangentAngle = obj.beginTangentAngle;\n            this.endDecoration = obj.endDecoration;\n            this.endTangentAngle = obj.endTangentAngle;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is line\n     *\n     * @method isLine\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isLine = function () {\n        return this.type === 'line';\n    };\n\n    /**\n     * Is ellipse\n     *\n     * @method isEllipse\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.isEllipse = function () {\n        return this.type === 'ellipse';\n    };\n\n    /**\n     * Has begin decoration\n     *\n     * @method hasBeginDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasBeginDecoration = function () {\n        return typeof this.beginDecoration !== 'undefined';\n    };\n\n    /**\n     * Has end decoration\n     *\n     * @method hasEndDecoration\n     * @returns {Boolean}\n     */\n    AbstractShapePrimitive.prototype.hasEndDecoration = function () {\n        return typeof this.endDecoration !== 'undefined';\n    };\n\n    /**\n     * Get begin decoration\n     *\n     * @method getBeginDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getBeginDecoration = function () {\n        return this.beginDecoration;\n    };\n\n    /**\n     * Get end decoration\n     *\n     * @method getEndDecoration\n     * @returns {String}\n     */\n    AbstractShapePrimitive.prototype.getEndDecoration = function () {\n        return this.endDecoration;\n    };\n\n    /**\n     * Get begin tangent angle\n     *\n     * @method getBeginTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getBeginTangentAngle = function () {\n        return this.beginTangentAngle;\n    };\n\n    /**\n     * Get end tangent angle\n     *\n     * @method getEndTangentAngle\n     * @returns {Number}\n     */\n    AbstractShapePrimitive.prototype.getEndTangentAngle = function () {\n        return this.endTangentAngle;\n    };\n\n    // Export\n    scope.AbstractShapePrimitive = AbstractShapePrimitive;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape candidate\n     *\n     * @class ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeCandidate(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    ShapeCandidate.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is erased\n     *\n     * @method isErased\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isErased = function () {\n        return this.type === 'erased';\n    };\n\n    /**\n     * Is scratch-out\n     *\n     * @method isScratchOut\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isScratchOut = function () {\n        return this.type === 'scratchOut';\n    };\n\n    /**\n     * Is not recognized\n     *\n     * @method isNotRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isNotRecognized = function () {\n        return this.type === 'notRecognized';\n    };\n\n    /**\n     * Is recognized\n     *\n     * @method isRecognized\n     * @returns {Boolean}\n     */\n    ShapeCandidate.prototype.isRecognized = function () {\n        return this.type === 'recognizedShape';\n    };\n\n    // Export\n    scope.ShapeCandidate = ShapeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape document\n     *\n     * @class ShapeDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeDocument(obj) {\n        this.segments = [];\n        if (obj) {\n            for (var i in obj.segments) {\n                this.segments.push(new scope.ShapeSegment(obj.segments[i]));\n            }\n        }\n    }\n\n    /**\n     * Get segments\n     *\n     * @method getSegments\n     * @returns {ShapeSegment[]}\n     */\n    ShapeDocument.prototype.getSegments = function () {\n        return this.segments;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    ShapeDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getSegments()) {\n            var currentSeg = this.getSegments()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.ShapeDocument = ShapeDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ellipse\n     *\n     * @class ShapeEllipse\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeEllipse(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.center = new scope.Point(obj.center);\n            this.minRadius = obj.minRadius;\n            this.maxRadius = obj.maxRadius;\n            this.orientation = obj.orientation;\n            this.startAngle = obj.startAngle;\n            this.sweepAngle = obj.sweepAngle;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeEllipse.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeEllipse.prototype.constructor = ShapeEllipse;\n\n    /**\n     * Get center\n     *\n     * @method getCenter\n     * @returns {Point}\n     */\n    ShapeEllipse.prototype.getCenter = function () {\n        return this.center;\n    };\n\n    /**\n     * Get min radius\n     *\n     * @method getMinRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMinRadius = function () {\n        return this.minRadius;\n    };\n\n    /**\n     * Get max radius\n     *\n     * @method getMaxRadius\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getMaxRadius = function () {\n        return this.maxRadius;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    ShapeEllipse.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get start angle\n     *\n     * @method getStartAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getStartAngle = function () {\n        return this.startAngle;\n    };\n\n    /**\n     * Get sweep angle\n     *\n     * @method getSweepAngle\n     * @returns {Number}\n     */\n    ShapeEllipse.prototype.getSweepAngle = function () {\n        return this.sweepAngle;\n    };\n\n    // Export\n    scope.ShapeEllipse = ShapeEllipse;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape erased\n     *\n     * @class ShapeErased\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeErased(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeErased.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeErased.prototype.constructor = ShapeErased;\n\n    // Export\n    scope.ShapeErased = ShapeErased;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape ink range\n     *\n     * @class ShapeInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeInkRange(obj) {\n        if (obj) {\n            this.firstStroke = obj.firstStroke;\n            this.lastStroke = obj.lastStroke;\n            this.firstPoint = obj.firstPoint;\n            this.lastPoint = obj.lastPoint;\n        }\n    }\n\n    /**\n     * Get first stroke\n     *\n     * @method getFirstStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstStroke = function () {\n        return this.firstStroke;\n    };\n\n    /**\n     * Get last stroke\n     *\n     * @method getLastStroke\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastStroke = function () {\n        return this.lastStroke;\n    };\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Number}\n     */\n    ShapeInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeInkRange = ShapeInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape line\n     *\n     * @class ShapeLine\n     * @extends AbstractShapePrimitive\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeLine(obj) {\n        scope.AbstractShapePrimitive.call(this, obj);\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeLine.prototype = new scope.AbstractShapePrimitive();\n\n    /**\n     * Constructor property\n     */\n    ShapeLine.prototype.constructor = ShapeLine;\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    ShapeLine.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    // Export\n    scope.ShapeLine = ShapeLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape not recognized\n     *\n     * @class ShapeNotRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeNotRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeNotRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeNotRecognized.prototype.constructor = ShapeNotRecognized;\n\n    // Export\n    scope.ShapeNotRecognized = ShapeNotRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognized\n     *\n     * @class ShapeRecognized\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeRecognized(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.primitives = [];\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n            this.resemblanceScore = obj.resemblanceScore;\n            for (var i in obj.primitives) {\n                switch (obj.primitives[i].type) {\n                    case 'line':\n                        this.primitives.push(new scope.ShapeLine(obj.primitives[i]));\n                        break;\n                    case 'ellipse':\n                        this.primitives.push(new scope.ShapeEllipse(obj.primitives[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown shape primitive');\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognized.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognized.prototype.constructor = ShapeRecognized;\n\n    /**\n     * Get primitives\n     *\n     * @method getPrimitives\n     * @returns {AbstractShapePrimitive[]}\n     */\n    ShapeRecognized.prototype.getPrimitives = function () {\n        return this.primitives;\n    };\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    ShapeRecognized.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get normalized score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    /**\n     * Get resemblance score\n     *\n     * @method getResemblanceScore\n     * @returns {Number}\n     */\n    ShapeRecognized.prototype.getResemblanceScore = function () {\n        return this.resemblanceScore;\n    };\n\n    // Export\n    scope.ShapeRecognized = ShapeRecognized;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape result\n     *\n     * @class ShapeResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.ShapeDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    ShapeResult.prototype.constructor = ShapeResult;\n\n    /**\n     * Get shape document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getShapeDocument\n     * @returns {ShapeDocument}\n     */\n    ShapeResult.prototype.getShapeDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.ShapeResult = ShapeResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape scratch-out\n     *\n     * @class ShapeScratchOut\n     * @extends ShapeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeScratchOut(obj) {\n        scope.ShapeCandidate.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeScratchOut.prototype = new scope.ShapeCandidate();\n\n    /**\n     * Constructor property\n     */\n    ShapeScratchOut.prototype.constructor = ShapeScratchOut;\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.ShapeScratchOut = ShapeScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape segment\n     *\n     * @class ShapeSegment\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function ShapeSegment(obj) {\n        this.inkRanges = [];\n        this.candidates = [];\n        if (obj) {\n            this.elementType = obj.elementType;\n            this.uniqueID = obj.uniqueID;\n            this.selectedCandidateIndex = obj.selectedCandidateIndex;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'erased':\n                        this.candidates.push(new scope.ShapeErased(obj.candidates[i]));\n                        break;\n                    case 'scratchOut':\n                        this.candidates.push(new scope.ShapeScratchOut(obj.candidates[i]));\n                        break;\n                    case 'recognizedShape':\n                        this.candidates.push(new scope.ShapeRecognized(obj.candidates[i]));\n                        break;\n                    default:\n                        this.candidates.push(new scope.ShapeNotRecognized(obj.candidates[i]));\n                        break;\n                }\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.ShapeInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    ShapeSegment.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {ShapeInkRange[]}\n     */\n    ShapeSegment.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    ShapeSegment.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidateIndex;\n    };\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {ShapeCandidate[]}\n     */\n    ShapeSegment.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {ShapeCandidate}\n     */\n    ShapeSegment.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.ShapeSegment = ShapeSegment;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math node\n     *\n     * @class MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNode(obj) {\n        if (obj) {\n            this.name = obj.name;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathNode.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathNode = MathNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math non-terminal node\n     *\n     * @class MathNonTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathNonTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                switch (obj.candidates[i].type) {\n                    case 'nonTerminalNode':\n                        this.candidates.push(new scope.MathNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'terminalNode':\n                        this.candidates.push(new scope.MathTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'rule':\n                        this.candidates.push(new scope.MathRuleNode(obj.candidates[i]));\n                        break;\n                    case 'cell':\n                        this.candidates.push(new scope.MathCellNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'border':\n                        this.candidates.push(new scope.MathBorderNonTerminalNode(obj.candidates[i]));\n                        break;\n                    case 'table':\n                        this.candidates.push(new scope.MathTableRuleNode(obj.candidates[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.candidates[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathNonTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathNonTerminalNode.prototype.constructor = MathNonTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathNode[]}\n     */\n    MathNonTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathNode}\n     */\n    MathNonTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathNonTerminalNode.prototype.getInkRanges = function () {\n        if (this.getSelectedCandidate()) {\n            return this.getSelectedCandidate().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    // Export\n    scope.MathNonTerminalNode = MathNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract math result\n     *\n     * @class MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is LaTeX result\n     *\n     * @method isLatex\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isLaTex = function () {\n        return this.type === 'LATEX';\n    };\n\n    /**\n     * Is MathML result\n     *\n     * @method isMathMl\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isMathMl = function () {\n        return this.type === 'MATHML';\n    };\n\n    /**\n     * Is SymbolTree result\n     *\n     * @method isSymbolTree\n     * @returns {Boolean}\n     */\n    MathResultElement.prototype.isSymbolTree = function () {\n        return this.type === 'SYMBOLTREE';\n    };\n\n    // Export\n    scope.MathResultElement = MathResultElement;\n})(MyScript);","(function (scope) {\n    'use strict';\n    /**\n     * Math rule node\n     *\n     * @class MathRuleNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathRuleNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.children = [];\n        if (obj) {\n            this.name = obj.name;\n            for (var i in obj.children) {\n                switch (obj.children[i].type) {\n                    case 'nonTerminalNode':\n                        this.children.push(new scope.MathNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'terminalNode':\n                        this.children.push(new scope.MathTerminalNode(obj.children[i]));\n                        break;\n                    case 'rule':\n                        this.children.push(new scope.MathRuleNode(obj.children[i]));\n                        break;\n                    case 'cell':\n                        this.children.push(new scope.MathCellNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'border':\n                        this.children.push(new scope.MathBorderNonTerminalNode(obj.children[i]));\n                        break;\n                    case 'table':\n                        this.children.push(new scope.MathTableRuleNode(obj.children[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.children[i].type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRuleNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathRuleNode.prototype.constructor = MathRuleNode;\n\n    /**\n     * Get name\n     *\n     * @method getName\n     * @returns {String}\n     */\n    MathRuleNode.prototype.getName = function () {\n        return this.name;\n    };\n\n    /**\n     * Get children\n     *\n     * @method getChildren\n     * @returns {MathNode[]}\n     */\n    MathRuleNode.prototype.getChildren = function () {\n        return this.children;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathRuleNode.prototype.getInkRanges = function () {\n        var inkRanges = [];\n        for (var i in this.getChildren()) {\n            var childInkRanges = this.getChildren()[i].getInkRanges();\n            for (var j in childInkRanges) {\n                inkRanges.push(childInkRanges[j]);\n            }\n        }\n        return inkRanges;\n    };\n\n    // Export\n    scope.MathRuleNode = MathRuleNode;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math document\n     *\n     * @class MathDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                var result = obj.results[i];\n                switch (result.type) {\n                    case 'MATHML':\n                        this.results.push(new scope.MathMathMLResultElement(result));\n                        break;\n                    case 'LATEX':\n                        this.results.push(new scope.MathLaTexResultElement(result));\n                        break;\n                    case 'SYMBOLTREE':\n                        this.results.push(new scope.MathSymbolTreeResultElement(result));\n                        break;\n                    default:\n                        throw new Error('Unknown math result type: ' + result.type);\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MathScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MathResultElement[]}\n     */\n    MathDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MathScratchOut[]}\n     */\n    MathDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MathDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MathDocument = MathDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math ink range\n     *\n     * @class MathInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathInkRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MathInkRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MathInkRange = MathInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * LaTex result element\n     *\n     * @class MathLaTexResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathLaTexResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathLaTexResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathLaTexResultElement.prototype.constructor = MathLaTexResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathLaTexResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathLaTexResultElement = MathLaTexResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MathML result element\n     *\n     * @class MathMathMLResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathMathMLResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathMathMLResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathMathMLResultElement.prototype.constructor = MathMathMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MathMathMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathMathMLResultElement = MathMathMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math result\n     *\n     * @class MathResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MathResult.prototype.constructor = MathResult;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResult.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResult = MathResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math scratch-out\n     *\n     * @class MathScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathScratchOut(obj) {\n        this.inkRanges = [];\n        this.erasedInkRanges = [];\n        if (obj) {\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.erasedInkRanges) {\n                this.erasedInkRanges.push(new scope.MathInkRange(obj.erasedInkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get erased ink ranges\n     *\n     * @method getErasedInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathScratchOut.prototype.getErasedInkRanges = function () {\n        return this.erasedInkRanges;\n    };\n\n    // Export\n    scope.MathScratchOut = MathScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math symbol tree\n     *\n     * @class MathSymbolTreeResultElement\n     * @extends MathResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathSymbolTreeResultElement(obj) {\n        scope.MathResultElement.call(this, obj);\n        if (obj) {\n            if (obj.root) {\n                switch (obj.root.type) {\n                    case 'nonTerminalNode':\n                        this.root = new scope.MathNonTerminalNode(obj.root);\n                        break;\n                    case 'terminalNode':\n                        this.root = new scope.MathTerminalNode(obj.root);\n                        break;\n                    case 'rule':\n                        this.root = new scope.MathRuleNode(obj.root);\n                        break;\n                    case 'cell':\n                        this.root = new scope.MathCellNonTerminalNode(obj.root);\n                        break;\n                    case 'border':\n                        this.root = new scope.MathBorderNonTerminalNode(obj.root);\n                        break;\n                    case 'table':\n                        this.root = new scope.MathTableRuleNode(obj.root);\n                        break;\n                    default:\n                        throw new Error('Unknown math node type: ' + obj.root.type);\n                }\n                this.value = JSON.stringify(obj.root, null, '  ');\n            } else {\n                throw new Error('Missing root');\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathSymbolTreeResultElement.prototype = new scope.MathResultElement();\n\n    /**\n     * Constructor property\n     */\n    MathSymbolTreeResultElement.prototype.constructor = MathSymbolTreeResultElement;\n\n    /**\n     * Get tree root\n     *\n     * @method getRoot\n     * @returns {MathNode}\n     */\n    MathSymbolTreeResultElement.prototype.getRoot = function () {\n        return this.root;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathSymbolTreeResultElement.prototype.getInkRanges = function () {\n        if (this.getRoot()) {\n            return this.getRoot().getInkRanges();\n        } else {\n            throw new Error('No selected candidate');\n        }\n    };\n\n    /**\n    * Get value\n    *\n    * @method getValue\n    * @returns {String}\n    */\n    MathSymbolTreeResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MathSymbolTreeResultElement = MathSymbolTreeResultElement;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node\n     *\n     * @class MathTerminalNode\n     * @extends MathNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNode(obj) {\n        scope.MathNode.call(this, obj);\n        this.candidates = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.selectedCandidate = obj.selectedCandidate;\n            for (var i in obj.candidates) {\n                this.candidates.push(new scope.MathTerminalNodeCandidate(obj.candidates[i]));\n            }\n            for (var j in obj.inkRanges) {\n                this.inkRanges.push(new scope.MathInkRange(obj.inkRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTerminalNode.prototype = new scope.MathNode();\n\n    /**\n     * Constructor property\n     */\n    MathTerminalNode.prototype.constructor = MathTerminalNode;\n\n    /**\n     * Get candidates\n     *\n     * @method getCandidates\n     * @returns {MathTerminalNodeCandidate[]}\n     */\n    MathTerminalNode.prototype.getCandidates = function () {\n        return this.candidates;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {MathInkRange[]}\n     */\n    MathTerminalNode.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get selected candidate index\n     *\n     * @method getSelectedCandidateIdx\n     * @returns {Number}\n     */\n    MathTerminalNode.prototype.getSelectedCandidateIdx = function () {\n        return this.selectedCandidate;\n    };\n\n    /**\n     * Get selected candidate\n     *\n     * @method getSelectedCandidate\n     * @returns {MathTerminalNodeCandidate}\n     */\n    MathTerminalNode.prototype.getSelectedCandidate = function () {\n        if ((this.getCandidates().length > 0) && (this.getSelectedCandidateIdx() !== undefined)) {\n            return this.getCandidates()[this.getSelectedCandidateIdx()];\n        } else {\n            return undefined;\n        }\n    };\n\n    // Export\n    scope.MathTerminalNode = MathTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math terminal node candidate\n     *\n     * @class MathTerminalNodeCandidate\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTerminalNodeCandidate(obj) {\n        if (obj) {\n            this.label = obj.label;\n            this.normalizedRecognitionScore = obj.normalizedRecognitionScore;\n        }\n    }\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MathTerminalNodeCandidate.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    /**\n     * Get score\n     *\n     * @method getNormalizedRecognitionScore\n     * @returns {Number}\n     */\n    MathTerminalNodeCandidate.prototype.getNormalizedRecognitionScore = function () {\n        return this.normalizedRecognitionScore;\n    };\n\n    // Export\n    scope.MathTerminalNodeCandidate = MathTerminalNodeCandidate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Math border data\n     *\n     * @class MathBorderData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderData(obj) {\n        if (obj) {\n            this.position = obj.position;\n            this.start = obj.start;\n            this.stop = obj.stop;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get position\n     *\n     * @method getPosition\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getPosition = function () {\n        return this.position;\n    };\n\n    /**\n     * Get start\n     *\n     * @method getStart\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStart = function () {\n        return this.start;\n    };\n\n    /**\n     * Get stop\n     *\n     * @method getStop\n     * @returns {Number}\n     */\n    MathBorderData.prototype.getStop = function () {\n        return this.stop;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MathBorderData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MathBorderData = MathBorderData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math border non-terminal node\n     *\n     * @class MathBorderNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathBorderNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathBorderData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathBorderNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathBorderNonTerminalNode.prototype.constructor = MathBorderNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathBorderData}\n     */\n    MathBorderNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathBorderNonTerminalNode = MathBorderNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell data\n     *\n     * @class MathCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellData(obj) {\n        if (obj) {\n            this.columnStart = obj.columnStart;\n            this.columnStop = obj.columnStop;\n            this.rowStart = obj.rowStart;\n            this.rowStop = obj.rowStop;\n        }\n    }\n\n    /**\n     * Get column start\n     *\n     * @method getColumnStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStart = function () {\n        return this.columnStart;\n    };\n\n    /**\n     * Get column stop\n     *\n     * @method getColumnStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getColumnStop = function () {\n        return this.columnStop;\n    };\n\n    /**\n     * Get row start\n     *\n     * @method getRowStart\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStart = function () {\n        return this.rowStart;\n    };\n\n    /**\n     * Get row stop\n     *\n     * @method getRowStop\n     * @returns {Number}\n     */\n    MathCellData.prototype.getRowStop = function () {\n        return this.rowStop;\n    };\n\n    // Export\n    scope.MathCellData = MathCellData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math cell non-terminal node\n     *\n     * @class MathCellNonTerminalNode\n     * @extends MathNonTerminalNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathCellNonTerminalNode(obj) {\n        scope.MathNonTerminalNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathCellNonTerminalNode.prototype = new scope.MathNonTerminalNode();\n\n    /**\n     * Constructor property\n     */\n    MathCellNonTerminalNode.prototype.constructor = MathCellNonTerminalNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathCellData}\n     */\n    MathCellNonTerminalNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathCellNonTerminalNode = MathCellNonTerminalNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table data\n     *\n     * @class MathTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    MathTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.MathTableData = MathTableData;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math table rule node\n     *\n     * @class MathTableRuleNode\n     * @extends MathRuleNode\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MathTableRuleNode(obj) {\n        scope.MathRuleNode.call(this, obj);\n        if (obj) {\n            this.data = new scope.MathTableData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathTableRuleNode.prototype = new scope.MathRuleNode();\n\n    /**\n     * Constructor property\n     */\n    MathTableRuleNode.prototype.constructor = MathTableRuleNode;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {MathTableData}\n     */\n    MathTableRuleNode.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.MathTableRuleNode = MathTableRuleNode;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * WebSocket recognition math result message\n     *\n     * @class MathResponseWSMessage\n     * @extends AbstractRecoResponseWSMessage\n     * @param {Object} [obj] Recognition WebSocket message\n     * @constructor\n     */\n    function MathResponseWSMessage(obj) {\n        scope.AbstractRecoResponseWSMessage.call(this, obj);\n        if (obj) {\n            this.result = new scope.MathDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathResponseWSMessage.prototype = new scope.AbstractRecoResponseWSMessage();\n\n    /**\n     * Constructor property\n     */\n    MathResponseWSMessage.prototype.constructor = MathResponseWSMessage;\n\n    /**\n     * Get math document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMathDocument\n     * @returns {MathDocument}\n     */\n    MathResponseWSMessage.prototype.getMathDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MathResponseWSMessage = MathResponseWSMessage;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music element\n     *\n     * @class MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicElement(obj) {\n        if (obj) {\n            this.inputRanges = [];\n            this.elementType = obj.elementType;\n            this.inputRanges = obj.inputRanges;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    MusicElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicElement.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    // Export\n    scope.MusicElement = MusicElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract music result element\n     *\n     * @class MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResultElement(obj) {\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicResultElement.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Is MusicXML\n     *\n     * @method isMusicXML\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isMusicXML = function () {\n        return this.type === 'MUSICXML';\n    };\n\n    /**\n     * Is ScoreTree\n     *\n     * @method isScoreTree\n     * @returns {Boolean}\n     */\n    MusicResultElement.prototype.isScoreTree = function () {\n        return this.type === 'SCORETREE';\n    };\n\n    // Export\n    scope.MusicResultElement = MusicResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music accidental\n     *\n     * @class MusicAccidental\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAccidental(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAccidental.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAccidental.prototype.constructor = MusicAccidental;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicAccidental.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicAccidental = MusicAccidental;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music annotation\n     *\n     * @class MusicAnnotation\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicAnnotation(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.label = obj.label;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicAnnotation.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicAnnotation.prototype.constructor = MusicAnnotation;\n\n    /**\n     * Get label\n     *\n     * @method getLabel\n     * @returns {String}\n     */\n    MusicAnnotation.prototype.getLabel = function () {\n        return this.label;\n    };\n\n    // Export\n    scope.MusicAnnotation = MusicAnnotation;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music arpeggiate\n     *\n     * @class MusicArpeggiate\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicArpeggiate(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicArpeggiate.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicArpeggiate.prototype.constructor = MusicArpeggiate;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicArpeggiate.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicArpeggiate = MusicArpeggiate;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music bar\n     *\n     * @class MusicBar\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBar(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        if (obj) {\n            this.repeatDirection = obj.repeatDirection;\n            this.style = obj.style;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBar.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBar.prototype.constructor = MusicBar;\n\n    /**\n     * Get repeat direction\n     *\n     * @method getRepeatDirection\n     * @returns {String}\n     */\n    MusicBar.prototype.getRepeatDirection = function () {\n        return this.repeatDirection;\n    };\n\n    /**\n     * Set repeat direction\n     *\n     * @method setRepeatDirection\n     * @param {String} repeatDirection\n     */\n    MusicBar.prototype.setRepeatDirection = function (repeatDirection) {\n        this.repeatDirection = repeatDirection;\n    };\n\n    /**\n     * Get style\n     *\n     * @method getStyle\n     * @returns {String}\n     */\n    MusicBar.prototype.getStyle = function () {\n        return this.style;\n    };\n\n    /**\n     * Set style\n     *\n     * @method setStyle\n     * @param {String} style\n     */\n    MusicBar.prototype.setStyle = function (style) {\n        this.style = style;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicBar.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Set decorations\n     *\n     * @method setDecorations\n     * @param {MusicDecoration[]}\n     */\n    MusicBar.prototype.setDecorations = function (decorations) {\n        this.decorations = decorations;\n    };\n\n    // Export\n    scope.MusicBar = MusicBar;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music beam\n     *\n     * @class MusicBeam\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicBeam(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.gap = obj.gap;\n            this.slope = obj.slope;\n            this.placement = obj.placement;\n            this.leftCount = obj.leftCount;\n            this.rightCount = obj.rightCount;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicBeam.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicBeam.prototype.constructor = MusicBeam;\n\n    /**\n     * Get gap\n     *\n     * @method getGap\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getGap = function () {\n        return this.gap;\n    };\n\n    /**\n     * Set gap\n     *\n     * @method setGap\n     * @param {Number} gap\n     */\n    MusicBeam.prototype.setGap = function (gap) {\n        this.gap = gap;\n    };\n\n    /**\n     * Get slope\n     *\n     * @method getSlope\n     * @returns {String}\n     */\n    MusicBeam.prototype.getSlope = function () {\n        return this.slope;\n    };\n\n    /**\n     * Set slope\n     *\n     * @method setSlope\n     * @param {String} slope\n     */\n    MusicBeam.prototype.setSlope = function (slope) {\n        this.slope = slope;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicBeam.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicBeam.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    /**\n     * Get left count\n     *\n     * @method getLeftCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getLeftCount = function () {\n        return this.leftCount;\n    };\n\n    /**\n     * Set left count\n     *\n     * @method setLeftCount\n     * @param {Number} leftCount\n     */\n    MusicBeam.prototype.setLeftCount = function (leftCount) {\n        this.leftCount = leftCount;\n    };\n\n    /**\n     * Get right count\n     *\n     * @method getRightCount\n     * @returns {Number}\n     */\n    MusicBeam.prototype.getRightCount = function () {\n        return this.rightCount;\n    };\n\n    /**\n     * Set right count\n     *\n     * @method setRightCount\n     * @param {Number} rightCount\n     */\n    MusicBeam.prototype.setRightCount = function (rightCount) {\n        this.rightCount = rightCount;\n    };\n\n\n    // Export\n    scope.MusicBeam = MusicBeam;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music chord\n     *\n     * @class MusicChord\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicChord(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.notes = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.duration = obj.duration;\n            this.arpeggiate = new scope.MusicArpeggiate(obj.arpeggiate);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.notes) {\n                this.notes.push(new scope.MusicNote(obj.notes[j]));\n            }\n            for (var k in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[k]);\n            }\n            for (var l in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[l]));\n            }\n            for (var m in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[m]));\n            }\n            for (var n in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[n]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicChord.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicChord.prototype.constructor = MusicChord;\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicChord.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get arpeggiate\n     *\n     * @method getArpeggiate\n     * @returns {MusicArpeggiate}\n     */\n    MusicChord.prototype.getArpeggiate = function () {\n        return this.arpeggiate;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicChord.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicChord.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicChord.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get notes\n     *\n     * @method getNotes\n     * @returns {MusicNote[]}\n     */\n    MusicChord.prototype.getNotes = function () {\n        return this.notes;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicChord.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicChord.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicChord.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicChord = MusicChord;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music clef\n     * default values: symbol='G', octave=0\n     *\n     * @class MusicClef\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicClef(obj) {\n        scope.MusicElement.call(this, obj);\n        this.symbol = 'G';\n        this.octave = 0;\n        if (obj) {\n            this.line = obj.line;\n            this.yAnchor = obj.yAnchor;\n            this.octave = obj.octave;\n            this.symbol = obj.symbol;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicClef.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicClef.prototype.constructor = MusicClef;\n\n    /**\n     * Get y anchor\n     *\n     * @method getYAnchor\n     * @returns {Number}\n     */\n    MusicClef.prototype.getYAnchor = function () {\n        return this.yAnchor;\n    };\n\n    /**\n     * Set y anchor\n     *\n     * @method setYAnchor\n     * @param {Number} yAnchor\n     */\n    MusicClef.prototype.setYAnchor = function (yAnchor) {\n        this.yAnchor = yAnchor;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicClef.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Set line\n     *\n     * @method setLine\n     * @param {Number} line\n     */\n    MusicClef.prototype.setLine = function (line) {\n        this.line = line;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicClef.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Set octave\n     *\n     * @method setOctave\n     * @param {Number} octave\n     */\n    MusicClef.prototype.setOctave = function (octave) {\n        this.octave = octave;\n    };\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicClef.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicClef.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    // Export\n    scope.MusicClef = MusicClef;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music decoration\n     *\n     * @class MusicDecoration\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDecoration(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.symbol = obj.symbol;\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDecoration.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDecoration.prototype.constructor = MusicDecoration;\n\n    /**\n     * Get symbol\n     *\n     * @method getSymbol\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getSymbol = function () {\n        return this.symbol;\n    };\n\n    /**\n     * Set symbol\n     *\n     * @method setSymbol\n     * @param {String} symbol\n     */\n    MusicDecoration.prototype.setSymbol = function (symbol) {\n        this.symbol = symbol;\n    };\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicDecoration.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Set placement\n     *\n     * @method setPlacement\n     * @param {String} placement\n     */\n    MusicDecoration.prototype.setPlacement = function (placement) {\n        this.placement = placement;\n    };\n\n    // Export\n    scope.MusicDecoration = MusicDecoration;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music document\n     *\n     * @class MusicDocument\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDocument(obj) {\n        this.results = [];\n        this.scratchOutResults = [];\n        if (obj) {\n            for (var i in obj.results) {\n                switch (obj.results[i].type) {\n                    case 'MUSICXML':\n                        this.results.push(new scope.MusicXMLResultElement(obj.results[i]));\n                        break;\n                    default:\n                        this.results.push(new scope.MusicScoreTreeResultElement(obj.results[i]));\n                        break;\n                }\n            }\n            for (var j in obj.scratchOutResults) {\n                this.scratchOutResults.push(new scope.MusicScratchOut(obj.scratchOutResults[j]));\n            }\n        }\n    }\n\n    /**\n     * Get result elements\n     *\n     * @method getResultElements\n     * @returns {MusicResultElement[]}\n     */\n    MusicDocument.prototype.getResultElements = function () {\n        return this.results;\n    };\n\n    /**\n     * Get scratch-out results\n     *\n     * @method getScratchOutResults\n     * @returns {MusicScratchOut[]}\n     */\n    MusicDocument.prototype.getScratchOutResults = function () {\n        return this.scratchOutResults;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    MusicDocument.prototype.hasScratchOutResults = function () {\n        if (this.getScratchOutResults() && (this.getScratchOutResults().length > 0)) {\n            return true;\n        }\n        return false;\n    };\n\n    // Export\n    scope.MusicDocument = MusicDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music dots\n     *\n     * @class MusicDots\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicDots(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.count = obj.count;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicDots.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicDots.prototype.constructor = MusicDots;\n\n    /**\n     * Get dots counts\n     *\n     * @method getCount\n     * @returns {Number}\n     */\n    MusicDots.prototype.getCount = function () {\n        return this.count;\n    };\n\n    // Export\n    scope.MusicDots = MusicDots;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music head\n     *\n     * @class MusicHead\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicHead(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicHead.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicHead.prototype.constructor = MusicHead;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicHead.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicHead = MusicHead;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music input range\n     *\n     * @class MusicInputRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicInputRange(obj) {\n        if (obj) {\n            this.component = obj.component;\n            this.firstItem = obj.firstItem;\n            this.lastItem = obj.lastItem;\n        }\n    }\n\n    /**\n     * Get component\n     *\n     * @method getComponent\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getComponent = function () {\n        return this.component;\n    };\n\n    /**\n     * Get first item\n     *\n     * @method getFirstItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getFirstItem = function () {\n        return this.firstItem;\n    };\n\n    /**\n     * Get last item\n     *\n     * @method getLastItem\n     * @returns {Number}\n     */\n    MusicInputRange.prototype.getLastItem = function () {\n        return this.lastItem;\n    };\n\n    // Export\n    scope.MusicInputRange = MusicInputRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature\n     *\n     * @class MusicKeySignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignature(obj) {\n        scope.MusicElement.call(this, obj);\n        this.accidentals = [];\n        if (obj) {\n            this.signature = new scope.MusicKeySignatureData(obj.signature);\n            for (var i in obj.accidentals) {\n                this.accidentals.push(new scope.MusicAccidental(obj.accidentals[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicKeySignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicKeySignature.prototype.constructor = MusicKeySignature;\n\n    /**\n     * Get signature\n     *\n     * @method getSignature\n     * @returns {MusicKeySignatureData}\n     */\n    MusicKeySignature.prototype.getSignature = function () {\n        return this.signature;\n    };\n\n    /**\n     * Get accidentals\n     *\n     * @method getAccidentals\n     * @returns {MusicAccidental[]}\n     */\n    MusicKeySignature.prototype.getAccidentals = function () {\n        return this.accidentals;\n    };\n\n    // Export\n    scope.MusicKeySignature = MusicKeySignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music key signature data\n     *\n     * @class MusicKeySignatureData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicKeySignatureData(obj) {\n        if (obj) {\n            this.fifths = obj.fifths;\n            this.cancel = obj.cancel;\n        }\n    }\n\n    /**\n     * Get fifths\n     *\n     * @method getFifths\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getFifths = function () {\n        return this.fifths;\n    };\n\n    /**\n     * Get cancel\n     *\n     * @method getCancel\n     * @returns {Number}\n     */\n    MusicKeySignatureData.prototype.getCancel = function () {\n        return this.cancel;\n    };\n\n    // Export\n    scope.MusicKeySignatureData = MusicKeySignatureData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music ledger line\n     *\n     * @class MusicLedgerLine\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicLedgerLine(obj) {\n        scope.MusicElement.call(this, obj);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicLedgerLine.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicLedgerLine.prototype.constructor = MusicLedgerLine;\n\n    // Export\n    scope.MusicLedgerLine = MusicLedgerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music note\n     *\n     * @class MusicNote\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicNote(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.beamTypes = [];\n        this.ledgerLines = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.accidental = new scope.MusicAccidental(obj.accidental);\n            this.dots = new scope.MusicDots(obj.dots);\n            this.duration = obj.duration;\n            this.head = new scope.MusicHead(obj.head);\n            this.line = obj.line;\n            this.pitch = new scope.MusicPitchData(obj.pitch);\n            this.startBeam = new scope.MusicBeam(obj.startBeam);\n            this.stopBeam = new scope.MusicBeam(obj.stopBeam);\n            this.stem = new scope.MusicStem(obj.stem);\n            this.startTie = new scope.MusicTie(obj.startTie);\n            this.stopTie = new scope.MusicTie(obj.stopTie);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.type = obj.type;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var j in obj.beamTypes) {\n                this.beamTypes.push(obj.beamTypes[j]);\n            }\n            for (var k in obj.ledgerLines) {\n                this.ledgerLines.push(new scope.MusicLedgerLine(obj.ledgerLines[k]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicNote.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicNote.prototype.constructor = MusicNote;\n\n    /**\n     * Get accidental\n     *\n     * @method getAccidental\n     * @returns {MusicAccidental}\n     */\n    MusicNote.prototype.getAccidental = function () {\n        return this.accidental;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicNote.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicNote.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get head\n     *\n     * @method getHead\n     * @returns {MusicHead}\n     */\n    MusicNote.prototype.getHead = function () {\n        return this.head;\n    };\n\n    /**\n     * Get line\n     *\n     * @method getLine\n     * @returns {Number}\n     */\n    MusicNote.prototype.getLine = function () {\n        return this.line;\n    };\n\n    /**\n     * Get pitch\n     *\n     * @method getPitch\n     * @returns {MusicPitchData}\n     */\n    MusicNote.prototype.getPitch = function () {\n        return this.pitch;\n    };\n\n    /**\n     * Get start beam\n     *\n     * @method getStartBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStartBeam = function () {\n        return this.startBeam;\n    };\n\n    /**\n     * Get stop beam\n     *\n     * @method getStopBeam\n     * @returns {MusicBeam}\n     */\n    MusicNote.prototype.getStopBeam = function () {\n        return this.stopBeam;\n    };\n\n    /**\n     * Get stem\n     *\n     * @method getStem\n     * @returns {MusicStem}\n     */\n    MusicNote.prototype.getStem = function () {\n        return this.stem;\n    };\n\n    /**\n     * Get start tie\n     *\n     * @method getStartTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStartTie = function () {\n        return this.startTie;\n    };\n\n    /**\n     * Get stop tie\n     *\n     * @method getStopTie\n     * @returns {MusicTie}\n     */\n    MusicNote.prototype.getStopTie = function () {\n        return this.stopTie;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicNote.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicNote.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicNote.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicNote.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get beam types\n     *\n     * @method getBeamTypes\n     * @returns {Array}\n     */\n    MusicNote.prototype.getBeamTypes = function () {\n        return this.beamTypes;\n    };\n\n    /**\n     * Get ledger lines\n     *\n     * @method getLedgerLines\n     * @returns {MusicLedgerLine[]}\n     */\n    MusicNote.prototype.getLedgerLines = function () {\n        return this.ledgerLines;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicNote.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicNote = MusicNote;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music part\n     *\n     * @class MusicPart\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPart(obj) {\n        this.elements = [];\n        if (obj) {\n            for (var i in obj.elements) {\n                switch (obj.elements[i].elementType) {\n                    case 'accidental':\n                        this.elements.push(new scope.MusicAccidental(obj.elements[i]));\n                        break;\n                    case 'annotation':\n                        this.elements.push(new scope.MusicAnnotation(obj.elements[i]));\n                        break;\n                    case 'arpeggiate':\n                        this.elements.push(new scope.MusicArpeggiate(obj.elements[i]));\n                        break;\n                    case 'bar':\n                        this.elements.push(new scope.MusicBar(obj.elements[i]));\n                        break;\n                    case 'beam':\n                        this.elements.push(new scope.MusicBeam(obj.elements[i]));\n                        break;\n                    case 'chord':\n                        this.elements.push(new scope.MusicChord(obj.elements[i]));\n                        break;\n                    case 'clef':\n                        this.elements.push(new scope.MusicClef(obj.elements[i]));\n                        break;\n                    case 'decoration':\n                        this.elements.push(new scope.MusicDecoration(obj.elements[i]));\n                        break;\n                    case 'dots':\n                        this.elements.push(new scope.MusicDots(obj.elements[i]));\n                        break;\n                    case 'head':\n                        this.elements.push(new scope.MusicHead(obj.elements[i]));\n                        break;\n                    case 'keySignature':\n                        this.elements.push(new scope.MusicKeySignature(obj.elements[i]));\n                        break;\n                    case 'ledgerLine':\n                        this.elements.push(new scope.MusicLedgerLine(obj.elements[i]));\n                        break;\n                    case 'note':\n                        this.elements.push(new scope.MusicNote(obj.elements[i]));\n                        break;\n                    case 'rest':\n                        this.elements.push(new scope.MusicRest(obj.elements[i]));\n                        break;\n                    case 'slur':\n                        this.elements.push(new scope.MusicSlur(obj.elements[i]));\n                        break;\n                    case 'stem':\n                        this.elements.push(new scope.MusicStem(obj.elements[i]));\n                        break;\n                    case 'tie':\n                        this.elements.push(new scope.MusicTie(obj.elements[i]));\n                        break;\n                    case 'timeSignature':\n                        this.elements.push(new scope.MusicTimeSignature(obj.elements[i]));\n                        break;\n                    case 'tuplet':\n                        this.elements.push(new scope.MusicTuplet(obj.elements[i]));\n                        break;\n                    case 'tupletBracket':\n                        this.elements.push(new scope.MusicTupletBracket(obj.elements[i]));\n                        break;\n                    default:\n                        throw new Error('Unknown music element');\n                }\n            }\n        }\n    }\n\n    /**\n     * Get elements\n     *\n     * @method getElements\n     * @returns {MusicElement[]}\n     */\n    MusicPart.prototype.getElements = function () {\n        return this.elements;\n    };\n\n    // Export\n    scope.MusicPart = MusicPart;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music pitch data\n     *\n     * @class MusicPitchData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicPitchData(obj) {\n        if (obj) {\n            this.alteration = obj.alteration;\n            this.octave = obj.octave;\n            this.step = obj.step;\n        }\n    }\n\n    /**\n     * Get alteration\n     *\n     * @method getAlteration\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getAlteration = function () {\n        return this.alteration;\n    };\n\n    /**\n     * Get octave\n     *\n     * @method getOctave\n     * @returns {Number}\n     */\n    MusicPitchData.prototype.getOctave = function () {\n        return this.octave;\n    };\n\n    /**\n     * Get step\n     *\n     * @method getStep\n     * @returns {String}\n     */\n    MusicPitchData.prototype.getStep = function () {\n        return this.step;\n    };\n\n    // Export\n    scope.MusicPitchData = MusicPitchData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music rest\n     *\n     * @class MusicRest\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicRest(obj) {\n        scope.MusicElement.call(this, obj);\n        this.decorations = [];\n        this.startSlurs = [];\n        this.stopSlurs = [];\n        if (obj) {\n            this.type = obj.type;\n            this.dots = new scope.MusicDots(obj.dots);\n            this.startTuplet = new scope.MusicTuplet(obj.startTuplet);\n            this.stopTuplet = new scope.MusicTuplet(obj.stopTuplet);\n            this.timeModification = new scope.MusicTimeModificationData(obj.timeModification);\n            this.duration = obj.duration;\n            for (var i in obj.decorations) {\n                this.decorations.push(new scope.MusicDecoration(obj.decorations[i]));\n            }\n            for (var l in obj.startSlurs) {\n                this.startSlurs.push(new scope.MusicSlur(obj.startSlurs[l]));\n            }\n            for (var m in obj.stopSlurs) {\n                this.stopSlurs.push(new scope.MusicSlur(obj.stopSlurs[m]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRest.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicRest.prototype.constructor = MusicRest;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicRest.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {MusicDots}\n     */\n    MusicRest.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get start tuplet\n     *\n     * @method getStartTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStartTuplet = function () {\n        return this.startTuplet;\n    };\n\n    /**\n     * Get stop tuplet\n     *\n     * @method getStopTuplet\n     * @returns {MusicTuplet}\n     */\n    MusicRest.prototype.getStopTuplet = function () {\n        return this.stopTuplet;\n    };\n\n    /**\n     * Get time modification\n     *\n     * @method getTimeModification\n     * @returns {MusicTimeModificationData}\n     */\n    MusicRest.prototype.getTimeModification = function () {\n        return this.timeModification;\n    };\n\n    /**\n     * Get duration\n     *\n     * @method getDuration\n     * @returns {Number}\n     */\n    MusicRest.prototype.getDuration = function () {\n        return this.duration;\n    };\n\n    /**\n     * Get decorations\n     *\n     * @method getDecorations\n     * @returns {MusicDecoration[]}\n     */\n    MusicRest.prototype.getDecorations = function () {\n        return this.decorations;\n    };\n\n    /**\n     * Get start slurs\n     *\n     * @method getStartSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStartSlurs = function () {\n        return this.startSlurs;\n    };\n\n    /**\n     * Get stop slurs\n     *\n     * @method getStopSlurs\n     * @returns {MusicSlur[]}\n     */\n    MusicRest.prototype.getStopSlurs = function () {\n        return this.stopSlurs;\n    };\n\n    // Export\n    scope.MusicRest = MusicRest;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music result\n     *\n     * @class MusicResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.MusicDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    MusicResult.prototype.constructor = MusicResult;\n\n    /**\n     * Get music document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getMusicDocument\n     * @returns {MusicDocument}\n     */\n    MusicResult.prototype.getMusicDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.MusicResult = MusicResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music score\n     *\n     * @class MusicScore\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScore(obj) {\n        this.parts = [];\n        if (obj) {\n            for (var i in obj.parts) {\n                this.parts.push(new scope.MusicPart(obj.parts[i]));\n            }\n        }\n    }\n\n    /**\n     * Get parts\n     *\n     * @method getParts\n     * @returns {MusicPart[]}\n     */\n    MusicScore.prototype.getParts = function () {\n        return this.parts;\n    };\n\n    // Export\n    scope.MusicScore = MusicScore;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music score tree\n     *\n     * @class MusicScoreTreeResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScoreTreeResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.score = new scope.MusicScore(obj.score);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicScoreTreeResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicScoreTreeResultElement.prototype.constructor = MusicScoreTreeResultElement;\n\n    /**\n     * Get score\n     *\n     * @method getScore\n     * @returns {MusicScore}\n     */\n    MusicScoreTreeResultElement.prototype.getScore = function () {\n        return this.score;\n    };\n\n    // Export\n    scope.MusicScoreTreeResultElement = MusicScoreTreeResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music scratch-out\n     *\n     * @class MusicScratchOut\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicScratchOut(obj) {\n        this.inputRanges = [];\n        this.erasedInputRanges = [];\n        if (obj) {\n            for (var i in obj.inputRanges) {\n                this.inputRanges.push(new scope.MusicInputRange(obj.inputRanges[i]));\n            }\n            for (var j in obj.erasedInputRanges) {\n                this.erasedInputRanges.push(new scope.MusicInputRange(obj.erasedInputRanges[j]));\n            }\n        }\n    }\n\n    /**\n     * Get input ranges\n     *\n     * @method getInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getInputRanges = function () {\n        return this.inputRanges;\n    };\n\n    /**\n     * Get erased input ranges\n     *\n     * @method getErasedInputRanges\n     * @returns {MusicInputRange[]}\n     */\n    MusicScratchOut.prototype.getErasedInputRanges = function () {\n        return this.erasedInputRanges;\n    };\n\n    // Export\n    scope.MusicScratchOut = MusicScratchOut;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music slur\n     *\n     * @class MusicSlur\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicSlur(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicSlur.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicSlur.prototype.constructor = MusicSlur;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicSlur.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicSlur = MusicSlur;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music stem\n     *\n     * @class MusicStem\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicStem(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicStem.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicStem.prototype.constructor = MusicStem;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicStem.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicStem = MusicStem;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tie\n     *\n     * @class MusicTie\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTie(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.placement = obj.placement;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTie.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTie.prototype.constructor = MusicTie;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTie.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    // Export\n    scope.MusicTie = MusicTie;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time modification data\n     *\n     * @class MusicTimeModificationData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeModificationData(obj) {\n        if (obj) {\n            this.actual = obj.actual;\n            this.dots = obj.dots;\n            this.normal = obj.normal;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get actual\n     *\n     * @method getActual\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getActual = function () {\n        return this.actual;\n    };\n\n    /**\n     * Get dots\n     *\n     * @method getDots\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getDots = function () {\n        return this.dots;\n    };\n\n    /**\n     * Get normal\n     *\n     * @method getNormal\n     * @returns {Number}\n     */\n    MusicTimeModificationData.prototype.getNormal = function () {\n        return this.normal;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeModificationData.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeModificationData = MusicTimeModificationData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music time signature\n     *\n     * @class MusicTimeSignature\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTimeSignature(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.top = new scope.MusicAnnotation(obj.top);\n            this.bottom = new scope.MusicAnnotation(obj.bottom);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTimeSignature.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTimeSignature.prototype.constructor = MusicTimeSignature;\n\n    /**\n     * Get top\n     *\n     * @method getTop\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getTop = function () {\n        return this.top;\n    };\n\n    /**\n     * Get bottom\n     *\n     * @method getBottom\n     * @returns {MusicAnnotation}\n     */\n    MusicTimeSignature.prototype.getBottom = function () {\n        return this.bottom;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTimeSignature.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTimeSignature = MusicTimeSignature;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet bracket\n     *\n     * @class MusicTupletBracket\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTupletBracket(obj) {\n        scope.MusicElement.call(this, obj);\n        if (obj) {\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTupletBracket.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTupletBracket.prototype.constructor = MusicTupletBracket;\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    MusicTupletBracket.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.MusicTupletBracket = MusicTupletBracket;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music tuplet\n     *\n     * @class MusicTuplet\n     * @extends MusicElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicTuplet(obj) {\n        scope.MusicElement.call(this, obj);\n        this.brackets = [];\n        if (obj) {\n            this.placement = obj.placement;\n            this.number = new scope.MusicAnnotation(obj.number);\n            for (var i in obj.brackets) {\n                this.brackets.push(new scope.MusicTupletBracket(obj.brackets[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicTuplet.prototype = new scope.MusicElement();\n\n    /**\n     * Constructor property\n     */\n    MusicTuplet.prototype.constructor = MusicTuplet;\n\n    /**\n     * Get placement\n     *\n     * @method getPlacement\n     * @returns {String}\n     */\n    MusicTuplet.prototype.getPlacement = function () {\n        return this.placement;\n    };\n\n    /**\n     * Get number\n     *\n     * @method getNumber\n     * @returns {MusicAnnotation}\n     */\n    MusicTuplet.prototype.getNumber = function () {\n        return this.number;\n    };\n\n    /**\n     * Get brackets\n     *\n     * @method getBrackets\n     * @returns {Array}\n     */\n    MusicTuplet.prototype.getBrackets = function () {\n        return this.brackets;\n    };\n\n    // Export\n    scope.MusicTuplet = MusicTuplet;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * MusicXML result\n     *\n     * @class MusicXMLResultElement\n     * @extends MusicResultElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function MusicXMLResultElement(obj) {\n        scope.MusicResultElement.call(this, obj);\n        if (obj) {\n            this.value = obj.value;\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicXMLResultElement.prototype = new scope.MusicResultElement();\n\n    /**\n     * Constructor property\n     */\n    MusicXMLResultElement.prototype.constructor = MusicXMLResultElement;\n\n    /**\n     * Get value\n     *\n     * @method getValue\n     * @returns {String}\n     */\n    MusicXMLResultElement.prototype.getValue = function () {\n        return this.value;\n    };\n\n    // Export\n    scope.MusicXMLResultElement = MusicXMLResultElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element\n     *\n     * @class AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElement(obj) {\n        if (obj) {\n            this.elementType = obj.elementType;\n        }\n    }\n\n    /**\n     * Get element type\n     *\n     * @method getElementType\n     * @returns {String}\n     */\n    AnalyzerElement.prototype.getElementType = function () {\n        return this.elementType;\n    };\n\n    // Export\n    scope.AnalyzerElement = AnalyzerElement;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table cell\n     *\n     * @class AnalyzerCell\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCell(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerCellData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerCell.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerCell.prototype.constructor = AnalyzerCell;\n\n    /**\n     * Get analyzer cell data\n     *\n     * @method getData\n     * @returns {AnalyzerCellData}\n     */\n    AnalyzerCell.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerCell = AnalyzerCell;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer cell data\n     *\n     * @class AnalyzerCellData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerCellData(obj) {\n        if (obj) {\n            this.firstColumn = obj.firstColumn;\n            this.lastColumn = obj.lastColumn;\n            this.firstRow = obj.firstRow;\n            this.lastRow = obj.lastRow;\n            this.height = obj.height;\n            this.width = obj.width;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.topBorder = obj.topBorder;\n            this.bottomBorder = obj.bottomBorder;\n            this.leftBorder = obj.leftBorder;\n            this.rightBorder = obj.rightBorder;\n        }\n    }\n\n    /**\n     * Get first column\n     *\n     * @method getFirstColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstColumn = function () {\n        return this.firstColumn;\n    };\n\n    /**\n     * Get last column\n     *\n     * @method getLastColumn\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastColumn = function () {\n        return this.lastColumn;\n    };\n\n    /**\n     * Get first row\n     *\n     * @method getFirstRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getFirstRow = function () {\n        return this.firstRow;\n    };\n\n    /**\n     * Get last row\n     *\n     * @method getLastRow\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getLastRow = function () {\n        return this.lastRow;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerCellData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerCellData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerCellData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Has top border\n     *\n     * @method hasTopBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasTopBorder = function () {\n        return this.topBorder;\n    };\n\n    /**\n     * Has bottom border\n     *\n     * @method hasBottomBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasBottomBorder = function () {\n        return this.bottomBorder;\n    };\n\n    /**\n     * Has left border\n     *\n     * @method hasLeftBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasLeftBorder = function () {\n        return this.leftBorder;\n    };\n\n    /**\n     * Has right border\n     *\n     * @method hasRightBorder\n     * @returns {Boolean}\n     */\n    AnalyzerCellData.prototype.hasRightBorder = function () {\n        return this.rightBorder;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerCellData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        rectangle.setTopLeftPoint(this.getTopLeftPoint());\n        rectangle.setWidth(this.getWidth());\n        rectangle.setHeight(this.getHeight());\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerCellData = AnalyzerCellData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer document\n     *\n     * @class AnalyzerDocument\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerDocument(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.textLines = [];\n        this.shapes = [];\n        this.tables = [];\n        this.groups = [];\n        if (obj) {\n            for (var i in obj.textLines) {\n                this.textLines.push(new scope.AnalyzerTextLine(obj.textLines[i]));\n            }\n            for (var j in obj.shapes) {\n                this.shapes.push(new scope.ShapeSegment(obj.shapes[j]));\n            }\n            for (var k in obj.tables) {\n                this.tables.push(new scope.AnalyzerTable(obj.tables[k]));\n            }\n            for (var l in obj.groups) {\n                this.groups.push(new scope.AnalyzerGroup(obj.groups[l]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerDocument.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerDocument.prototype.constructor = AnalyzerDocument;\n\n    /**\n     * Get text lines\n     *\n     * @method getTextLines\n     * @returns {AnalyzerTextLine[]}\n     */\n    AnalyzerDocument.prototype.getTextLines = function () {\n        return this.textLines;\n    };\n\n    /**\n     * Get shapes\n     *\n     * @method getShapes\n     * @returns {ShapeSegment[]}\n     */\n    AnalyzerDocument.prototype.getShapes = function () {\n        return this.shapes;\n    };\n\n    /**\n     * Get tables\n     *\n     * @method getTables\n     * @returns {AnalyzerTable[]}\n     */\n    AnalyzerDocument.prototype.getTables = function () {\n        return this.tables;\n    };\n\n    /**\n     * Get groups\n     *\n     * @method getGroups\n     * @returns {AnalyzerGroup[]}\n     */\n    AnalyzerDocument.prototype.getGroups = function () {\n        return this.groups;\n    };\n\n    /**\n     * Has scratch-out results\n     *\n     * @method hasScratchOutResults\n     * @returns {Boolean}\n     */\n    AnalyzerDocument.prototype.hasScratchOutResults = function () {\n        for (var i in this.getShapes()) {\n            var currentSeg = this.getShapes()[i];\n            for (var j in currentSeg.getCandidates()) {\n                var currentCandidate = currentSeg.getCandidates()[j];\n                if (currentCandidate instanceof scope.ShapeScratchOut) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Export\n    scope.AnalyzerDocument = AnalyzerDocument;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer element reference\n     *\n     * @class AnalyzerElementReference\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerElementReference(obj) {\n        if (obj) {\n            this.uniqueID = obj.uniqueID;\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get unique id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerElementReference.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerElementReference = AnalyzerElementReference;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer group\n     *\n     * @class AnalyzerGroup\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerGroup(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.elementReferences = [];\n        if (obj) {\n            this.type = obj.type;\n            this.uniqueID = obj.uniqueID;\n            for (var i in obj.elementReferences) {\n                this.elementReferences.push(new scope.AnalyzerElementReference(obj.elementReferences[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerGroup.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerGroup.prototype.constructor = AnalyzerGroup;\n\n    /**\n     * Get element references\n     *\n     * @method getElementReferences\n     * @returns {AnalyzerElementReference[]}\n     */\n    AnalyzerGroup.prototype.getElementReferences = function () {\n        return this.elementReferences;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get unique Id\n     *\n     * @method getUniqueId\n     * @returns {String}\n     */\n    AnalyzerGroup.prototype.getUniqueId = function () {\n        return this.uniqueID;\n    };\n\n    // Export\n    scope.AnalyzerGroup = AnalyzerGroup;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer ink range\n     *\n     * @class AnalyzerInkRange\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerInkRange(obj) {\n        if (obj) {\n            this.firstPoint = new scope.Point(obj.firstPoint);\n            this.lastPoint = new scope.Point(obj.lastPoint);\n            this.stroke = new scope.AnalyzerRecognizedStroke(obj.stroke);\n        }\n    }\n\n    /**\n     * Get first point\n     *\n     * @method getFirstPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getFirstPoint = function () {\n        return this.firstPoint;\n    };\n\n    /**\n     * Get last point\n     *\n     * @method getLastPoint\n     * @returns {Point}\n     */\n    AnalyzerInkRange.prototype.getLastPoint = function () {\n        return this.lastPoint;\n    };\n\n    /**\n     * Get stroke\n     *\n     * @method getStroke\n     * @returns {null|*}\n     */\n    AnalyzerInkRange.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    // Export\n    scope.AnalyzerInkRange = AnalyzerInkRange;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line\n     *\n     * @class AnalyzerLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        if (obj) {\n            this.data = new scope.AnalyzerLineData(obj.data);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerLine.prototype.constructor = AnalyzerLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerLineData}\n     */\n    AnalyzerLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    // Export\n    scope.AnalyzerLine = AnalyzerLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer line data\n     *\n     * @class AnalyzerLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerLineData(obj) {\n        if (obj) {\n            this.p1 = new scope.Point(obj.p1);\n            this.p2 = new scope.Point(obj.p2);\n        }\n    }\n\n    /**\n     * Get p1\n     *\n     * @method getP1\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP1 = function () {\n        return this.p1;\n    };\n\n    /**\n     * Get p2\n     *\n     * @method getP2\n     * @returns {Point}\n     */\n    AnalyzerLineData.prototype.getP2 = function () {\n        return this.p2;\n    };\n\n    // Export\n    scope.AnalyzerLineData = AnalyzerLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * AnalyzerRecognizedStroke\n     *\n     * @class AnalyzerRecognizedStroke\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerRecognizedStroke(obj) {\n        if (obj) {\n            this.type = obj.type;\n            this.x = obj.x;\n            this.y = obj.y;\n        }\n    }\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerRecognizedStroke.prototype.getType = function () {\n        return this.type;\n    };\n\n    /**\n     * Get x\n     *\n     * @method getX\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getX = function () {\n        return this.x;\n    };\n\n    /**\n     * Get y\n     *\n     * @method getY\n     * @returns {Number[]}\n     */\n    AnalyzerRecognizedStroke.prototype.getY = function () {\n        return this.y;\n    };\n\n    // Export\n    scope.AnalyzerRecognizedStroke = AnalyzerRecognizedStroke;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer result\n     *\n     * @class AnalyzerResult\n     * @extends AbstractResult\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerResult(obj) {\n        scope.AbstractResult.call(this, obj);\n        if (obj) {\n            this.result = new scope.AnalyzerDocument(obj.result);\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerResult.prototype = new scope.AbstractResult();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerResult.prototype.constructor = AnalyzerResult;\n\n    /**\n     * Get analyzer document\n     *\n     * @deprecated Use getDocument() instead\n     * @method getAnalyzerDocument\n     * @returns {AnalyzerDocument}\n     */\n    AnalyzerResult.prototype.getAnalyzerDocument = function () {\n        return this.result;\n    };\n\n    // Export\n    scope.AnalyzerResult = AnalyzerResult;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer stroke type\n     *\n     * @class AnalyzerStrokeType\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerStrokeType(obj) {\n        if (obj) {\n            this.inkRange = new scope.AnalyzerInkRange(obj.inkRange);\n            this.type = obj.type;\n        }\n    }\n\n    /**\n     * Get ink range\n     *\n     * @method getInkRange\n     * @returns {AnalyzerInkRange}\n     */\n    AnalyzerStrokeType.prototype.getInkRange = function () {\n        return this.inkRange;\n    };\n\n    /**\n     * Get type\n     *\n     * @method getType\n     * @returns {String}\n     */\n    AnalyzerStrokeType.prototype.getType = function () {\n        return this.type;\n    };\n\n    // Export\n    scope.AnalyzerStrokeType = AnalyzerStrokeType;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table\n     *\n     * @class AnalyzerTable\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTable(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.lines = [];\n        this.cells = [];\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTableData(obj.data);\n            for (var i in obj.lines) {\n                this.lines.push(new scope.AnalyzerLine(obj.lines[i]));\n            }\n            for (var j in obj.cells) {\n                this.cells.push(new scope.AnalyzerCell(obj.cells[j]));\n            }\n            for (var k in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[k]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTable.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTable.prototype.constructor = AnalyzerTable;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTableData}\n     */\n    AnalyzerTable.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get lines\n     *\n     * @method getLines\n     * @returns {AnalyzerLine[]}\n     */\n    AnalyzerTable.prototype.getLines = function () {\n        return this.lines;\n    };\n\n    /**\n     * Get cells\n     *\n     * @method getCells\n     * @returns {AnalyzerCell[]}\n     */\n    AnalyzerTable.prototype.getCells = function () {\n        return this.cells;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTable.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerTable = AnalyzerTable;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer table data\n     *\n     * @class AnalyzerTableData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTableData(obj) {\n        if (obj) {\n            this.columnCount = obj.columnCount;\n            this.rowCount = obj.rowCount;\n        }\n    }\n\n    /**\n     * Get column count\n     *\n     * @method getColumnCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getColumnCount = function () {\n        return this.columnCount;\n    };\n\n    /**\n     * Get row count\n     *\n     * @method getRowCount\n     * @returns {Number}\n     */\n    AnalyzerTableData.prototype.getRowCount = function () {\n        return this.rowCount;\n    };\n\n    // Export\n    scope.AnalyzerTableData = AnalyzerTableData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line\n     *\n     * @class AnalyzerTextLine\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLine(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        this.underlineList = [];\n        if (obj) {\n            this.data = new scope.AnalyzerTextLineData(obj.data);\n            this.result = new scope.TextDocument(obj.result);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n            for (var j in obj.underlineList) {\n                this.underlineList.push(new scope.AnalyzerUnderline(obj.underlineList[j]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerTextLine.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerTextLine.prototype.constructor = AnalyzerTextLine;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerTextLineData}\n     */\n    AnalyzerTextLine.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get text document\n     *\n     * @method getTextDocument\n     * @returns {TextDocument}\n     */\n    AnalyzerTextLine.prototype.getTextDocument = function () {\n        return this.result;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerTextLine.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    /**\n     * Get underline list\n     *\n     * @method getUnderlineList\n     * @returns {AnalyzerUnderline[]}\n     */\n    AnalyzerTextLine.prototype.getUnderlineList = function () {\n        return this.underlineList;\n    };\n\n    // Export\n    scope.AnalyzerTextLine = AnalyzerTextLine;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer text line data\n     *\n     * @class AnalyzerTextLineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerTextLineData(obj) {\n        if (obj) {\n            this.baselinePos = obj.baselinePos;\n            this.toMidline = obj.toMidline;\n            this.orientation = obj.orientation;\n            this.topLeftPoint = new scope.Point(obj.topLeftPoint);\n            this.textHeight = obj.textHeight;\n            this.justificationType = obj.justificationType;\n            this.height = obj.height;\n            this.width = obj.width;\n        }\n    }\n\n    /**\n     * Get baseline position\n     *\n     * @method getBaselinePos\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getBaselinePos = function () {\n        return this.baselinePos;\n    };\n\n    /**\n     * Get to midline\n     *\n     * @method getToMidline\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getToMidline = function () {\n        return this.toMidline;\n    };\n\n    /**\n     * Get orientation\n     *\n     * @method getOrientation\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getOrientation = function () {\n        return this.orientation;\n    };\n\n    /**\n     * Get top-left point\n     *\n     * @method getTopLeftPoint\n     * @returns {Point}\n     */\n    AnalyzerTextLineData.prototype.getTopLeftPoint = function () {\n        return this.topLeftPoint;\n    };\n\n    /**\n     * Get text height\n     *\n     * @method getTextHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getTextHeight = function () {\n        return this.textHeight;\n    };\n\n    /**\n     * Get justification type\n     *\n     * @method getJustificationType\n     * @returns {String}\n     */\n    AnalyzerTextLineData.prototype.getJustificationType = function () {\n        return this.justificationType;\n    };\n\n    /**\n     * Get height\n     *\n     * @method getHeight\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getHeight = function () {\n        return this.height;\n    };\n\n    /**\n     * Get width\n     *\n     * @method getWidth\n     * @returns {Number}\n     */\n    AnalyzerTextLineData.prototype.getWidth = function () {\n        return this.width;\n    };\n\n    /**\n     * Get bounding box\n     *\n     * @method getBoundingBox\n     * @returns {Rectangle}\n     */\n    AnalyzerTextLineData.prototype.getBoundingBox = function () {\n        var rectangle = new scope.Rectangle();\n        if (this.getTopLeftPoint() || this.getWidth() || this.getHeight()) {\n            rectangle.setTopLeftPoint(this.getTopLeftPoint());\n            rectangle.setWidth(this.getWidth());\n            rectangle.setHeight(this.getHeight());\n        }\n        return rectangle;\n    };\n\n    // Export\n    scope.AnalyzerTextLineData = AnalyzerTextLineData;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline\n     *\n     * @class AnalyzerUnderline\n     * @extends AnalyzerElement\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderline(obj) {\n        scope.AnalyzerElement.call(this, obj);\n        this.inkRanges = [];\n        if (obj) {\n            this.data = new scope.AnalyzerUnderlineData(obj.data);\n            for (var i in obj.inkRanges) {\n                this.inkRanges.push(new scope.AnalyzerInkRange(obj.inkRanges[i]));\n            }\n        }\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerUnderline.prototype = new scope.AnalyzerElement();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerUnderline.prototype.constructor = AnalyzerUnderline;\n\n    /**\n     * Get data\n     *\n     * @method getData\n     * @returns {AnalyzerUnderlineData}\n     */\n    AnalyzerUnderline.prototype.getData = function () {\n        return this.data;\n    };\n\n    /**\n     * Get ink ranges\n     *\n     * @method getInkRanges\n     * @returns {AnalyzerInkRange[]}\n     */\n    AnalyzerUnderline.prototype.getInkRanges = function () {\n        return this.inkRanges;\n    };\n\n    // Export\n    scope.AnalyzerUnderline = AnalyzerUnderline;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer underline data\n     *\n     * @class AnalyzerUnderlineData\n     * @param {Object} [obj]\n     * @constructor\n     */\n    function AnalyzerUnderlineData(obj) {\n        if (obj) {\n            this.firstCharacter = obj.firstCharacter;\n            this.lastCharacter = obj.lastCharacter;\n        }\n    }\n\n    /**\n     * Get first character\n     *\n     * @method getFirstCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getFirstCharacter = function () {\n        return this.firstCharacter;\n    };\n\n    /**\n     * Get last character\n     *\n     * @method getLastCharacter\n     * @returns {Number}\n     */\n    AnalyzerUnderlineData.prototype.getLastCharacter = function () {\n        return this.lastCharacter;\n    };\n\n    // Export\n    scope.AnalyzerUnderlineData = AnalyzerUnderlineData;\n})(MyScript);","'use strict';\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkInterface\n     * @constructor\n     */\n    function NetworkInterface() {\n    }\n\n    /**\n     * Parse JSON String to Object\n     *\n     * @method parse\n     * @param {Object} req\n     * @returns {Object}\n     */\n    NetworkInterface.parse = function (req) {\n        var result;\n        try {\n            result = JSON.parse(req.responseText);\n        } catch (e) {\n            result = req.responseText;\n        }\n        return result;\n    };\n\n    /**\n     * Transform object data request to a list of parameters\n     *\n     * @method transformRequest\n     * @param {Object} [obj]\n     * @returns {String}\n     */\n    NetworkInterface.transformRequest = function (obj) {\n        var str = [];\n        for (var p in obj) {\n            if ((typeof obj[p] !== 'undefined') &&\n                (typeof obj[p] !== 'function')) {\n                str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n            }\n        }\n        return str.join('&');\n    };\n\n    /**\n     * Send request to the network and return a promise\n     *\n     * @method xhr\n     * @param {String} type\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.xhr = function (type, url, data) {\n\n        var deferred = Q.defer();\n\n        function onStateChange() {\n            if (request.readyState === 4) {\n                if (request.status >= 200 && request.status < 300) {\n                    deferred.resolve(NetworkInterface.parse(request));\n                }\n            }\n        }\n\n        function onLoad() {\n            if (request.status >= 200 && request.status < 300) {\n                deferred.resolve(NetworkInterface.parse(request));\n            } else {\n                deferred.reject(new Error(request.responseText));\n            }\n        }\n\n        function onError() {\n            deferred.reject(new Error('Can\\'t XHR ' + url));\n        }\n\n        function onProgress(event) {\n            deferred.notify(event.loaded / event.total);\n        }\n\n        var request = new XMLHttpRequest();\n        request.open(type, url, true);\n        request.withCredentials = true;\n        request.setRequestHeader('Accept', 'application/json');\n        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        request.onload = onLoad;\n        request.onerror = onError;\n        request.onprogress = onProgress;\n        request.onreadystatechange = onStateChange;\n        request.send(NetworkInterface.transformRequest(data));\n\n        return deferred.promise;\n    };\n\n    /**\n     * Get request\n     *\n     * @method get\n     * @param {String} src\n     * @param {Object} params\n     * @returns {Promise}\n     */\n    NetworkInterface.get = function (src, params) {\n        if (params) {\n            src += '?' + NetworkInterface.transformRequest(params);\n        }\n        return scope.NetworkInterface.xhr('GET', src, undefined);\n    };\n\n    /**\n     * Put request\n     *\n     * @method put\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.put = function (url, data) {\n        return scope.NetworkInterface.xhr('PUT', url, data);\n    };\n\n    /**\n     * Post request\n     *\n     * @method post\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.post = function (url, data) {\n        return scope.NetworkInterface.xhr('POST', url, data);\n    };\n\n    /**\n     * Delete request\n     *\n     * @method delete\n     * @param {String} url\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    NetworkInterface.delete = function (url, data) {\n        return scope.NetworkInterface.xhr('DELETE', url, data);\n    };\n\n    // Export\n    scope.NetworkInterface = NetworkInterface;\n})(MyScript, Q);\n","'use strict';\n/* jshint ignore:start */\n\n(function (scope, Q) {\n    /**\n     * Network interface\n     *\n     * @class NetworkWSInterface\n     * @constructor\n     */\n    function NetworkWSInterface(url, callback) {\n        this._url = url;\n        this._callback = callback;\n    }\n\n    NetworkWSInterface.prototype.send = function (request) {\n        if (this._socket) {\n            this._socket.send(JSON.stringify(request));\n        }\n    };\n\n    NetworkWSInterface.prototype.isClosed = function () {\n        if (this._socket) {\n            return this._socket.readyState === 3;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isClosing = function () {\n        if (this._socket) {\n            return this._socket.readyState === 2;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isOpen = function () {\n        if (this._socket) {\n            return this._socket.readyState === 1;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.isConnecting = function () {\n        if (this._socket) {\n            return this._socket.readyState === 0;\n        }\n        return false;\n    };\n\n    NetworkWSInterface.prototype.close = function (code, reason) {\n        if (this._socket) {\n            this._socket.close(code, reason);\n        }\n    };\n\n    NetworkWSInterface.prototype.open = function () {\n        var self = this;\n        this._socket = new WebSocket(this._url);\n\n        this._socket.onopen = function (e) {\n            self._callback(e);\n        };\n        this._socket.onclose = function (e) {\n            self._callback(e);\n        };\n        this._socket.onerror = function (e) {\n            self._callback(e);\n        };\n\n        this._socket.onmessage = function (e) {\n            self._callback({\n                type: e.type,\n                data: JSON.parse(e.data)\n            });\n        };\n    };\n\n    // Export\n    scope.NetworkWSInterface = NetworkWSInterface;\n})(MyScript, Q);\n/* jshint ignore:end */\n","'use strict';\n\n(function (scope, CryptoJS) {\n    /**\n     * Abstract recognizer interface\n     *\n     * @class AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractRecognizer(host) {\n        this.host = 'cloud.myscript.com';\n        if (host) {\n            this.setHost(host);\n        }\n    }\n\n    /**\n     * Get the recognition service host\n     *\n     * @method getHost\n     * @returns {string|String|*}\n     */\n    AbstractRecognizer.prototype.getHost = function() {\n        return this.host;\n    };\n\n    /**\n     * Set the recognition service host\n     *\n     * @method setHost\n     * @param {String}\n     */\n    AbstractRecognizer.prototype.setHost = function (host) {\n        if (host !== undefined) {\n            this.host = host;\n        }\n    };\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {AbstractParameter}\n     */\n    AbstractRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {AbstractParameter} parameters\n     */\n    AbstractRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Get the recognition languages available for an application and a specific inputMode\n     *\n     * @method getAvailableLanguageList\n     * @param {String} applicationKey\n     * @param {String} inputMode\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.getAvailableLanguageList = function (applicationKey, inputMode) {\n        var data = new scope.RecognitionLanguagesData();\n        data.setApplicationKey(applicationKey);\n        data.setInputMode(inputMode);\n\n        return scope.NetworkInterface.get('https://' + this.getHost() + '/api/v3.0/recognition/rest/text/languages.json', data).then(\n            function success(response) {\n                return response.result;\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do REST recognition\n     *\n     * @method doRestRecognition\n     * @param {AbstractRecognitionData} data\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.doRestRecognition = function (data, applicationKey, hmacKey, instanceId) {\n        data.setApplicationKey(applicationKey);\n        data.setInstanceId(instanceId);\n        if (hmacKey) {\n            data.setHmac(_computeHmac(data.getRecognitionInput(), applicationKey, hmacKey));\n        }\n\n        if (data instanceof scope.TextRecognitionData) {\n            return _doTextRecognition(this.getHost(), data);\n        } else if (data instanceof scope.ShapeRecognitionData) {\n            return _doShapeRecognition(this.getHost(), data);\n        } else if (data instanceof scope.MathRecognitionData) {\n            return _doMathRecognition(this.getHost(), data);\n        } else if (data instanceof scope.MusicRecognitionData) {\n            return _doMusicRecognition(this.getHost(), data);\n        } else if (data instanceof scope.AnalyzerRecognitionData) {\n            return _doAnalyzerRecognition(this.getHost(), data);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * Clear REST recognition\n     *\n     * @method clearRestRecognition\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    AbstractRecognizer.prototype.clearRestRecognition = function (instanceId) {\n        var data = {\n            instanceSessionId: instanceId\n        };\n        return _clearShapeRecognition(this.getHost(), data);\n    };\n\n    /**\n     * Do text recognition\n     *\n     * @private\n     * @method _doTextRecognition\n     * @param {String} host\n     * @param {TextRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doTextRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/text/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.TextResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doShapeRecognition\n     * @param {String} host\n     * @param {ShapeRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doShapeRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/shape/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Clear shape recognition\n     *\n     * @private\n     * @method _clearShapeRecognition\n     * @param {String} host\n     * @param {Object} data\n     * @returns {Promise}\n     */\n    var _clearShapeRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/shape/clearSessionId.json', data).then(\n            function success(response) {\n                return new scope.ShapeResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do shape recognition\n     *\n     * @private\n     * @method _doMathRecognition\n     * @param {String} host\n     * @param {MathRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doMathRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/math/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MathResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do music recognition\n     *\n     * @private\n     * @method _doMusicRecognition\n     * @param {String} host\n     * @param {MusicRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doMusicRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/music/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.MusicResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method _doAnalyzerRecognition\n     * @param {String} host\n     * @param {AnalyzerRecognitionData} data\n     * @returns {Promise}\n     */\n    var _doAnalyzerRecognition = function (host, data) {\n        return scope.NetworkInterface.post('https://' + host + '/api/v3.0/recognition/rest/analyzer/doSimpleRecognition.json', data).then(\n            function success(response) {\n                return new scope.AnalyzerResult(response);\n            },\n            function error(response) {\n                return response;\n            }\n        );\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @deprecated\n     * @method computeHmac\n     * @param {String} applicationKey\n     * @param {String} data\n     * @param {String} hmacKey\n     */\n    AbstractRecognizer.prototype.computeHmac = function (applicationKey, data, hmacKey) {\n        return _computeHmac(data, applicationKey, hmacKey);\n    };\n\n    /**\n     * Compute HMAC signature for server authentication\n     *\n     * @private\n     * @method _computeHmac\n     * @param {AbstractRecognitionInput} input\n     * @param {String} applicationKey\n     * @param {String} hmacKey\n     */\n    var _computeHmac = function (input, applicationKey, hmacKey) {\n        var jsonInput = (typeof input === 'object') ? JSON.stringify(input) : input;\n        return CryptoJS.HmacSHA512(jsonInput, applicationKey + hmacKey).toString(CryptoJS.enc.Hex);\n    };\n\n    // Export\n    scope.AbstractRecognizer = AbstractRecognizer;\n})(MyScript, CryptoJS);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Abstract WebSocket recognizer interface\n     *\n     * @class AbstractWSRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AbstractWSRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AbstractWSRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AbstractWSRecognizer.prototype.constructor = AbstractWSRecognizer;\n\n    AbstractWSRecognizer.prototype._init = function (endpoint, callback) {\n        this._wsInterface = new scope.NetworkWSInterface(endpoint, callback);\n    };\n\n    AbstractWSRecognizer.prototype.isClosed = function () {\n        return this._wsInterface.isClosed();\n    };\n\n    AbstractWSRecognizer.prototype.isClosing = function () {\n        return this._wsInterface.isClosing();\n    };\n\n    AbstractWSRecognizer.prototype.isOpen = function () {\n        return this._wsInterface.isOpen();\n    };\n\n    AbstractWSRecognizer.prototype.isConnecting = function () {\n        return this._wsInterface.isConnecting();\n    };\n\n    /**\n     * Open the socket\n     *\n     * @method open\n     */\n    AbstractWSRecognizer.prototype.open = function () {\n        this._wsInterface.open();\n    };\n\n    /**\n     * Close the socket\n     *\n     * @method close\n     */\n    AbstractWSRecognizer.prototype.close = function () {\n        this._wsInterface.close();\n    };\n\n    /**\n     * Send a message\n     *\n     * @method sendMessage\n     * @param {AbstractWSMessage} message\n     */\n    AbstractWSRecognizer.prototype.sendMessage = function (message) {\n        this._wsInterface.send(message);\n    };\n\n    /**\n     * Initialize the WebSocket\n     *\n     * @method initWSRecognition\n     * @param {String} applicationKey\n     */\n    AbstractWSRecognizer.prototype.initWSRecognition = function (applicationKey) {\n        var message = new scope.InitRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Authenticate the WebSocket client end with a handshake of HMAC signature\n     *\n     * @method takeUpHmacChallenge\n     * @param {String} applicationKey\n     * @param {String} challenge\n     * @param {String} hmacKey\n     */\n    AbstractWSRecognizer.prototype.takeUpHmacChallenge = function (applicationKey, challenge, hmacKey) {\n        var message = new scope.ChallengeRequestWSMessage();\n        message.setApplicationKey(applicationKey);\n        message.setChallenge(challenge);\n        if (hmacKey) {\n            message.setHmacSignature(this.computeHmac(applicationKey, challenge, hmacKey));\n        }\n        this.sendMessage(message);\n    };\n\n    /**\n     * Reset the WebSocket recognition session\n     *\n     * @method resetWSRecognition\n     */\n    AbstractWSRecognizer.prototype.resetWSRecognition = function () {\n        var message = new scope.ResetRequestWSMessage();\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.AbstractWSRecognizer = AbstractWSRecognizer;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Text recognizer interface\n     *\n     * @class TextRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextRecognizer.prototype.constructor = TextRecognizer;\n\n    /**\n     * Do text recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} hmacKey\n     * @param {TextParameter} [parameters]\n     * @returns {Promise}\n     */\n    TextRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, inputUnits, hmacKey, parameters) {\n        var input = new scope.TextRecognitionInput();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setParameters(params);\n        input.setInputUnits(inputUnits);\n\n        var data = new scope.TextRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.TextRecognizer = TextRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Text WebSocket recognizer interface\n     *\n     * @class TextWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function TextWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this, host);\n        this._endpoint = 'wss://' + this.getHost() + '/api/v3.0/recognition/ws/text';\n        this.parameters = new scope.TextParameter();\n        this.parameters.setLanguage('en_US');\n        this.parameters.setInputMode('CURSIVE');\n        this._init(this._endpoint, function (message) {\n            switch (message.type) {\n                case 'open':\n                    callback(message);\n                    break;\n                case 'close':\n                    callback(message);\n                    break;\n                case 'error':\n                    callback(undefined, message);\n                    break;\n                default:\n                    switch (message.data.type) {\n                        case 'init':\n                            message.data = new scope.InitResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'reset':\n                            message.data = new scope.ResetResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'error':\n                            message.data = new scope.ErrorResponseWSMessage(message.data);\n                            callback(undefined, message.data);\n                            break;\n                        case 'hmacChallenge':\n                            message.data = new scope.ChallengeResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        default:\n                            message.data = new scope.TextResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                    }\n                    break;\n            }\n        });\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    TextWSRecognizer.prototype.constructor = TextWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {TextParameter}\n     */\n    TextWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {TextParameter} parameters\n     */\n    TextWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextParameter} [parameters]\n     */\n    TextWSRecognizer.prototype.startWSRecognition = function (inputUnits, parameters) {\n        var message = new scope.TextStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setInputUnits(inputUnits);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {TextInputUnit[]} inputUnits\n     * @param {String} instanceId\n     */\n    TextWSRecognizer.prototype.continueWSRecognition = function (inputUnits, instanceId) {\n        var message = new scope.TextContinueRequestWSMessage();\n        message.setInputUnits(inputUnits);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.TextWSRecognizer = TextWSRecognizer;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Shape recognizer interface\n     *\n     * @class ShapeRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function ShapeRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.ShapeParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRecognizer.prototype.constructor = ShapeRecognizer;\n\n    /**\n     * Do shape recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {ShapeParameter} [parameters]\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.ShapeRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setDoBeautification(params.hasBeautification());\n        input.setRejectDetectionSensitivity(params.getRejectDetectionSensitivity());\n\n        var data = new scope.ShapeRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    /**\n     * Clear shape recognition session\n     *\n     * @method clearShapeRecognitionSession\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @returns {Promise}\n     */\n    ShapeRecognizer.prototype.clearShapeRecognitionSession = function (applicationKey, instanceId) {\n        return scope.AbstractRecognizer.prototype.clearRestRecognition.call(this, instanceId); // super\n    };\n\n    // Export\n    scope.ShapeRecognizer = ShapeRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math recognizer interface\n     *\n     * @class MathRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MathParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathRecognizer.prototype.constructor = MathRecognizer;\n\n    /**\n     * Do math recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MathParameter} [parameters]\n     * @returns {Promise}\n     */\n    MathRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.MathRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setResultTypes(params.getResultTypes());\n        input.setColumnar(params.isColumnar());\n        input.setScratchOutDetectionSensitivity(params.getScratchOutDetectionSensitivity());\n        input.setUserResources(params.getUserResources());\n\n        var data = new scope.MathRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MathRecognizer = MathRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Math WebSocket recognizer interface\n     *\n     * @class MathWSRecognizer\n     * @extends AbstractWSRecognizer\n     * @param {Function} callback The WebSocket response callback\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MathWSRecognizer(callback, host) {\n        scope.AbstractWSRecognizer.call(this, host);\n        this._endpoint = 'wss://' + this.getHost() + '/api/v3.0/recognition/ws/math';\n        this.parameters = new scope.MathParameter();\n        this._init(this._endpoint, function (message) {\n            switch (message.type) {\n                case 'open':\n                    callback(message);\n                    break;\n                case 'close':\n                    callback(message);\n                    break;\n                case 'error':\n                    callback(undefined, message);\n                    break;\n                default:\n                    switch (message.data.type) {\n                        case 'init':\n                            message.data = new scope.InitResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'reset':\n                            message.data = new scope.ResetResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        case 'error':\n                            message.data = new scope.ErrorResponseWSMessage(message.data);\n                            callback(undefined, message.data);\n                            break;\n                        case 'hmacChallenge':\n                            message.data = new scope.ChallengeResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                        default:\n                            message.data = new scope.MathResponseWSMessage(message.data);\n                            callback(message.data);\n                            break;\n                    }\n                    break;\n            }\n        });\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathWSRecognizer.prototype = new scope.AbstractWSRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MathWSRecognizer.prototype.constructor = MathWSRecognizer;\n\n    /**\n     * Get parameters\n     *\n     * @method getParameters\n     * @returns {MathParameter}\n     */\n    MathWSRecognizer.prototype.getParameters = function () {\n        return this.parameters;\n    };\n\n    /**\n     * Set parameters\n     *\n     * @method setParameters\n     * @param {MathParameter} parameters\n     */\n    MathWSRecognizer.prototype.setParameters = function (parameters) {\n        this.parameters = parameters;\n    };\n\n    /**\n     * Start the WebSocket session\n     *\n     * @method startWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {MathParameter} [parameters]\n     */\n    MathWSRecognizer.prototype.startWSRecognition = function (components, parameters) {\n        var message = new scope.MathStartRequestWSMessage();\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        message.setParameters(params);\n        message.setComponents(components);\n        this.sendMessage(message);\n    };\n\n    /**\n     * Continue the recognition\n     *\n     * @method continueWSRecognition\n     * @param {AbstractComponent[]} components\n     * @param {String} instanceId\n     */\n    MathWSRecognizer.prototype.continueWSRecognition = function (components, instanceId) {\n        var message = new scope.MathContinueRequestWSMessage();\n        message.setComponents(components);\n        message.setInstanceId(instanceId);\n        this.sendMessage(message);\n    };\n\n    // Export\n    scope.MathWSRecognizer = MathWSRecognizer;\n})(MyScript);","'use strict';\n\n(function (scope) {\n    /**\n     * Music recognizer interface\n     *\n     * @class MusicRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function MusicRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.MusicParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    MusicRecognizer.prototype.constructor = MusicRecognizer;\n\n    /**\n     * Do music recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {MusicParameter} [parameters]\n     * @returns {Promise}\n     */\n    MusicRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.MusicRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setStaff(params.getStaff());\n        input.setDivisions(params.getDivisions());\n        input.setResultTypes(params.getResultTypes());\n        input.setScratchOutDetectionSensitivity(params.getScratchOutDetectionSensitivity());\n        input.setUserResources(params.getUserResources());\n\n        var data = new scope.MusicRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.MusicRecognizer = MusicRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Analyzer recognizer interface\n     *\n     * @class AnalyzerRecognizer\n     * @extends AbstractRecognizer\n     * @param {String} [host='cloud.myscript.com'] Recognition service host\n     * @constructor\n     */\n    function AnalyzerRecognizer(host) {\n        scope.AbstractRecognizer.call(this, host);\n        this.parameters = new scope.AnalyzerParameter();\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRecognizer.prototype = new scope.AbstractRecognizer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRecognizer.prototype.constructor = AnalyzerRecognizer;\n\n    /**\n     * Do analyzer recognition\n     *\n     * @method doSimpleRecognition\n     * @param {String} applicationKey\n     * @param {String} instanceId\n     * @param {AbstractComponent[]} components\n     * @param {String} hmacKey\n     * @param {AnalyzerParameter} [parameters]\n     * @returns {Promise}\n     */\n    AnalyzerRecognizer.prototype.doSimpleRecognition = function (applicationKey, instanceId, components, hmacKey, parameters) {\n        var input = new scope.AnalyzerRecognitionInput();\n        input.setComponents(components);\n        var params = this.getParameters();\n        if (parameters) {\n            params = parameters;\n        }\n        input.setParameters(params);\n\n        var data = new scope.AnalyzerRecognitionData();\n        data.setRecognitionInput(input);\n        return scope.AbstractRecognizer.prototype.doRestRecognition.call(this, data, applicationKey, hmacKey, instanceId); // super\n    };\n\n    // Export\n    scope.AnalyzerRecognizer = AnalyzerRecognizer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Abstract Renderer. It's used to calculate the ink rendering in HTML5 canvas\n     *\n     * @class AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AbstractRenderer(context) {\n        this.penParameters = new scope.PenParameters();\n        this.showBoundingBoxes = false;\n        this.typeset = true;\n        this.context = context;\n        this.points = [];\n        this.drawing = false;\n    }\n\n    /**\n     * Get the context\n     *\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype.getContext = function () {\n        return this.context;\n    };\n\n    /**\n     * Set the context (legacy code for non-regression)\n     *\n     * @private\n     * @returns {Object}\n     */\n    AbstractRenderer.prototype._setContext = function (context) {\n        this.context = context;\n    };\n\n    /**\n     * This property is use to show or not show the bounding box\n     *\n     * @method getShowBoundingBoxes\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.getShowBoundingBoxes = function () {\n        return this.showBoundingBoxes;\n    };\n\n    /**\n     * Set the show state of bounding box\n     *\n     * @method setShowBoundingBoxes\n     * @param {Boolean} showBoundingBoxes\n     */\n    AbstractRenderer.prototype.setShowBoundingBoxes = function (showBoundingBoxes) {\n        this.showBoundingBoxes = showBoundingBoxes;\n    };\n\n    /**\n     * Get the default pen parameters\n     *\n     * @returns {PenParameters}\n     */\n    AbstractRenderer.prototype.getParameters = function () {\n        return this.penParameters;\n    };\n\n    /**\n     * Set the default pen parameters\n     *\n     * @param {PenParameters} penParameters\n     */\n    AbstractRenderer.prototype.setParameters = function (penParameters) {\n        this.penParameters = penParameters;\n    };\n\n    /**\n     * Is typesetting\n     *\n     * @returns {Boolean}\n     */\n    AbstractRenderer.prototype.isTypesetting = function () {\n        return this.typeset;\n    };\n\n    /**\n     * Enable / disable typesetting\n     *\n     * @param {Boolean} typeset\n     */\n    AbstractRenderer.prototype.setTypeset = function (typeset) {\n        this.typeset = typeset;\n    };\n\n    /**\n     * Clear the recognition context\n     *\n     * @method clear\n     */\n    AbstractRenderer.prototype.clear = function () {\n        this.getContext().clearRect(0, 0, this.getContext().canvas.width, this.getContext().canvas.height);\n    };\n\n    /**\n     * Draw recognition result on HTML5 canvas.\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {Object} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw input components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponents = function (components, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw component\n     *\n     * @method drawComponent\n     * @param {AbstractComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawComponent = function (component, context, parameters) {\n        if (component instanceof scope.Stroke) {\n            this.drawStroke(component, context, parameters);\n        } else if (component instanceof scope.CharacterInputComponent) {\n            this.drawCharacter(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw a rectangle on context\n     *\n     * @method drawRectangle\n     * @param {Rectangle} rectangle\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawRectangle = function (rectangle, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n\n        var params = this.getParameters();\n        this.getContext().save();\n        try {\n            this.getContext().fillStyle = params.getRectColor();\n            this.getContext().strokeStyle = params.getColor();\n            this.getContext().lineWidth = 0.5 * params.getWidth();\n            this.getContext().fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n        } finally {\n            this.getContext().restore();\n        }\n    };\n\n    /**\n     * Draw character component\n     *\n     * @private\n     * @method drawCharacter\n     * @param {CharacterInputComponent} character\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawCharacter = function (character, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stroke component\n     *\n     * @private\n     * @method drawStroke\n     * @param {Stroke} stroke\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStroke = function (stroke, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (stroke && stroke.getLength() > 0) {\n            if (stroke instanceof scope.StrokeComponent) {\n                _renderStroke(stroke, this.getContext());\n            } else {\n                this.drawStart(stroke.getX()[0], stroke.getY()[0]);\n                for (var i = 0; i < stroke.getLength(); ++i) {\n                    this.drawContinue(stroke.getX()[i], stroke.getY()[i], context, parameters);\n                }\n                this.drawEnd(stroke.getX()[stroke.getLength() - 1], stroke.getY()[stroke.getLength() - 1], context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw stroke components\n     *\n     * @private\n     * @method drawStrokes\n     * @param {Stroke[]} strokes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStrokes = function (strokes, context, parameters) {\n        for (var i = 0; i < strokes.length; i++) {\n            this.drawStroke(strokes[i], context, parameters);\n        }\n    };\n\n    /*******************************************************************************************************************\n     * Algorithm methods to compute rendering\n     ******************************************************************************************************************/\n\n    function _computeLinksPoints(point, angle, width) {\n        var radius = point.p * width;\n        return [{\n            x: (point.x - Math.sin(angle) * radius),\n            y: (point.y + Math.cos(angle) * radius)\n        }, {\n            x: (point.x + Math.sin(angle) * radius),\n            y: (point.y - Math.cos(angle) * radius)\n        }\n        ];\n    }\n\n    function _computeMiddlePoint(point1, point2) {\n        return {\n            x: ((point2.x + point1.x) / 2),\n            y: ((point2.y + point1.y) / 2),\n            p: ((point2.p + point1.p) / 2)\n        };\n    }\n\n    function _computeAxeAngle(begin, end) {\n        return Math.atan2(end.y - begin.y, end.x - begin.x);\n    }\n\n    function _fill(context, color) {\n        if (color !== undefined) {\n            context.fillStyle = color;\n            context.fill();\n        }\n    }\n\n    /**\n     *\n     * @param stroke\n     * @param context\n     * @param parameters\n     * @private\n     */\n    function _renderStroke(stroke, context) {\n        context.beginPath();\n        var length = stroke.getLength();\n        var width = stroke.getWidth();\n        var firstPoint = stroke.getPointByIndex(0);\n        if (length < 3) {\n            context.arc(firstPoint.x, firstPoint.y, width * 0.6, 0, Math.PI * 2, true);\n        } else {\n            context.arc(firstPoint.x, firstPoint.y, width * firstPoint.p, 0, Math.PI * 2, true);\n            _renderLine(context, firstPoint, _computeMiddlePoint(firstPoint, stroke.getPointByIndex(1)), width);\n\n            // Possibility to try this (the start looks better when the ink is large)\n            //var first = _computeMiddlePoint(stroke[0], stroke[1]);\n            //context.arc(first.x, first.y, width * first.p, 0, Math.PI * 2, true);\n\n            var nbquadratics = length - 2;\n            for (var i = 0; i < nbquadratics; i++) {\n                _renderQuadratic(context, _computeMiddlePoint(stroke.getPointByIndex(i), stroke.getPointByIndex(i + 1)), _computeMiddlePoint(stroke.getPointByIndex(i + 1), stroke.getPointByIndex(i + 2)), stroke.getPointByIndex(i + 1), width);\n            }\n            _renderLine(context, _computeMiddlePoint(stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1)), stroke.getPointByIndex(length - 1), width);\n            _renderFinal(context, stroke.getPointByIndex(length - 2), stroke.getPointByIndex(length - 1), width);\n        }\n        context.closePath();\n        _fill(context, stroke.getColor());\n    }\n\n    function _renderFinal(context, begin, end, width) {\n        var ARCSPLIT = 6;\n        var angle = _computeAxeAngle(begin, end);\n        var linkPoints = _computeLinksPoints(end, angle, width);\n        context.moveTo(linkPoints[0].x, linkPoints[0].y);\n        for (var i = 1; i <= ARCSPLIT; i++) {\n            var newAngle = angle - i * Math.PI / ARCSPLIT;\n            context.lineTo(end.x - end.p * width * Math.sin(newAngle), end.y + end.p * width * Math.cos(newAngle));\n        }\n    }\n\n    function _renderLine(context, begin, end, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, end), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.lineTo(linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.lineTo(linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    function _renderQuadratic(context, begin, end, ctrl, width) {\n        var linkPoints1 = _computeLinksPoints(begin, _computeAxeAngle(begin, ctrl), width);\n        var linkPoints2 = _computeLinksPoints(end, _computeAxeAngle(ctrl, end), width);\n        var linkPoints3 = _computeLinksPoints(ctrl, _computeAxeAngle(begin, end), width);\n\n        context.moveTo(linkPoints1[0].x, linkPoints1[0].y);\n        context.quadraticCurveTo(linkPoints3[0].x, linkPoints3[0].y, linkPoints2[0].x, linkPoints2[0].y);\n        context.lineTo(linkPoints2[1].x, linkPoints2[1].y);\n        context.quadraticCurveTo(linkPoints3[1].x, linkPoints3[1].y, linkPoints1[1].x, linkPoints1[1].y);\n    }\n\n    /**\n     * DEPRECATED METHODS\n     */\n\n    /**\n     * Record the beginning of drawing\n     *\n     * @deprecated\n     * @method drawStart\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawStart = function (x, y, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        this.points = [];\n        this.drawing = true;\n        this.points.push(new scope.QuadraticPoint({x: x, y: y}));\n    };\n\n    /**\n     * Record the drawing\n     *\n     * @deprecated\n     * @method drawContinue\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawContinue = function (x, y, context, parameters) {\n        if (this.drawing) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            var params = this.getParameters();\n            var delta = 2 + (params.getWidth() / 4);\n            var last = this.points[this.points.length - 1];\n\n            if (Math.abs(last.getX() - x) >= delta || Math.abs(last.getY() - y) >= delta) {\n\n                if (this.points.length === 1) { // firstPoint\n\n                    var pA = this.points[this.points.length - 1]; // firstPoint\n                    var pB = new scope.QuadraticPoint({x: x, y: y});\n                    var pAB = new scope.QuadraticPoint({\n                        x: 0.5 * (pA.getX() + pB.getX()),\n                        y: 0.5 * (pA.getY() + pB.getY())\n                    });\n                    _computePointParameters(pA, pAB, params.getPressureType());\n                    _computePointParameters(pAB, pB, params.getPressureType());\n\n                    _computeFirstControls(pA, pAB, params.getWidth());\n                    _computeControls(pAB, pB, params.getWidth());\n\n                    this.points.push(pAB);\n                    this.points.push(pB);\n\n                    _drawFirstSegment(pA, pAB, this.getContext(), params);\n\n                } else {\n                    var pAB = this.points[this.points.length - 2]; // jshint ignore:line\n                    var pB = this.points[this.points.length - 1]; // jshint ignore:line\n                    var pC = new scope.QuadraticPoint({x: x, y: y});\n                    var pBC = new scope.QuadraticPoint({\n                        x: 0.5 * (pB.getX() + pC.getX()),\n                        y: 0.5 * (pB.getY() + pC.getY())\n                    });\n                    _computePointParameters(pB, pBC, params.getPressureType());\n                    _computePointParameters(pBC, pC, params.getPressureType());\n\n                    _computeControls(pB, pBC, params.getWidth());\n                    _computeControls(pBC, pC, params.getWidth());\n\n                    this.points.push(pBC);\n                    this.points.push(pC);\n\n                    _drawSegment(pAB, pB, pBC, this.getContext(), params);\n                }\n            }\n        }\n    };\n\n    /**\n     * Stop record of drawing\n     *\n     * @deprecated\n     * @method drawEnd\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AbstractRenderer.prototype.drawEnd = function (x, y, context, parameters) {\n        if (this.drawing) {\n            var params = this.getParameters();\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n\n            if (this.points.length === 1) {\n                _drawPoint(new scope.QuadraticPoint({x: x, y: y}), this.getContext(), params);\n            } else if (this.points.length > 1) {\n                var pA = this.points[this.points.length - 1];\n                var pB = new scope.QuadraticPoint({x: x, y: y});\n                var pAB = new scope.QuadraticPoint({\n                    x: 0.5 * (pA.getX() + pB.getX()),\n                    y: 0.5 * (pA.getY() + pB.getY())\n                });\n                _computePointParameters(pA, pAB, params.getPressureType());\n                _computePointParameters(pAB, pB, params.getPressureType());\n\n                _computeControls(pA, pAB, params.getWidth());\n                _computeLastControls(pB, params.getWidth());\n\n                this.points.push(pAB);\n                this.points.push(pB);\n\n                _drawLastSegment(pAB, pB, this.getContext(), params);\n            }\n            this.drawing = false;\n        }\n    };\n\n    /**\n     * Draw point on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawPoint\n     * @param {QuadraticPoint} point\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawPoint = function (point, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.arc(point.getX(), point.getY(), 0.25 * parameters.getWidth(), 0, 2 * Math.PI);\n            context.fill();\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw the first stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawFirstSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawFirstSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Draw middle stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {QuadraticPoint} pC\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawSegment = function (pA, pB, pC, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.quadraticCurveTo(pB.getP1().getX(), pB.getP1().getY(), pC.getP1().getX(), pC.getP1().getY());\n            context.lineTo(pC.getP2().getX(), pC.getP2().getY());\n            context.quadraticCurveTo(pB.getP2().getX(), pB.getP2().getY(), pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw the last stroke segment on context\n     *\n     * @private\n     * @deprecated\n     * @method _drawLastSegment\n     * @param {QuadraticPoint} pA\n     * @param {QuadraticPoint} pB\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLastSegment = function (pA, pB, context, parameters) {\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.globalAlpha = 1;\n            context.lineWidth = 1;\n\n            context.beginPath();\n            context.moveTo(pA.getP1().getX(), pA.getP1().getY());\n            context.lineTo(pB.getP1().getX(), pB.getP1().getY());\n            context.lineTo(pB.getP2().getX(), pB.getP2().getY());\n            context.lineTo(pA.getP2().getX(), pA.getP2().getY());\n            context.closePath();\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Compute distance and unit vector from the previous point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePointParameters\n     * @param {QuadraticPoint} previous\n     * @param {QuadraticPoint} point\n     * @param {String} pressureType\n     */\n    var _computePointParameters = function (previous, point, pressureType) {\n        var dx = point.getX() - previous.getX(),\n            dy = point.getY() - previous.getY(),\n            d = Math.sqrt((dx * dx) + (dy * dy));\n\n        if (d !== 0) {\n            point.setDistance(d);\n            point.setCos(dx / d);\n            point.setSin(dy / d);\n        }\n        point.setLength(previous.getLength() + point.getDistance());\n\n        switch (pressureType) {\n            case 'SIMULATED':\n                _computePressure(point);\n                break;\n            case 'CONSTANT':\n                point.setPressure(1.0);\n                break;\n            case 'REAL':\n                // keep the current pressure\n                break;\n            default:\n                throw new Error('Unknown pressure type');\n        }\n    };\n\n    /**\n     * Compute simulated pressure of given point.\n     *\n     * @private\n     * @deprecated\n     * @method _computePressure\n     * @param {QuadraticPoint} point\n     */\n    var _computePressure = function (point) {\n        var k, pressure;\n        if (point.getDistance() < 10) {\n            k = 0.2 + Math.pow(0.1 * point.getDistance(), 0.4);\n        } else if (point.getDistance() > point.getLength() - 10) {\n            k = 0.2 + Math.pow(0.1 * (point.getLength() - point.getDistance()), 0.4);\n        } else {\n            k = 1.0;\n        }\n\n        pressure = k * Math.max(0.1, 1.0 - 0.1 * Math.sqrt(point.getDistance()));\n        if (isNaN(parseFloat(pressure))) {\n            pressure = 0.5;\n        }\n        point.setPressure(pressure);\n    };\n\n    /**\n     * Compute control points of the first point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeFirstControls\n     * @param {QuadraticPoint} first First point of the list to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeFirstControls = function (first, next, penWidth) {\n        var r = 0.5 * (penWidth * first.getPressure()),\n            nx = r * next.getSin(),\n            ny = r * next.getCos();\n\n        first.getP1().setX(first.getX() - nx);\n        first.getP1().setY(first.getY() + ny);\n        first.getP2().setX(first.getX() + nx);\n        first.getP2().setY(first.getY() - ny);\n    };\n\n    /**\n     * Compute control points between two points.\n     *\n     * @private\n     * @deprecated\n     * @method _computeControls\n     * @param {QuadraticPoint} point Point to be computed\n     * @param {QuadraticPoint} next Next point\n     * @param {Number} penWidth Pen width\n     */\n    var _computeControls = function (point, next, penWidth) {\n        var cos = point.getCos() + next.getCos(),\n            sin = point.getSin() + next.getSin(),\n            u = Math.sqrt((cos * cos) + (sin * sin));\n\n        if (u !== 0) {\n            // compute control points\n            var r = 0.5 * penWidth * point.getPressure();\n            var nx = -r * sin / u;\n            var ny = r * cos / u;\n            point.getP1().setX(point.getX() + nx);\n            point.getP1().setY(point.getY() + ny);\n            point.getP2().setX(point.getX() - nx);\n            point.getP2().setY(point.getY() - ny);\n        }\n    };\n\n    /**\n     * Compute control points of the last point.\n     *\n     * @private\n     * @deprecated\n     * @method _computeLastControls\n     * @param {QuadraticPoint} last Last point to be computed\n     * @param {Number} penWidth Pen width\n     */\n    var _computeLastControls = function (last, penWidth) {\n        var r = 0.5 * penWidth * last.getPressure(),\n            nx = -r * last.getSin(),\n            ny = r * last.getCos();\n\n        last.getP1().setX(last.getX() + nx);\n        last.getP1().setY(last.getY() + ny);\n        last.getP2().setX(last.getX() - nx);\n        last.getP2().setY(last.getY() - ny);\n    };\n\n    // Export\n    scope.AbstractRenderer = AbstractRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Text Renderer. It's used to calculate the text ink rendering in HTML5 canvas\n     *\n     * @class TextRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function TextRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    TextRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    TextRenderer.prototype.constructor = TextRenderer;\n\n    /**\n     * Draw text recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {TextInputUnit[]} inputUnits\n     * @param {TextDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawRecognitionResult = function (inputUnits, recognitionResult, context, parameters) {\n        this.drawInputUnits(inputUnits, context, parameters);\n    };\n\n    /**\n     * Draw input units\n     *\n     * @method drawInputUnits\n     * @param {TextInputUnit[]} inputUnits\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawInputUnits = function (inputUnits, context, parameters) {\n        for (var i in inputUnits) {\n            this.drawComponents(inputUnits[i].getComponents(), context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractTextInputComponent) {\n                _drawTextComponent(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw text component\n     *\n     * @deprecated\n     * @method drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    TextRenderer.prototype.drawTextComponent = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawTextComponent(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text component\n     *\n     * @private\n     * @method _drawTextComponent\n     * @param {AbstractTextInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextComponent = function (component, context, parameters) {\n        if (component instanceof scope.CharInputComponent) {\n            _drawChar(component, context, parameters);\n        } else if (component instanceof scope.StringInputComponent) {\n            _drawString(component, context, parameters);\n        } else {\n            throw new Error('Component not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw char\n     *\n     * @private\n     * @method _drawChar\n     * @param {CharInputComponent} char\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawChar = function (char, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw string\n     *\n     * @private\n     * @method _drawString\n     * @param {StringInputComponent} string\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawString = function (string, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    // Export\n    scope.TextRenderer = TextRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Shape Renderer. It's used to calculate the shape ink rendering in HTML5 canvas\n     *\n     * @class ShapeRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function ShapeRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    ShapeRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    ShapeRenderer.prototype.constructor = ShapeRenderer;\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {ShapeDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (this.isTypesetting()) {\n            this.drawShapes(components, recognitionResult.getSegments(), context, parameters);\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                _drawShapePrimitive(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw the shapes\n     *\n     * @method drawShapes\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment[]} shapes\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapes = function (components, shapes, context, parameters) {\n        for (var i in shapes) {\n            this.drawShapeSegment(components, shapes[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape segment\n     *\n     * @method drawShapeSegment\n     * @param {AbstractComponent[]} components\n     * @param {ShapeSegment} segment\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeSegment = function (components, segment, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        var candidate = segment.getSelectedCandidate();\n        if (candidate instanceof scope.ShapeRecognized) {\n            _drawShapeRecognized(candidate, this.getContext(), this.getParameters());\n        } else if (candidate instanceof scope.ShapeNotRecognized) {\n            this.drawShapeNotRecognized(components, segment.getInkRanges(), context, parameters);\n        } else {\n            throw new Error('not implemented');\n        }\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @deprecated\n     * @method drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeRecognized(shapeRecognized, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw not recognized shape\n     *\n     * @method drawShapeNotRecognized\n     * @param {AbstractComponent[]} components\n     * @param {ShapeInkRange[]} inkRanges\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeNotRecognized = function (components, inkRanges, context, parameters) {\n        var notRecognized = _extractShapeNotRecognized(components, inkRanges);\n        this.drawComponents(notRecognized, context, parameters);\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @deprecated\n     * @method drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapePrimitive = function (primitive, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapePrimitive(primitive, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @deprecated\n     * @method drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeLine = function (shapeLine, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeLine(shapeLine, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @deprecated\n     * @method drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    ShapeRenderer.prototype.drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawShapeEllipse(shapeEllipse, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * This method allow you to draw recognized shape\n     *\n     * @private\n     * @method _drawShapeRecognized\n     * @param {ShapeRecognized} shapeRecognized\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeRecognized = function (shapeRecognized, context, parameters) {\n        for (var i in shapeRecognized.getPrimitives()) {\n            _drawShapePrimitive(shapeRecognized.getPrimitives()[i], context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape primitive\n     *\n     * @private\n     * @method _drawShapePrimitive\n     * @param {AbstractShapePrimitive} primitive\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapePrimitive = function (primitive, context, parameters) {\n        if (primitive instanceof scope.ShapeEllipse) {\n            _drawShapeEllipse(primitive, context, parameters);\n        } else if (primitive instanceof scope.ShapeLine) {\n            _drawShapeLine(primitive, context, parameters);\n        } else {\n            throw new Error('Primitive not implemented: ' + primitive.getType());\n        }\n    };\n\n    /**\n     * Draw shape line\n     *\n     * @private\n     * @method _drawShapeLine\n     * @param {ShapeLine} shapeLine\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeLine = function (shapeLine, context, parameters) {\n        _drawLine(shapeLine.getFirstPoint(), shapeLine.getLastPoint(), context, parameters);\n        if (shapeLine.hasBeginDecoration() && shapeLine.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getFirstPoint(), shapeLine.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeLine.hasEndDecoration() && shapeLine.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(shapeLine.getLastPoint(), shapeLine.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Draw shape ellipse\n     *\n     * @private\n     * @method _drawShapeEllipse\n     * @param {ShapeEllipse} shapeEllipse\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawShapeEllipse = function (shapeEllipse, context, parameters) {\n        var points = _drawEllipseArc(\n            shapeEllipse.getCenter(),\n            shapeEllipse.getMaxRadius(),\n            shapeEllipse.getMinRadius(),\n            shapeEllipse.getOrientation(),\n            shapeEllipse.getStartAngle(),\n            shapeEllipse.getSweepAngle(),\n            context, parameters);\n\n        if (shapeEllipse.hasBeginDecoration() && shapeEllipse.getBeginDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[0], shapeEllipse.getBeginTangentAngle(), 12.0, context, parameters);\n        }\n        if (shapeEllipse.hasEndDecoration() && shapeEllipse.getEndDecoration() === 'ARROW_HEAD') {\n            _drawArrowHead(points[1], shapeEllipse.getEndTangentAngle(), 12.0, context, parameters);\n        }\n    };\n\n    /**\n     * Get strokes from shape inkRange\n     *\n     * @deprecated\n     * @method extractStroke\n     * @param {Stroke[]} strokes\n     * @param {ShapeInkRange} inkRange\n     * @result {Stroke[]} List of strokes from inkRange\n     */\n    ShapeRenderer.prototype.extractStroke = function (strokes, inkRange) {\n        return _extractShapeNotRecognized(strokes, inkRange);\n    };\n\n    /**\n     * Draw an ellipse arc on context\n     *\n     * @private\n     * @method _drawEllipseArc\n     * @param {Point} centerPoint\n     * @param {Number} maxRadius\n     * @param {Number} minRadius\n     * @param {String} orientation\n     * @param {Number} startAngle\n     * @param {Number} sweepAngle\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     * @returns {Point[]}\n     */\n    var _drawEllipseArc = function (centerPoint, maxRadius, minRadius, orientation, startAngle, sweepAngle, context, parameters) {\n\n        var angleStep = 0.02; // angle delta between interpolated\n\n        var z1 = Math.cos(orientation);\n        var z3 = Math.sin(orientation);\n        var z2 = z1;\n        var z4 = z3;\n        z1 *= maxRadius;\n        z2 *= minRadius;\n        z3 *= maxRadius;\n        z4 *= minRadius;\n\n        var n = Math.floor(Math.abs(sweepAngle) / angleStep);\n\n        var boundariesPoints = [];\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n\n            for (var i = 0; i <= n; i++) {\n\n                var angle = startAngle + (i / n) * sweepAngle; // points on the arc, in radian\n                var alpha = Math.atan2(Math.sin(angle) / minRadius, Math.cos(angle) / maxRadius);\n\n                var cosAlpha = Math.cos(alpha);\n                var sinAlpha = Math.sin(alpha);\n\n                // current point\n                var x = centerPoint.x + z1 * cosAlpha - z4 * sinAlpha;\n                var y = centerPoint.y + z2 * sinAlpha + z3 * cosAlpha;\n                if (i === 0) {\n                    context.moveTo(x, y);\n                } else {\n                    context.lineTo(x, y);\n                }\n\n                if (i === 0 || i === n) {\n                    boundariesPoints.push(new scope.Point({x: x, y: y}));\n                }\n            }\n\n            context.stroke();\n\n        } finally {\n            context.restore();\n        }\n\n        return boundariesPoints;\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Clamp an angle into the range [-PI, +PI]\n     *\n     * @private\n     * @method _phi\n     * @param {Number} angle\n     * @returns {Number}\n     */\n    var _phi = function (angle) {\n        angle = ((angle + Math.PI) % (Math.PI * 2)) - Math.PI;\n        if (angle < -Math.PI) {\n            angle += Math.PI * 2;\n        }\n        return angle;\n    };\n\n    /**\n     * Draw an arrow head on context\n     *\n     * @private\n     * @method _drawArrowHead\n     * @param {Point} headPoint\n     * @param {Number} angle\n     * @param {Number} length\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters\n     */\n    var _drawArrowHead = function (headPoint, angle, length, context, parameters) {\n        var alpha = _phi(angle + Math.PI - (Math.PI / 8)),\n            beta = _phi(angle - Math.PI + (Math.PI / 8));\n\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.moveTo(headPoint.getX(), headPoint.getY());\n            context.beginPath();\n            context.lineTo(headPoint.getX() + (length * Math.cos(alpha)), headPoint.getY() + (length * Math.sin(alpha)));\n            context.lineTo(headPoint.getX() + (length * Math.cos(beta)), headPoint.getY() + (length * Math.sin(beta)));\n            context.lineTo(headPoint.getX(), headPoint.getY());\n            context.fill();\n\n        } finally {\n            context.restore();\n        }\n\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param inkRanges\n     * @returns {*}\n     */\n    var _extractShapeNotRecognized = function (components, inkRanges) {\n        var result = [];\n\n        for (var i in inkRanges) {\n            var inkRange = inkRanges[i];\n\n            var firstPointIndex = Math.floor(inkRange.getFirstPoint());\n            var lastPointIndex = Math.ceil(inkRange.getLastPoint());\n\n            for (var strokeIndex = inkRange.getFirstStroke(); strokeIndex <= inkRange.getLastStroke(); strokeIndex++) {\n                var currentStroke = components[strokeIndex - 1];\n                var currentStrokePointCount = currentStroke.getX().length;\n\n                var newStroke = new scope.Stroke(), x = [], y = [];\n\n                for (var pointIndex = firstPointIndex; (strokeIndex === inkRange.getLastStroke() && pointIndex <= lastPointIndex && pointIndex < currentStrokePointCount) || (strokeIndex !== inkRange.getLastStroke() && pointIndex < currentStrokePointCount); pointIndex++) {\n                    x.push(currentStroke.getX()[pointIndex]);\n                    y.push(currentStroke.getY()[pointIndex]);\n                }\n\n                newStroke.setX(x);\n                newStroke.setY(y);\n                result.push(newStroke);\n            }\n        }\n        return result;\n\n    };\n\n    // Export\n    scope.ShapeRenderer = ShapeRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Math Renderer. It's used to calculate the math ink rendering in HTML5 canvas\n     *\n     * @class MathRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MathRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MathRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MathRenderer.prototype.constructor = MathRenderer;\n\n    /**\n     * Draw math recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MathDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMathScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MathRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MathScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MathRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMathScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMathScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            for (var n in scratchOutResults[k].getErasedInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getErasedInkRanges()[n].getComponent());\n            }\n            for (var p in scratchOutResults[k].getInkRanges()) {\n                componentsToRemove.push(scratchOutResults[k].getInkRanges()[p].getComponent());\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MathRenderer = MathRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Music Renderer. It's used to calculate the music ink rendering in HTML5 canvas\n     *\n     * @class MusicRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function MusicRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    MusicRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    MusicRenderer.prototype.constructor = MusicRenderer;\n\n    /**\n     * Draw music recognition result on HTML5 canvas. Scratch out results are use to redraw HTML5 Canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {MusicDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        var notScratchOutComponents = _removeMusicScratchOut(components, recognitionResult.getScratchOutResults());\n        this.drawComponents(notScratchOutComponents, context, parameters);\n    };\n\n    /**\n     * Remove scratch out from input components\n     *\n     * @deprecated\n     * @param {AbstractComponent[]} components\n     * @param {MusicScratchOut[]} scratchOutResults\n     * @returns {AbstractComponent[]} notScratchOutComponents\n     */\n    MusicRenderer.prototype.removeScratchOut = function (components, scratchOutResults) {\n        return _removeMusicScratchOut(components, scratchOutResults);\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @method drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawStaff = function (staff, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawStaff(staff, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawComponents = function (components, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractMusicInputComponent) {\n                _drawMusicNode(component, this.getContext(), this.getParameters());\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw music node\n     *\n     * @method drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    MusicRenderer.prototype.drawMusicNode = function (component, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawMusicNode(component, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw staff on the HTML5 canvas\n     *\n     * @private\n     * @method _drawStaff\n     * @param {MusicStaff} staff\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawStaff = function (staff, context, parameters) {\n        var staffHeight = staff.getTop() + ((staff.getCount() - 1) * staff.getGap());\n//            var staves = Math.floor(context.canvas.clientHeight / staff.height);\n        var staves = 1;\n\n        context.beginPath();\n\n        // Drawing horizontal staff lines\n        for (var i = 0; i < staves; i++) {\n            var offset = staffHeight * i;\n            for (var j = 0; j < staff.getCount(); j++) {\n                context.moveTo(0, (staff.getTop() + offset) + j * staff.getGap());\n                context.lineTo(context.canvas.clientWidth, (staff.getTop() + offset) + j * staff.getGap());\n            }\n        }\n\n        context.stroke();\n    };\n\n    /**\n     * Draw music node\n     *\n     * @private\n     * @method _drawMusicNode\n     * @param {AbstractMusicInputComponent} component\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawMusicNode = function (component, context, parameters) {\n        if (component instanceof scope.MusicAccidentalInputComponent) {\n            _drawAccidental(component, context, parameters);\n        } else if (component instanceof scope.MusicArpeggiateInputComponent) {\n            _drawArpeggiate(component, context, parameters);\n        } else if (component instanceof scope.MusicBarInputComponent) {\n            _drawBar(component, context, parameters);\n        } else if (component instanceof scope.MusicBeamInputComponent) {\n            _drawBeam(component, context, parameters);\n        } else if (component instanceof scope.MusicClefInputComponent) {\n            _drawClef(component, context, parameters);\n        } else if (component instanceof scope.MusicDecorationInputComponent) {\n            _drawDecoration(component, context, parameters);\n        } else if (component instanceof scope.MusicDotsInputComponent) {\n            _drawDots(component, context, parameters);\n        } else if (component instanceof scope.MusicHeadInputComponent) {\n            _drawHead(component, context, parameters);\n        } else if (component instanceof scope.MusicLedgerLineInputComponent) {\n            _drawLedgerLine(component, context, parameters);\n        } else if (component instanceof scope.MusicRestInputComponent) {\n            _drawRest(component, context, parameters);\n        } else if (component instanceof scope.MusicStemInputComponent) {\n            _drawStem(component, context, parameters);\n        } else if (component instanceof scope.MusicTieOrSlurInputComponent) {\n            _drawTieOrSlur(component, context, parameters);\n        } else if (component instanceof scope.MusicTimeSignatureInputComponent) {\n            _drawTimeSignature(component, context, parameters);\n        } else {\n            throw new Error('Node not implemented: ' + component.getType());\n        }\n    };\n\n    /**\n     * Draw accidental\n     *\n     * @private\n     * @method _drawAccidental\n     * @param {MusicAccidentalInputComponent} accidental\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawAccidental = function (accidental, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw arpeggiate\n     *\n     * @private\n     * @method _drawArpeggiate\n     * @param {MusicArpeggiateInputComponent} arpeggiate\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawArpeggiate = function (arpeggiate, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw bar\n     *\n     * @private\n     * @method _drawBar\n     * @param {MusicBarInputComponent} bar\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBar = function (bar, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw beam\n     *\n     * @private\n     * @method _drawBeam\n     * @param {MusicBeamInputComponent} beam\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawBeam = function (beam, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw clef\n     *\n     * @private\n     * @method _drawClef\n     * @param {MusicClefInputComponent} clef\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawClef = function (clef, context, parameters) { // jshint ignore:line\n        var src = 'data:image/svg+xml,';\n        switch (clef.getValue().getSymbol()) {\n            case 'F':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" x=\"0\" y=\"0\" width=\"18\" height=\"20\"><defs/><g transform=\"translate(6.600000e-3,3.125356e-3)\"><g><path d=\"M17.3 3.1 C17.3 3.5 17.1 3.8 16.8 4.1 C16.5 4.4 15.9 4.5 15.5 4.3 C15 4.1 14.7 3.7 14.7 3.2 C14.6 2.8 14.8 2.5 15 2.2 C15.3 1.9 15.7 1.8 16 1.8 C16.4 1.8 16.8 2 17 2.3 C17.2 2.5 17.3 2.8 17.3 3.1 z\"/></g><g><path d=\"M17.3 8.9 C17.3 9.3 17.1 9.7 16.8 9.9 C16.5 10.3 15.9 10.3 15.5 10.2 C15 10 14.7 9.5 14.7 9.1 C14.6 8.7 14.8 8.3 15 8 C15.3 7.8 15.7 7.6 16 7.6 C16.5 7.7 17 8 17.2 8.4 C17.2 8.6 17.3 8.8 17.3 8.9 z\"/></g><g><path d=\"M13 7.2 C13 10 11.8 12.7 9.8 14.7 C7.3 17.2 4 18.8 0.7 19.8 C0.3 20.1 -0.4 19.8 0.3 19.4 C1.6 18.8 3 18.3 4.2 17.5 C7 15.8 9.3 13.1 9.8 9.9 C10.1 8 10.1 5.9 9.6 4 C9.2 2.6 8.2 1.1 6.7 0.9 C5.3 0.7 3.7 1.2 2.7 2.2 C2.5 2.4 2 3.2 2 4 C2.6 3.6 2.6 3.6 3.1 3.4 C4.2 2.9 5.7 3.6 6 4.9 C6.3 6 6.1 7.5 5 8.1 C3.8 8.7 2 8.5 1.4 7.2 C0.3 5.3 0.9 2.6 2.6 1.2 C4.4 -0.3 7.1 -0.3 9.2 0.4 C11.4 1.3 12.7 3.5 12.9 5.8 C13 6.2 13 6.7 13 7.2 z\"/></g></g></svg>';\n                break;\n            case 'C':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"18\" height=\"25\"><defs/><g><g transform=\"matrix(1,0,0,1.030698,-309.364,-543.8647)\"><path d=\"M 325.9 546.8 C 325.8 548.7 324.7 550.7 322.8 551.5 C 321.1 552.1 319.1 552.2 317.6 551 C 316.6 550.2 316.2 548.4 317.3 547.5 C 318.3 546.5 320.4 547.4 320.3 548.9 C 320.7 549.9 318.5 550.5 319.7 551.3 C 321 551.6 322.3 550.5 322.6 549.3 C 323.1 547.5 323.1 545.6 322.7 543.8 C 322.4 542.9 321.9 541.5 320.7 541.9 C 319.2 542.2 318.3 543.8 317.9 545.1 C 317.6 543.2 316.4 541.5 315 540.2 C 315 544.1 315 548 315 551.9 L 314.1 551.9 C 314.1 543.9 314.1 535.7 314.1 527.7 L 315 527.7 C 315 531.5 315 535.5 315 539.4 C 316.4 538.1 317.6 536.4 317.8 534.5 C 318.3 535.9 319.3 537.5 321 537.8 C 322.2 537.8 322.5 536.3 322.8 535.4 C 323.1 533.7 323.1 531.8 322.6 530.1 C 322.2 529 320.9 528 319.6 528.3 C 318.6 529 320.6 529.6 320.3 530.6 C 320.5 532 318.8 533 317.6 532.3 C 316.3 531.6 316.4 529.7 317.4 528.8 C 318 528.1 319.3 527.7 320.3 527.7 C 321.2 527.7 321.8 527.7 322.6 528 C 324.6 528.7 325.7 530.7 325.9 532.7 C 326.2 534.9 324.9 537.3 322.8 538.2 C 321.5 538.7 319.9 538.3 318.8 537.3 C 318.7 538.3 318.2 539.2 317.7 539.9 C 318.1 540.6 318.6 541.8 318.8 542.1 C 320.1 540.9 322.5 540.8 323.8 542 C 325.2 543.1 326.1 545 325.9 546.8 z \"/></g><g transform=\"matrix(1,0,0,1.030928,-309.364,-543.9805)\"><path d=\"M 312.2 551.9 L 309.4 551.9 L 309.4 527.7 L 312.2 527.7 L 312.2 551.9 z \"/></g></g></svg>';\n                break;\n            case 'G':\n                src = src + '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" width=\"15\" height=\"40\"><defs/><path d=\"m 12 3.4 c 0.3 3.1 -2 5.6 -4.1 7.6 -0.9 0.9 -0.2 0.1 -0.6 0.6 -0.1 -0.5 -0.3 -1.7 -0.3 -2.1 0.1 -2.6 2.3 -6.5 4.2 -7.9 0.3 0.6 0.6 0.6 0.8 1.8 z m 0.7 15.9 c -1.2 -0.9 -2.8 -1.1 -4.3 -0.9 -0.2 -1.2 -0.4 -2.5 -0.6 -3.7 2.4 -2.3 4.9 -4.9 5 -8.4 0.1 -2.2 -0.3 -4.6 -1.7 -6.4 C 9.5 0.1 8.3 2.1 7.4 3.3 c -1.5 2.6 -1.1 5.8 -0.6 8.6 -0.8 0.9 -1.9 1.7 -2.7 2.7 -2.4 2.3 -4.4 5.3 -4 8.7 0.2 3.3 2.6 6.3 5.9 7.1 1.2 0.3 2.6 0.3 3.8 0.1 0.2 2.2 1 4.5 0.1 6.7 -0.7 1.6 -2.8 2.9 -4.3 2.2 -0.6 -0.3 -0.1 -0.1 -0.5 -0.2 1.1 -0.3 2 -1 2.3 -1.5 0.8 -1.4 -0.4 -3.6 -2.2 -3.3 -2.3 0 -3.2 3.1 -1.7 4.6 1.3 1.5 3.8 1.3 5.4 0.3 1.8 -1.2 2 -3.5 1.8 -5.5 -0.1 -0.7 -0.4 -2.6 -0.4 -3.3 0.7 -0.2 0.2 -0.1 1.2 -0.4 2.7 -1 4.4 -4.2 3.6 -7 -0.3 -1.4 -1 -2.9 -2.3 -3.7 z m 0.6 5.7 c 0.2 2 -1.1 4.2 -3.1 4.9 -0.1 -0.8 -0.2 -1 -0.3 -1.4 -0.5 -2.4 -0.7 -4.9 -1.1 -7.3 1.6 -0.2 3.5 0.5 4 2.1 0.2 0.6 0.3 1.2 0.4 1.8 z m -5.1 5.1 c -2.5 0.1 -5 -1.6 -5.6 -4 -0.7 -2.1 -0.5 -4.5 0.8 -6.4 1.1 -1.7 2.6 -3 4 -4.5 0.2 1.1 0.4 2.2 0.5 3.3 -3 0.8 -5 4.6 -3.2 7.3 0.5 0.8 2 2.2 2.8 1.6 -1.1 -0.7 -2 -1.8 -1.8 -3.2 -0.1 -1.3 1.4 -2.9 2.7 -3.1 0.4 2.8 0.9 6 1.4 8.8 -0.5 0.1 -1 0.1 -1.5 0.1 z\"/></svg>';\n                break;\n            default:\n                throw new Error('Unknown music clef symbol');\n        }\n\n        var imageObj = new Image();\n        imageObj.onload = function () {\n            var ratio = clef.getBoundingBox().getHeight() / this.height;\n            clef.getBoundingBox().setWidth(this.width * ratio);\n            context.drawImage(imageObj, clef.getBoundingBox().getX(), clef.getBoundingBox().getY(), clef.getBoundingBox().getWidth(), clef.getBoundingBox().getHeight());\n        };\n        imageObj.src = src;\n    };\n\n    /**\n     * Draw decoration\n     *\n     * @private\n     * @method _drawDecoration\n     * @param {MusicDecorationInputComponent} decoration\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDecoration = function (decoration, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw dots\n     *\n     * @private\n     * @method _drawDots\n     * @param {MusicDotsInputComponent} dots\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawDots = function (dots, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw head\n     *\n     * @private\n     * @method _drawHead\n     * @param {MusicHeadInputComponent} head\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawHead = function (head, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw ledgerLine\n     *\n     * @private\n     * @method _drawLedgerLine\n     * @param {MusicLedgerLineInputComponent} ledgerLine\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawLedgerLine = function (ledgerLine, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw rest\n     *\n     * @private\n     * @method _drawRest\n     * @param {MusicRestInputComponent} rest\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawRest = function (rest, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw stem\n     *\n     * @private\n     * @method _drawStem\n     * @param {MusicStemInputComponent} stem\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawStem = function (stem, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw tieOrSlur\n     *\n     * @private\n     * @method _drawTieOrSlur\n     * @param {MusicTieOrSlurInputComponent} tieOrSlur\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTieOrSlur = function (tieOrSlur, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Draw timeSignature\n     *\n     * @private\n     * @method _drawTimeSignature\n     * @param {MusicTimeSignatureInputComponent} timeSignature\n     * @param {Object} context The canvas 2d context\n     * @param {PenParameters} parameters Rendering parameters\n     */\n    var _drawTimeSignature = function (timeSignature, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n    /**\n     * Return non-scratched out components\n     *\n     * @private\n     * @param components\n     * @param scratchOutResults\n     * @returns {*}\n     */\n    var _removeMusicScratchOut = function (components, scratchOutResults) {\n        if (!scratchOutResults || scratchOutResults.length === 0) {\n            return components;\n        }\n\n        var cloneComponents = components.slice(0);\n        var componentsToRemove = [];\n\n        for (var k in scratchOutResults) {\n            if (scratchOutResults[k].getErasedInputRanges()) {\n                for (var n in scratchOutResults[k].getErasedInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getErasedInputRanges()[n].getComponent());\n                }\n                for (var p in scratchOutResults[k].getInputRanges()) {\n                    componentsToRemove.push(scratchOutResults[k].getInputRanges()[p].getComponent());\n                }\n            }\n        }\n\n        componentsToRemove.sort(function (a, b) {\n            return b - a;\n        });\n\n        for (var z in componentsToRemove) {\n            cloneComponents.splice(componentsToRemove[z], 1);\n        }\n        return cloneComponents;\n    };\n\n    // Export\n    scope.MusicRenderer = MusicRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * Represent the Analyzer Renderer. It's used to calculate the analyzer ink rendering in HTML5 canvas\n     *\n     * @class AnalyzerRenderer\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function AnalyzerRenderer(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.shapeRenderer = new scope.ShapeRenderer(context);\n    }\n\n    /**\n     * Inheritance property\n     */\n    AnalyzerRenderer.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    AnalyzerRenderer.prototype.constructor = AnalyzerRenderer;\n\n    /**\n     * Get shape renderer\n     *\n     * @method getShapeRenderer\n     * @returns {ShapeRenderer}\n     */\n    AnalyzerRenderer.prototype.getShapeRenderer = function () {\n        return this.shapeRenderer;\n    };\n\n    /**\n     * Set shape renderer\n     *\n     * @method setShapeRenderer\n     * @param {ShapeRenderer} shapeRenderer\n     */\n    AnalyzerRenderer.prototype.setShapeRenderer = function (shapeRenderer) {\n        this.shapeRenderer = shapeRenderer;\n    };\n\n    /**\n     * Draw shape recognition result on HTML5 canvas\n     *\n     * @method drawRecognitionResult\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerDocument} recognitionResult\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawRecognitionResult = function (components, recognitionResult, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        if (this.isTypesetting()) {\n            this.shapeRenderer.drawShapes(components, recognitionResult.getShapes(), context, parameters);\n            _drawTables(components, recognitionResult.getTables(), this.getContext(), this.getParameters());\n            _drawTextLines(components, recognitionResult.getTextLines(), this.getContext(), this.getParameters());\n            //_drawGroups(components, recognitionResult.getGroups(), this.getContext(), this.getParameters()); // TODO: not implemented\n        } else {\n            this.drawComponents(components, context, parameters);\n        }\n    };\n\n    /**\n     * Draw components\n     *\n     * @method drawComponents\n     * @param {AbstractComponent[]} components\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawComponents = function (components, context, parameters) {\n        for (var i in components) {\n            var component = components[i];\n            if (component instanceof scope.AbstractShapePrimitive) {\n                this.shapeRenderer.drawShapePrimitive(component, context, parameters);\n            } else if (component instanceof scope.AbstractComponent) {\n                scope.AbstractRenderer.prototype.drawComponent.call(this, component, context, parameters); // super\n            } else {\n                throw new Error('not implemented');\n            }\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @deprecated\n     * @method drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTables = function (components, tables, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in tables) {\n            if (this.getShowBoundingBoxes()) {\n                for (var j in tables[i].getCells()) {\n                    _drawCell(tables[i].getCells()[j], this.getContext(), this.getParameters());\n                }\n            }\n        }\n        _drawTables(components, tables, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @deprecated\n     * @method drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawTextLines = function (components, textLines, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data && this.getShowBoundingBoxes()) {\n                this.drawRectangle(data.getBoundingBox(), context, parameters);\n            }\n        }\n        _drawTextLines(components, textLines, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @deprecated\n     * @method drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawText(boundingBox, text, justificationType, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Underline\n     *\n     * @deprecated\n     * @method drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        if (context) {\n            this._setContext(context);\n        }\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        _drawUnderline(boundingBox, underline, text, textHeight, baseline, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @deprecated\n     * @method drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        _drawGroups(components, groups, this.getContext(), this.getParameters());\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @deprecated\n     * @method drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} [context] DEPRECATED, use renderer constructor instead\n     * @param {PenParameters} [parameters] DEPRECATED, use setParameters instead\n     */\n    AnalyzerRenderer.prototype.drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            if (context) {\n                this._setContext(context);\n            }\n            if (parameters) {\n                this.setParameters(parameters);\n            }\n            _drawCell(cell, this.getContext(), this.getParameters());\n        }\n    };\n\n    /**\n     * Draw table\n     *\n     * @private\n     * @method _drawTables\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTable[]} tables\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTables = function (components, tables, context, parameters) {\n        for (var i in tables) {\n            for (var k in tables[i].getLines()) {\n                var data = tables[i].getLines()[k].getData();\n                _drawLine(data.getP1(), data.getP2(), context, parameters);\n            }\n        }\n    };\n\n    /**\n     * Draw the text line\n     *\n     * @private\n     * @method _drawTextLines\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerTextLine[]} textLines\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawTextLines = function (components, textLines, context, parameters) {\n        for (var i in textLines) {\n            var textLine = textLines[i];\n            var data = textLine.getData();\n            if (data) {\n                var text = textLine.getTextDocument().getTextSegment().getSelectedCandidate().getLabel();\n                _drawText(data.getBoundingBox(), text, data.getJustificationType(), data.getTextHeight(), data.getBaselinePos(), context, parameters);\n\n                var underlines = textLine.getUnderlineList();\n                for (var j in underlines) {\n                    _drawUnderline(data.getBoundingBox(), underlines[j], text, data.getTextHeight(), data.getBaselinePos() + data.getTextHeight() / 10, context, parameters);\n                }\n            }\n        }\n    };\n\n    /**\n     * Draw text on analyser\n     *\n     * @private\n     * @method _drawText\n     * @param {Rectangle} boundingBox\n     * @param {String} text\n     * @param {String} justificationType\n     * @param {Number} textHeight\n     * @param {Number} baseline\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawText = function (boundingBox, text, justificationType, textHeight, baseline, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n            context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n            context.textAlign = (justificationType === 'CENTER') ? 'center' : 'left';\n\n            context.fillText(text, boundingBox.getX(), baseline);\n\n        } finally {\n            context.restore();\n        }\n    };\n\n    /**\n     * Draw Groups\n     *\n     * @private\n     * @method _drawGroups\n     * @param {AbstractComponent[]} components\n     * @param {AnalyzerGroup[]} groups\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawGroups = function (components, groups, context, parameters) { // jshint ignore:line\n        throw new Error('not implemented');\n    };\n\n\n    /**\n     * Draw Underline\n     *\n     * @private\n     * @method _drawUnderline\n     * @param {Rectangle} boundingBox\n     * @param {AnalyzerUnderline} underline\n     * @param {String} text\n     * @param {Number} textHeight\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawUnderline = function (boundingBox, underline, text, textHeight, baseline, context, parameters) {\n        var topLeft = boundingBox.getTopLeftPoint();\n        var firstCharacter = underline.getData().getFirstCharacter();\n        var lastCharacter = underline.getData().getLastCharacter();\n\n        context.font = parameters.getDecoration() + ' ' + textHeight + 'px' + ' ' + parameters.getFont();\n\n        var textMetrics = context.measureText(text.substring(0, firstCharacter));\n        var x1 = topLeft.x + textMetrics.width;\n\n        textMetrics = context.measureText(text.substring(firstCharacter, lastCharacter + 1));\n        var x2 = x1 + textMetrics.width;\n        _drawLine(new scope.Point({x: x1, y: baseline}), new scope.Point({x: x2, y: baseline}), context, parameters);\n    };\n\n    /**\n     * Draw a cell\n     *\n     * @private\n     * @method _drawCell\n     * @param {AnalyzerCell} cell\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawCell = function (cell, context, parameters) {\n        if (cell.getData()) {\n            var rectangle = cell.getData().getBoundingBox();\n            context.save();\n            try {\n                context.fillStyle = parameters.getRectColor();\n                context.strokeStyle = parameters.getColor();\n                context.lineWidth = 0.5 * parameters.getWidth();\n                context.fillRect(rectangle.getX(), rectangle.getY(), rectangle.getWidth(), rectangle.getHeight());\n            } finally {\n                context.restore();\n            }\n        }\n    };\n\n    /**\n     * Draw a line on context\n     *\n     * @private\n     * @method _drawLine\n     * @param {Point} p1\n     * @param {Point} p2\n     * @param {Object} context\n     * @param {PenParameters} parameters\n     */\n    var _drawLine = function (p1, p2, context, parameters) {\n        context.save();\n        try {\n            context.fillStyle = parameters.getColor();\n            context.strokeStyle = parameters.getColor();\n            context.lineWidth = 0.5 * parameters.getWidth();\n\n            context.beginPath();\n            context.moveTo(p1.getX(), p1.getY());\n            context.lineTo(p2.getX(), p2.getY());\n            context.stroke();\n        } finally {\n            context.restore();\n        }\n    };\n\n    // Export\n    scope.AnalyzerRenderer = AnalyzerRenderer;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * The InkGrabber class that render, capture and build strokes\n     *\n     * @class InkGrabber\n     * @extends AbstractRenderer\n     * @param {Object} context\n     * @constructor\n     */\n    function InkGrabber(context) {\n        scope.AbstractRenderer.call(this, context);\n        this.stroke = undefined;\n        this.writing = false;\n    }\n\n    /**\n     * Inheritance property\n     */\n    InkGrabber.prototype = new scope.AbstractRenderer();\n\n    /**\n     * Constructor property\n     */\n    InkGrabber.prototype.constructor = InkGrabber;\n\n    /**\n     * Is Writing a stroke\n     *\n     * @method isWriting\n     * @returns {Boolean}\n     */\n    InkGrabber.prototype.isWriting = function () {\n        return this.writing;\n    };\n\n    /**\n     * Get the last wrote stroke\n     *\n     * @method getStroke\n     * @returns {StrokeComponent}\n     */\n    InkGrabber.prototype.getStroke = function () {\n        return this.stroke;\n    };\n\n    InkGrabber.prototype.startCapture = function (x, y, t) {\n        if (!this.writing) {\n            this.writing = true;\n            this.stroke = new scope.StrokeComponent();\n            this.stroke.setColor(this.penParameters.getColor());\n            this.stroke.setWidth(this.penParameters.getWidth());\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('StrokeComponent capture already running');\n        }\n    };\n\n    InkGrabber.prototype.continueCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    InkGrabber.prototype.endCapture = function (x, y, t) {\n        if (this.writing) {\n            this.stroke.addPoint(x, y, t);\n            this.clear();\n            this.drawStroke(this.stroke);\n            this.writing = false;\n        } else {\n            throw new Error('Missing startInkCapture');\n        }\n    };\n\n    // Export\n    scope.InkGrabber = InkGrabber;\n})(MyScript);\n","'use strict';\n\n(function (scope) {\n    /**\n     * InkPaper\n     *\n     * @class InkPaper\n     * @param {Element} element\n     * @param {Object} [options]\n     * @param {Function} [callback] callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     * @constructor\n     */\n    function InkPaper(element, options, callback) {\n        this._element = element;\n        this._instanceId = undefined;\n        this._timerId = undefined;\n        this._initialized = false;\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this.resultCallback = callback;\n        this.changeCallback = undefined;\n        this.options = { // Default options\n            type: scope.RecognitionType.TEXT,\n            protocol: scope.Protocol.REST,\n            width: 400,\n            height: 300,\n            timeout: 2000,\n            typeset: false,\n            components: [],\n            textParameters: new scope.TextParameter(),\n            mathParameters: new scope.MathParameter(),\n            shapeParameters: new scope.ShapeParameter(),\n            musicParameters: new scope.MusicParameter(),\n            analyzerParameters: new scope.AnalyzerParameter()\n        };\n\n        // Capture\n        this._captureCanvas = _createCanvas(element, 'ms-capture-canvas');\n        this._inkGrabber = new scope.InkGrabber(this._captureCanvas.getContext('2d'));\n\n        // Rendering\n        this._renderingCanvas = _createCanvas(element, 'ms-rendering-canvas');\n\n        this._textRenderer = new scope.TextRenderer(this._renderingCanvas.getContext('2d'));\n        this._mathRenderer = new scope.MathRenderer(this._renderingCanvas.getContext('2d'));\n        this._shapeRenderer = new scope.ShapeRenderer(this._renderingCanvas.getContext('2d'));\n        this._musicRenderer = new scope.MusicRenderer(this._renderingCanvas.getContext('2d'));\n        this._analyzerRenderer = new scope.AnalyzerRenderer(this._renderingCanvas.getContext('2d'));\n\n        // Recognition\n        this._textRecognizer = new scope.TextRecognizer(options? options.host : undefined);\n        this._mathRecognizer = new scope.MathRecognizer(options? options.host : undefined);\n        this._shapeRecognizer = new scope.ShapeRecognizer(options? options.host : undefined);\n        this._musicRecognizer = new scope.MusicRecognizer(options? options.host : undefined);\n        this._analyzerRecognizer = new scope.AnalyzerRecognizer(options? options.host : undefined);\n\n        this._textWSRecognizer = new scope.TextWSRecognizer(this._handleMessage.bind(this), options? options.host : undefined);\n        this._mathWSRecognizer = new scope.MathWSRecognizer(this._handleMessage.bind(this), options? options.host : undefined);\n\n        this._attachListeners(element);\n\n        if (options) {\n            for (var idx in options) {\n                if (options[idx] !== undefined) {\n                    this.options[idx] = options[idx]; // Override current options\n                }\n            }\n        }\n\n        this._initialize(this._getOptions());\n    }\n\n    /**\n     * Set the width\n     *\n     * @method setWidth\n     * @param {Number} width\n     */\n    InkPaper.prototype.setWidth = function (width) {\n        this._captureCanvas.width = width;\n        this._renderingCanvas.width = width;\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the height\n     *\n     * @method setHeight\n     * @param {Number} height\n     */\n    InkPaper.prototype.setHeight = function (height) {\n        this._captureCanvas.height = height;\n        this._renderingCanvas.height = height;\n        this._initRenderingCanvas();\n    };\n\n    /**\n     * Set the network protocol (REST or WebSocket)\n     *\n     * @param {'REST'|'WebSocket'} protocol\n     */\n    InkPaper.prototype.setProtocol = function (protocol) {\n        switch (protocol) {\n            case scope.Protocol.REST:\n                this._selectedRecognizer = this._selectedRESTRecognizer;\n                break;\n            case scope.Protocol.WS:\n                this.setTimeout(-1); // FIXME hack to avoid border issues\n                this._selectedRecognizer = this._selectedWSRecognizer;\n                break;\n            default:\n                throw new Error('Unknown protocol: ' + protocol);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get the network protocol (REST or WebSocket)\n     *\n     * @returns {'REST'|'WebSocket'}\n     */\n    InkPaper.prototype.getProtocol = function () {\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            return scope.Protocol.WS;\n        } else {\n            return scope.Protocol.REST;\n        }\n    };\n\n    /**\n     * Set recognition type\n     *\n     * @method setType\n     * @param {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.setType = function (type) {\n        switch (type) {\n            case scope.RecognitionType.TEXT:\n                this._selectedRenderer = this._textRenderer;\n                this._selectedRESTRecognizer = this._textRecognizer;\n                this._selectedWSRecognizer = this._textWSRecognizer;\n                break;\n            case scope.RecognitionType.MATH:\n                this._selectedRenderer = this._mathRenderer;\n                this._selectedRESTRecognizer = this._mathRecognizer;\n                this._selectedWSRecognizer = this._mathWSRecognizer;\n                break;\n            case scope.RecognitionType.SHAPE:\n                this._selectedRenderer = this._shapeRenderer;\n                this._selectedRESTRecognizer = this._shapeRecognizer;\n                break;\n            case scope.RecognitionType.MUSIC:\n                this._selectedRenderer = this._musicRenderer;\n                this._selectedRESTRecognizer = this._musicRecognizer;\n                break;\n            case scope.RecognitionType.ANALYZER:\n                this._selectedRenderer = this._analyzerRenderer;\n                this._selectedRESTRecognizer = this._analyzerRecognizer;\n                break;\n            default:\n                throw new Error('Unknown type: ' + type);\n        }\n        this._instanceId = undefined;\n        this._initialized = false;\n        this.lastNonRecoComponentIdx = 0;\n    };\n\n    /**\n     * Get recognition type\n     *\n     * @method getType\n     * @returns {'TEXT'|'MATH'|'SHAPE'|'MUSIC'|'ANALYZER'} type\n     */\n    InkPaper.prototype.getType = function () {\n        if (this._selectedRenderer instanceof scope.TextRenderer) {\n            return scope.RecognitionType.TEXT;\n        }\n        if (this._selectedRenderer instanceof scope.MathRenderer) {\n            return scope.RecognitionType.MATH;\n        }\n        if (this._selectedRenderer instanceof scope.ShapeRenderer) {\n            return scope.RecognitionType.SHAPE;\n        }\n        if (this._selectedRenderer instanceof scope.MusicRenderer) {\n            return scope.RecognitionType.MUSIC;\n        }\n        if (this._selectedRenderer instanceof scope.AnalyzerRenderer) {\n            return scope.RecognitionType.ANALYZER;\n        }\n        throw new Error('Unknown type');\n    };\n\n    /**\n     * Get the recognition timeout\n     *\n     * @method getTimeout\n     * @returns {Number}\n     */\n    InkPaper.prototype.getTimeout = function () {\n        return this.timeout;\n    };\n\n    /**\n     * Set the recognition timeout\n     *\n     * @method setTimeout\n     * @param {Number} timeout\n     */\n    InkPaper.prototype.setTimeout = function (timeout) {\n        this.timeout = timeout;\n    };\n\n    /**\n     * Get the application key\n     *\n     * @method getApplicationKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getApplicationKey = function () {\n        return this.applicationKey;\n    };\n\n    /**\n     * Set the application key\n     *\n     * @method setApplicationKey\n     * @param {String} applicationKey\n     */\n    InkPaper.prototype.setApplicationKey = function (applicationKey) {\n        this.applicationKey = applicationKey;\n    };\n\n    /**\n     * Get the HMAC key\n     *\n     * @method getHmacKey\n     * @returns {String}\n     */\n    InkPaper.prototype.getHmacKey = function () {\n        return this.hmacKey;\n    };\n\n    /**\n     * Set the HMAC key\n     *\n     * @method setHmacKey\n     * @param {String} hmacKey\n     */\n    InkPaper.prototype.setHmacKey = function (hmacKey) {\n        this.hmacKey = hmacKey;\n    };\n\n    /**\n     * Set recognition language\n     *\n     * @deprecated Use setTextParameters instead\n     * @method setLanguage\n     * @param  String language\n     */\n    InkPaper.prototype.setLanguage = function (language) {\n        if(this.options.type === scope.RecognitionType.TEXT){\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setLanguage(language);\n        }\n    };\n\n    /**\n     * Set math recognition format result types\n     *\n     * @deprecated Use setMathParameters instead\n     * @method setResultTypes\n     * @param  Array resultTypes\n     */\n    InkPaper.prototype.setResultTypes = function (resultTypes) {\n        if(this.options.type === scope.RecognitionType.MATH){\n            this.isStarted = false;\n            this._selectedWSRecognizer.resetWSRecognition();\n            this._selectedWSRecognizer.getParameters().setResultTypes(resultTypes.map(function(x) { return x.toUpperCase(); }));\n        }\n    };\n\n    /**\n     * Set text recognition parameters\n     *\n     * @method setTextParameters\n     * @param {TextParameter} textParameters\n     */\n    InkPaper.prototype.setTextParameters = function (textParameters) {\n        if (textParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in textParameters) {\n                if (textParameters[i] !== undefined) {\n                    this._textRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._textWSRecognizer.getParameters()[i] = textParameters[i]; // Override options\n                    this._analyzerRecognizer.getParameters().getTextParameters()[i] = textParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get text recognition parameters\n     *\n     * @method getTextParameters\n     * @returns {TextParameter} textParameters\n     */\n    InkPaper.prototype.getTextParameters = function () {\n        return this._textRecognizer.getParameters();\n    };\n\n    /**\n     * Set math recognition parameters\n     *\n     * @method setMathParameters\n     * @param {MathParameter} mathParameters\n     */\n    InkPaper.prototype.setMathParameters = function (mathParameters) {\n        if (mathParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in mathParameters) {\n                if (mathParameters[i] !== undefined) {\n                    this._mathRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                    this._mathWSRecognizer.getParameters()[i] = mathParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get math recognition parameters\n     *\n     * @method getMathParameters\n     * @returns {MathParameter} mathParameters\n     */\n    InkPaper.prototype.getMathParameters = function () {\n        return this._mathRecognizer.getParameters();\n    };\n\n    /**\n     * Set shape recognition parameters\n     *\n     * @method setShapeParameters\n     * @param {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.setShapeParameters = function (shapeParameters) {\n        if (shapeParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in shapeParameters) {\n                if (shapeParameters[i] !== undefined) {\n                    this._shapeRecognizer.getParameters()[i] = shapeParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get shape recognition parameters\n     *\n     * @method getShapeParameters\n     * @returns {ShapeParameter} shapeParameters\n     */\n    InkPaper.prototype.getShapeParameters = function () {\n        return this._shapeRecognizer.getParameters();\n    };\n\n    /**\n     * Set music recognition parameters\n     *\n     * @method setMusicParameters\n     * @param {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.setMusicParameters = function (musicParameters) {\n        if (musicParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in musicParameters) {\n                if (musicParameters[i] !== undefined) {\n                    this._musicRecognizer.getParameters()[i] = musicParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get music recognition parameters\n     *\n     * @method getMusicParameters\n     * @returns {MusicParameter} musicParameters\n     */\n    InkPaper.prototype.getMusicParameters = function () {\n        return this._musicRecognizer.getParameters();\n    };\n\n    /**\n     * Set analyzer recognition parameters\n     *\n     * @method setAnalyzerParameters\n     * @param {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.setAnalyzerParameters = function (analyzerParameters) {\n        if (analyzerParameters) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            }\n            for (var i in analyzerParameters) {\n                if (analyzerParameters[i] !== undefined) {\n                    this._analyzerRecognizer.getParameters()[i] = analyzerParameters[i]; // Override options\n                }\n            }\n        }\n    };\n\n    /**\n     * Get analyzer recognition parameters\n     *\n     * @method getAnalyzerParameters\n     * @returns {AnalyzerParameter} analyzerParameters\n     */\n    InkPaper.prototype.getAnalyzerParameters = function () {\n        return this._analyzerRecognizer.getParameters();\n    };\n\n    /**\n     * Set pen parameters\n     *\n     * @method setPenParameters\n     * @param {PenParameters} penParameters\n     */\n    InkPaper.prototype.setPenParameters = function (penParameters) {\n        if (penParameters) {\n            for (var i in penParameters) {\n                if (penParameters[i] !== undefined) {\n                    this._selectedRenderer.getParameters()[i] = penParameters[i]; // Override options\n                }\n            }\n            var params = this._selectedRenderer.getParameters();\n            this._inkGrabber.setParameters(params); // Override options\n            this._textRenderer.setParameters(params); // Override options\n            this._mathRenderer.setParameters(params); // Override options\n            this._shapeRenderer.setParameters(params); // Override options\n            this._musicRenderer.setParameters(params); // Override options\n            this._analyzerRenderer.setParameters(params); // Override options\n        }\n    };\n\n    /**\n     * Get pen parameters\n     *\n     * @method getPenParameters\n     * @returns {PenParameters} penParameters\n     */\n    InkPaper.prototype.getPenParameters = function () {\n        return this._selectedRenderer.getParameters();\n    };\n\n    /**\n     * Enable / disable typeset\n     *\n     * @method setTypeset\n     * @param {Boolean} typeset\n     */\n    InkPaper.prototype.setTypeset = function (typeset) {\n        this._textRenderer.setTypeset(typeset);\n        this._mathRenderer.setTypeset(typeset);\n        this._shapeRenderer.setTypeset(typeset);\n        this._musicRenderer.setTypeset(typeset);\n        this._analyzerRenderer.setTypeset(typeset);\n    };\n\n    /**\n     * @private\n     * @method _initialize\n     * @param {Object} options\n     */\n    InkPaper.prototype._initialize = function (options) {\n\n        this._setHost(options.host);\n\n        this.setTextParameters(options.textParameters); // jshint ignore:line\n        this.setMathParameters(options.mathParameters); // jshint ignore:line\n        this.setShapeParameters(options.shapeParameters); // jshint ignore:line\n        this.setMusicParameters(options.musicParameters); // jshint ignore:line\n        this.setAnalyzerParameters(options.analyzerParameters); // jshint ignore:line\n\n        // Recognition type\n        this.setType(options.type);\n        this.setProtocol(options.protocol);\n        this.setTimeout(options.timeout);\n        this.setApplicationKey(options.applicationKey);\n        this.setHmacKey(options.hmacKey);\n\n        this.setPenParameters(options.penParameters);\n        this.setTypeset(options.typeset);\n\n        this.setWidth(options.width);\n        this.setHeight(options.height);\n    };\n\n    /**\n     * Get options\n     *\n     * @private\n     * @method _getOptions\n     * @returns {Object}\n     */\n    InkPaper.prototype._getOptions = function () {\n        return this.options;\n    };\n\n    /**\n     * Get available languages\n     *\n     * @method getAvailableLanguages\n     * @returns {Promise}\n     */\n    InkPaper.prototype.getAvailableLanguages = function () {\n        return this._selectedRecognizer.getAvailableLanguageList(this.getApplicationKey(), this._textRecognizer.getParameters().getInputMode());\n    };\n\n    /**\n     * Get the renderer\n     *\n     * @method getRenderer\n     * @returns {AbstractRenderer}\n     */\n    InkPaper.prototype.getRenderer = function () {\n        return this._selectedRenderer;\n    };\n\n    /**\n     * Get the ink capturer\n     *\n     * @method getInkGrabber\n     * @returns {InkGrabber}\n     */\n    InkPaper.prototype.getInkGrabber = function () {\n        return this._inkGrabber;\n    };\n\n    /**\n     * Get the recognizer\n     *\n     * @method getRecognizer\n     * @returns {AbstractRecognizer}\n     */\n    InkPaper.prototype.getRecognizer = function () {\n        return this._selectedRecognizer;\n    };\n\n    /**\n     * Set the recognition callback\n     *\n     * @method setCallback\n     * @deprecated Use setResultCallback instead\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     * @param {Object} callback.err The err to the callback\n     */\n    InkPaper.prototype.setCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Set the change callback\n     *\n     * @method setChangeCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The inkPaper state\n     */\n    InkPaper.prototype.setChangeCallback = function (changeCallback) {\n        this.changeCallback = changeCallback;\n    };\n\n    /**\n     * Set the recognition result callback\n     *\n     * @method setResultCallback\n     * @param {Function} callback callback function\n     * @param {Object} callback.data The recognition result\n     */\n    InkPaper.prototype.setResultCallback = function (callback) {\n        this.resultCallback = callback;\n    };\n\n    /**\n     * Recognize\n     *\n     * @method recognize\n     * @returns {Promise}\n     */\n    InkPaper.prototype.recognize = function () {\n        return this._doRecognition(this.components);\n    };\n\n    /**\n     * Return true if you can undo\n     *\n     * @method canUndo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canUndo = function () {\n        return this.components.length > 0;\n    };\n\n    /**\n     * Undo\n     *\n     * @method undo\n     */\n    InkPaper.prototype.undo = function () {\n        if (this.canUndo()) {\n            this.redoComponents.push(this.components.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.isStarted = false;\n                this._selectedRecognizer.resetWSRecognition();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Return true if you can redo\n     *\n     * @method canRedo\n     * @returns {Boolean}\n     */\n    InkPaper.prototype.canRedo = function () {\n        return this.redoComponents.length > 0;\n    };\n\n    /**\n     * Redo\n     *\n     * @method redo\n     */\n    InkPaper.prototype.redo = function () {\n        if (this.canRedo()) {\n            this.components.push(this.redoComponents.pop());\n\n            if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                this.lastNonRecoComponentIdx = 0;\n                if (this._instanceId) {\n                    this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                    this._inkGrabber.clear();\n                    this._instanceId = undefined;\n                }\n            }\n            this._initRenderingCanvas();\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                this.recognize();\n            } else {\n                clearTimeout(this._timerId);\n                if (this.getTimeout() > 0) {\n                    this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n                } else if (this.getTimeout() > -1) {\n                    this.recognize();\n                } else {\n                    this._onResult();\n                }\n            }\n        }\n    };\n\n    /**\n     * Clear the ink paper\n     *\n     * @method clear\n     */\n    InkPaper.prototype.clear = function () {\n        if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n            if (this._instanceId) {\n                this._selectedRecognizer.clearShapeRecognitionSession(this.getApplicationKey(), this._instanceId);\n                this._instanceId = undefined;\n            }\n        }\n        this.components = [];\n        this.redoComponents = [];\n        this.lastNonRecoComponentIdx = 0;\n        this._inkGrabber.clear();\n        this._instanceId = undefined;\n\n        this._initRenderingCanvas();\n        this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            this.isStarted = false;\n            this._selectedRecognizer.resetWSRecognition();\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            } else {\n                this._onResult();\n            }\n        }\n    };\n\n    InkPaper.event = {\n        'addDomListener': function (element, useCapture, myfunction) {\n            element.addEventListener(useCapture, myfunction);\n        }\n    };\n\n    /**\n     *\n     * @private\n     * @method _down\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._down = function (x, y, t) {\n\n        if(this._captureCanvas.clientHeight != this._captureCanvas.height){\n            this._captureCanvas.height = this._captureCanvas.clientHeight;\n            this._renderingCanvas.height = this._renderingCanvas.clientHeight;\n        }\n        if(this._captureCanvas.clientWidth != this._captureCanvas.width){\n            this._captureCanvas.width = this._captureCanvas.clientWidth;\n            this._renderingCanvas.width = this._renderingCanvas.clientWidth;\n        }\n\n        if (this.canRedo()) {\n            this.redoComponents = [];\n            this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n        }\n        this._inkGrabber.startCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._move = function (x, y, t) {\n        this._inkGrabber.continueCapture(x, y, t);\n    };\n\n    /**\n     *\n     * @private\n     * @method _move\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Date} [t] timeStamp\n     */\n    InkPaper.prototype._up = function (x, y, t) {\n        this._inkGrabber.endCapture(x, y, t);\n\n        var stroke = this._inkGrabber.getStroke();\n\n        this._inkGrabber.clear();\n        this._selectedRenderer.drawComponent(stroke);\n\n        this.components.push(stroke);\n        this._onChange({canUndo: this.canUndo(), canRedo: this.canRedo()});\n\n        if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n            if (!this._selectedRecognizer.isOpen() && !this._selectedRecognizer.isConnecting()) {\n                this._selectedRecognizer.open();\n            } else {\n                this.recognize();\n            }\n        } else {\n            clearTimeout(this._timerId);\n            if (this.getTimeout() > 0) {\n                this._timerId = setTimeout(this.recognize.bind(this), this.getTimeout());\n            } else if (this.getTimeout() > -1) {\n                this.recognize();\n            }\n        }\n    };\n\n    /**\n     * Do recognition\n     *\n     * @private\n     * @method _doRecognition\n     * @param {AbstractComponent[]} components Input components\n     */\n    InkPaper.prototype._doRecognition = function (components) {\n        if (components.length > 0) {\n            if (this._selectedRecognizer instanceof scope.AbstractWSRecognizer) {\n                if (this._initialized) {\n                    var inputWS = [];\n                    if (this._selectedRecognizer instanceof scope.TextWSRecognizer) {\n                        var inputUnitWS = new scope.TextInputUnit();\n                        inputUnitWS.setComponents(this._getOptions().components.concat(components.slice(this.lastNonRecoComponentIdx)));\n                        inputWS = [inputUnitWS];\n                    } else {\n                        inputWS = components.slice(this.lastNonRecoComponentIdx);\n                    }\n                    this.lastNonRecoComponentIdx = components.length;\n\n\n                    if (this.isStarted) {\n                        this._selectedRecognizer.continueWSRecognition(inputWS, this._instanceId);\n                    } else {\n                        this.isStarted = true;\n                        this._selectedRecognizer.startWSRecognition(inputWS);\n                    }\n                }\n            } else {\n                var input = [];\n                if (this._selectedRecognizer instanceof scope.TextRecognizer) {\n                    var inputUnit = new scope.TextInputUnit();\n                    inputUnit.setComponents(this._getOptions().components.concat(components));\n                    input = [inputUnit];\n                } else if (this._selectedRecognizer instanceof scope.ShapeRecognizer) {\n                    input = components.slice(this.lastNonRecoComponentIdx);\n                    this.lastNonRecoComponentIdx = components.length;\n                } else {\n                    input = input.concat(this._getOptions().components, components);\n                }\n                this._selectedRecognizer.doSimpleRecognition(\n                    this.getApplicationKey(),\n                    this._instanceId,\n                    input,\n                    this.getHmacKey()\n                ).then(\n                    function (data) {\n                        return this._parseResult(data, input);\n                    }.bind(this),\n                    function (error) {\n                        this._onResult(undefined, error);\n                        return error;\n                    }.bind(this)\n                ).done();\n            }\n        } else {\n            this.isStarted = false;\n            this._selectedRenderer.clear();\n            this._initRenderingCanvas();\n            this._onResult();\n        }\n    };\n\n    InkPaper.prototype._onResult = function (data, err) {\n        if (this.resultCallback) {\n            this.resultCallback(data, err);\n        }\n        if (err) {\n            this._element.dispatchEvent(new CustomEvent('failure', {detail: err}));\n        } else {\n            this._element.dispatchEvent(new CustomEvent('success', {detail: data}));\n        }\n    };\n\n    InkPaper.prototype._onChange = function (changes) {\n        if (this.changeCallback) {\n            this.changeCallback(changes)\n        }\n        this._element.dispatchEvent(new CustomEvent('changed', {detail: changes}));\n    };\n\n    InkPaper.prototype._parseResult = function (data, input) {\n\n        if (!this._instanceId) {\n            this._instanceId = data.getInstanceId();\n        } else if (this._instanceId !== data.getInstanceId()) {\n            this._onResult(data);\n            return data;\n        }\n\n        if (data.getDocument().hasScratchOutResults() || this._selectedRenderer.isTypesetting()) {\n            this._selectedRenderer.clear();\n            this._selectedRenderer.drawRecognitionResult(input, data.getDocument());\n        }\n\n        this._onResult(data);\n        return data;\n    };\n\n    /**\n     * Set recognition service host\n     *\n     * @private\n     * @param {String} host\n     */\n    InkPaper.prototype._setHost = function (host) {\n        this._textRecognizer.setHost(host);\n        this._mathRecognizer.setHost(host);\n        this._shapeRecognizer.setHost(host);\n        this._musicRecognizer.setHost(host);\n        this._analyzerRecognizer.setHost(host);\n    };\n\n    /**\n     * Tool to attach touch events\n     *\n     * @private\n     * @param {Element} element\n     */\n    InkPaper.prototype._attachListeners = function (element) {\n        var self = this;\n        var pointerId;\n        element.addEventListener('pointerdown', function (e) {\n            if (!pointerId) {\n                pointerId = e.pointerId;\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._down(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointermove', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._move(coord.x, coord.y, coord.t);\n            }\n        }, false);\n\n        element.addEventListener('pointerup', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n                console.log('pointerenter');\n                console.log(e);\n            }\n        }, false);\n\n        element.addEventListener('pointerleave', function (e) {\n            if (pointerId === e.pointerId) {\n                e.preventDefault();\n\n                var coord = _getCoordinates(e, element);\n                self._up(coord.x, coord.y, coord.t);\n\n                pointerId = undefined;\n            }\n        }, false);\n    };\n\n    InkPaper.prototype._initRenderingCanvas = function () {\n        this._selectedRenderer.clear();\n        this._drawInput(this.components);\n    };\n\n    InkPaper.prototype._drawInput = function (components) {\n        if (this._selectedRecognizer instanceof scope.MusicRecognizer) {\n            if (this._selectedRecognizer.getParameters().getStaff() instanceof scope.MusicStaff) {\n                this._selectedRenderer.drawStaff(this._selectedRecognizer.getParameters().getStaff());\n            } else {\n                throw new Error('Missing music staff');\n            }\n        }\n        this._selectedRenderer.drawComponents(this._getOptions().components.concat(components));\n    };\n\n    /**\n     *\n     * @param message\n     * @param error\n     * @returns {boolean} false no immediate replay needed, true when the call need to be replay ASAP\n     * @private\n     */\n    InkPaper.prototype._handleMessage = function (message, error) {\n        var replayNeeded = false;\n        if (error) {\n            replayNeeded = true;\n            this._instanceId = undefined;\n            this.isStarted = false;\n            this.lastNonRecoComponentIdx = 0;\n            this._onResult(undefined, error);\n        }\n\n        if (message) {\n            switch (message.type) {\n                case 'open':\n                    this._selectedWSRecognizer.initWSRecognition(this.getApplicationKey());\n                    break;\n                case 'hmacChallenge':\n                    this._selectedWSRecognizer.takeUpHmacChallenge (this.getApplicationKey(), message.getChallenge(), this.getHmacKey());\n                    break;\n                case 'init':\n                    this.isStarted = false;\n                    this._initialized = true;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'reset':\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    this.recognize();\n                    break;\n                case 'close':\n                    this._initialized = false;\n                    this._instanceId = undefined;\n                    this.lastNonRecoComponentIdx = 0;\n                    break;\n                default: {\n                    this._parseResult(message, this.components);\n                    break;\n                }\n            }\n        }\n        return replayNeeded;\n    };\n\n    /**\n     * Tool to create canvas\n     *\n     * @private\n     * @param {Element} parent\n     * @param {String} id\n     * @returns {Element}\n     */\n    function _createCanvas(parent, id) {\n        var count = document.querySelectorAll('canvas[id^=' + id + ']').length;\n        var canvas = document.createElement('canvas');\n        canvas.id = id + '-' + count;\n        parent.appendChild(canvas);\n        return canvas;\n    }\n\n\n    /**\n     * Tool to get proper coordinates\n     *\n     * @private\n     * @param {Event} e\n     * @param {Element} element\n     * @returns {Object}\n     */\n    function _getCoordinates(e, container) {\n        if (e.changedTouches) e = e.changedTouches[0];\n        var rect = container.getBoundingClientRect();\n        return {\n            x: e.clientX - rect.left - container.clientLeft,\n            y: e.clientY - rect.top - container.clientTop,\n            t: e.timeStamp\n        };\n    }\n\n    // Export\n    scope.InkPaper = InkPaper;\n})(MyScript);\n"],"sourceRoot":"/source/"}